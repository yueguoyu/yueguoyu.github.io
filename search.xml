<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树的最大深度]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F11%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 解法： 使用递归，和递归遍历差不多。先遍历左子树，再遍历右子树，最后返回最大数加一。 12345678public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left, right) + 1; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排他锁（写锁），共享锁（读锁）死锁 和 活锁]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F11%2F%E6%8E%92%E4%BB%96%E9%94%81%EF%BC%88%E5%86%99%E9%94%81%EF%BC%89%EF%BC%8C%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%88%E8%AF%BB%E9%94%81%EF%BC%89%E6%AD%BB%E9%94%81%20%E5%92%8C%20%E6%B4%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[排他锁（写锁），共享锁（读锁）死锁 和 活锁排他锁（写锁，X锁）： 事务t对数据a加上X锁，则只允许事务t对a进行读取，和修改，其他事务都不能对a加任何类型的锁，直到t释放a上的锁为止。就保证了其他事务在t事务在对a释放之前，不能对a进行修改和读取。 共享锁（读锁，S锁）： 若事务t对数据a加上s锁，则事务t可以读a但不能修改a，其他事务可以对a加s锁，而在t没有释放a的锁时不能加x锁，表示其他事务可以读取a的数据，但在t释放a 的s锁之前不能对a进行修改。 分所类型的相容矩阵 概述： 在数据库系统中，封锁的方法可能引起活锁和死锁 活锁：如果事务t1封锁了数据r，事务t2又请求封锁r，于是t2等待；T3也请求封锁r，当t1释放r上的锁之后系统首先批准t3的请求，t2接着等，t4也请求封锁r，t3释放r系统又批准t4，就不给r2，r2一直等啊等，永远的等下去，这就是活锁的情景。 避免活锁： 系统采用先来先服务的策略。（先到先得） 死锁：如果事务t1封锁r1，t2封锁了r2，然后r1又请求封锁r2，因为t2已经封锁r2，于是t1等待t2释放r2上的锁；接着t2又申请封锁r1，又因为t1已经封锁了r1，所以t2等待t1释放r1的锁，就这样t1等t2放锁，t2等t1放锁，所以这两个事务将永远不能结束。就形成了死锁。 死锁的预防（不适用）： 1.一次封锁法 一次封锁法要求每个事务必须一次将所有使用的数据全部加锁，否则就不能继续执行。如上面的例子中，如果t1将r1和r2都加锁，当t1释放锁后t2在加锁，这样就不会发生死锁。 2.顺序封锁法 顺序封锁法是加锁前先对数据对象指定一个封锁顺序，所有事务都按照这个顺序执行。 缺点：太复杂，成本高， 死锁的诊断与解除 超时法：当一个事务的等待时间超过了规定的时间，就认为发生了死锁。 缺点：时间设置太短，发生误判，时间太长，不能及时发现 等待图法：事务等待图是一个有向图G=(T,U)，t为节点的集合，每个节点表示一个事务；u为边的集合，每个边表示事务等待的情况；t1等待t2，t1指向t2一条线。 同常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有所有的锁，使其他事务得以继续运行下去。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库隔离级别]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F10%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[数据库隔离级别原文 事务数据库事务（Transaction）是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。一方面，当多个应用程序并发访问数据库时，事务可以在应用程序间提供一个隔离方法，防止互相干扰。另一方面，事务为数据库操作序列提供了一个从失败恢复正常的方法。 事务的四个特性事务具有四个特性：原子性（Atomicity）、一致性（Consistency）、隔离型（Isolation）、持久性（Durability），简称ACID。 原子性（Atomicity） 事务的原子性是指事务中的操作不可拆分，只允许全部执行或者全部不执行。 一致性（Consistency） 事务的一致性是指事务的执行不能破坏数据库的一致性，一致性也称为完整性。一个事务在执行后，数据库必须从一个一致性状态转变为另一个一致性状态。 隔离型（Isolation） 事务的隔离型是指并发的事务相互隔离，不能互相干扰。 持久性（Durability） 事务的持久性是指事务一旦提交，对数据的状态变更应该被永久保存。 数据库隔离级别对于同时运行的多个事务,当这些事务访问数据库中相同的数据时,如果没有采取必要的隔离机制,就会导致各种并发问题: 脏读：对于两个事务T1，T2，T1读取了已经被T2更新但还没有提交的字段，之后，若T2回滚，T1读取到的内容就是临时无效的内容。 不可重复读：对于事务T1，T2，T1需要读取一个字段两次，在第一次和第二次读取之间，T2更新了该字段，导致T1第二次读取到的内容值不同。 幻读： 事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。 幻读与不可重复读之间的区别是幻读强调的是新增或删除,而不可重复读强调的是修改。比如Mary两次查工资，中间有人改过工资，则两次结果不一样，这就是不可重复读。Mary要查工资一千的人数，第一次查到了10个，中间有人增加了一条工资为一千的人，下次查的时候就变成了11个，好像第一次查询的是幻觉一样。 事务的四个隔离级别 实际工作中事务几乎都是并发的，完全做到互相之间不干扰会严重牺牲性能，为了平衡隔离型和性能，SQL92规范定义了四个事务隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）、串行化（Serializable）。四个级别逐渐增强，每个级别解决上个级别的一个问题。 读未提交（Read Uncommitted） 另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）。 脏读是指另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据。 读已提交（Read Committed） 本事务读取到的是最新的数据（其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不可重复读）。 不可重复读是指同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。 可重复读（Repeatable Read） 在同一个事务里，SELECT的结果是事务开始时间点的状态，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象。 可重复读保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会发现了这些新数据，貌似之前读到的数据是幻觉，这就是幻读。 串行化（Serializable） 所有事务只能一个接一个串行执行，不能并发。 隔离级别的选择 事务隔离级别越高，越能保证数据的一致性，但对并发性能影响越大，一致性和高性能必须有所取舍或折中。 一般情况下，多数应用程序可以选择将数据库的隔离级别设置为读已提交，这样可以避免脏读，也可以得到不错的并发性能。尽管这个隔离级别会导致不可重复度、幻读，但这种个别场合应用程序可以通过主动加锁进行并发控制。 Oracle支持两种隔离级别，READ COMMITED和SERIALIZABLE默认的事务隔离级别是READ COMMITED MYSQL支持4中隔离界别，默认的是REPEATED READ]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共前缀]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F09%2F%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解法： 由于只是最长公共前缀，先将字符数组排序，只比较最小和最大的字符串。 1234567891011121314151617public static String longestCommonPrefix1(String[] strs) &#123; StringBuilder builder = new StringBuilder(); if (strs != null &amp;&amp; strs.length &gt; 0) &#123; Arrays.sort(strs); char[] a = strs[0].toCharArray(); char[] b = strs[strs.length - 1].toCharArray(); for (int i = 0; i &lt; a.length; i++) &#123; if (b.length &gt; i &amp;&amp; a[i] == b[i]) &#123; builder.append(a[i]); &#125; else &#123; return builder.toString(); &#125; &#125; &#125; return builder.toString(); &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证二叉搜索树]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F08%2F%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。 一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \ 1 3输出: true 示例 2: 123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解法： 1.根据定义判断，使用递归，设置一个min和max，当节点的值大于max时false，节点值小与min时false，遍历完返回true。 2.先中序遍历，然后判断得到的链表是否是递增的。 12345678910111213141516public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return dfs(root,Long.MIN_VALUE,Long.MAX_VALUE); &#125; public boolean dfs(TreeNode root,long min,long max)&#123; if (root==null)&#123; return true; &#125; if (root.val&lt;=min||root.val&gt;=max)&#123; return false; &#125; return dfs(root.left,min,root.val)&amp;&amp;dfs(root.right,root.val,max); &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql语法随笔]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F08%2Fmysql%E8%AF%AD%E6%B3%95%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[mysql语法随笔创建数据库 1CREATE DATABASE 数据库名; drop 命令删除数据库drop 命令格式： 1drop database &lt;数据库名&gt;; mysql创建表 以下为创建MySQL数据表的SQL通用语法： 1CREATE TABLE table_name (column_name column_type); 以下例子中我们将在 RUNOOB 数据库中创建数据表runoob_tbl： 1234567CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8; 实例解析： 如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 删除表 1DROP TABLE TABLE_NAME; 插入数据 1INSERT INTO TABLE_NAME(f1,f2,f3) VALUES (v1,v2,v3); 查询数据 1234SELECT COLUM_NAME,COLUM_NAMEFROM TABLE_NAME[WHERE Clause][LIMIT N][OFFSET M] 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件。 你可以使用 LIMIT 属性来设定返回的记录数。 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 where子句 12SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2..... 查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用WHERE语句来设定查询条件。 你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。 WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。 UPDATE查询 12UPDATE TABLE_NAME SET f1=new-value,f2=new-value[WHERE Clause] DELETE语句 1DELETE FROM table_name [WHERE Clause] LIKE语句 12SELECT f1,f2,f3 FROM table_nameWHERE f1 LIKE condition1[AND[OR]] f2=&apos;somevalue&apos; 你可以在 WHERE 子句中指定任何条件。 你可以在 WHERE 子句中使用LIKE子句。 你可以使用LIKE子句代替等号 =。 LIKE 通常与 % 一同使用，类似于一个元字符的搜索。 你可以使用 AND 或者 OR 指定一个或多个条件。 你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。 UNION操作符 Union可以将两个select语句的结果组合 1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据。 排序 1SELECT F1,F2 FROM TABLE_NAME ORDER BY F1[ASC[DECS]] 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 WHERE…LIKE 子句来设置条件。 GROUP BY分组 GROUP BY 语句根据一个或多个列对结果集进行分组。 在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 1234SELECT column_name,function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY cOLUMN_NAME; 12345678910111213mysql&gt; set names utf8;mysql&gt; SELECT * FROM employee_tbl;+----+--------+---------------------+--------+| id | name | date | singin |+----+--------+---------------------+--------+| 1 | 小明 | 2016-04-22 15:25:33 | 1 || 2 | 小王 | 2016-04-20 15:25:47 | 3 || 3 | 小丽 | 2016-04-19 15:26:02 | 2 || 4 | 小王 | 2016-04-07 15:26:14 | 4 || 5 | 小明 | 2016-04-11 15:26:40 | 4 || 6 | 小明 | 2016-04-04 15:26:54 | 2 |+----+--------+---------------------+--------+6 rows in set (0.00 sec) 接下来我们使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录： 123456789mysql&gt; SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;+--------+----------+| name | COUNT(*) |+--------+----------+| 小丽 | 1 || 小明 | 3 || 小王 | 2 |+--------+----------+3 rows in set (0.01 sec) 使用 WITH ROLLUPWITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。 例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数： 12345678910mysql&gt; SELECT name, SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------+--------------+| name | singin_count |+--------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || NULL | 16 |+--------+--------------+4 rows in set (0.00 sec) LIMIT m,n : 表示从第m+1条开始，取n条数据； LIMIT n ： 表示从第0条开始，取n条数据，是limit(0,n)的缩写。 SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。 最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行 INNER JOIN：如果表中有至少一个匹配，则返回行 SELECT column_name(s)FROM table1INNER JOIN table2ON table1.column_name=table2.column_name; 或： SELECT column_name(s)FROM table1JOIN table2ON table1.column_name=table2.column_name; LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name=table2.column_name; RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 SELECT column_name(s) FROM table1 RIGHT JOIN table2 ON table1.column_name=table2.column_name; FULL JOIN：只要其中一个表中存在匹配，则返回行 IN 操作符IN 操作符允许您在 WHERE 子句中规定多个值。 SQL IN 语法SELECT column_name(s)FROM table_nameWHERE column_name IN (value1,value2,…); SQL BETWEEN 操作符BETWEEN 操作符选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。 SQL BETWEEN 语法SELECT column_name(s)FROM table_nameWHERE column_name BETWEEN value1 AND value2; SQL 别名通过使用 SQL，可以为表名称或列名称指定别名。 基本上，创建别名是为了让列名称的可读性更强。 列的 SQL 别名语法SELECT column_name AS alias_nameFROM table_name; 表的 SQL 别名语法SELECT column_name(s)FROM table_name AS alias_name; SQL UNION 操作符 SQL UNION 操作符合并两个或多个 SELECT 语句的结果。 SQL UNION 操作符UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法SELECT column_name(s) FROM table1UNIONSELECT column_name(s) FROM table2; 注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 SQL UNION ALL 语法SELECT column_name(s) FROM table1UNION ALLSELECT column_name(s) FROM table2; 注释：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 MySQL 数据库不支持 SELECT … INTO 语句，但支持 INSERT INTO … SELECT 。 当然你可以使用以下语句来拷贝表结构及数据： 1CREATE TABLE 新表 SELECT * FROM 旧表]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 存储引擎MyISAM和InnoDB的区别]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F08%2Fmysql%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[mysql 存储引擎概述：数据库存储引擎是数据库底层软件组件，数据库管理系统（DBMS）使用数据引擎进行创建，查询，更新和删除数据操作。不同的存储引擎提供不同的存储机制，索引技巧，锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。 mysql提供了不同的存储引擎，mysql中不需要整个服务器用一个引擎，针对具体的要求，一个表可以用多个存储引擎。 InnoDB存储引擎 InnoDB事物型数据库首选的存储引擎，InnoDB主要特征： 1.InnoDB给mysql提供了具有提交，回滚，崩溃恢复能力的事物安全（ACID兼容）存储引擎。 2.InnoDB为了处理巨大数据量的最大性能设计。他的cpu效率相比与其他存储引擎是最好的。 3.InnoDB存储引擎完全与mysql服务器整合，InnoDB将索引和表放在一个逻辑表空间中，表空间可以包含数个文件。而MyISAM表中每个表被存在在分离的文件中。 4.InnoDB支持外键完整性约束。当表没有指定主键时，InnoDB会为每一行生成一个6字节的ROWID，并以此为主键。 5.InnoDB应用在众多需要高性能的大型数据库站点上。 InnoDB不创建目录，使用InnoDB时，MySQL在mysql数据目录下创建一个名为ibdata1的10mb大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5mb大小的日志文件。 MyISAM存储引擎 MyISAM基于ISAM，他是在web，数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入，查询速度，但不支持事务。每张MyISAM表存放在三个文件中：frm 文件存放表格定义；数据文件是MYD (MYData)；索引文件是MYI (MYIndex)。 MyISAM和InnoDB的区别： 一、InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。 二、MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用 三、InnoDB支持外键，MyISAM不支持 四、MyISAM是默认引擎，InnoDB需要指定 五、InnoDB不支持FULLTEXT类型的索引 六、InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表 七、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引 八、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表 九、InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’ 应用场景： MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。 InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。 常用命令： （1）查看表的存储类型（三种）： show create table tablename show table status from dbname where name=tablename mysqlshow -u user -p password –status dbname tablename （2）修改表的存储引擎： alter table tablename type=InnoDB （3）启动mysql数据库的命令行中添加以下参数使新发布的表都默认使用事务： –default-table-type=InnoDB （4）临时改变默认表类型： set table_type=InnoDB show variables like ‘table_type’ 参考：1.http://www.cnblogs.com/panfeng412/archive/2011/08/16/2140364.html 2.https://my.oschina.net/junn/blog/183341]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二高的薪水]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F07%2F176.%20%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[176. 第二高的薪水题目描述提示帮助提交记录社区讨论阅读解答 SQL架构随机一题 编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。 12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ 先排序再改名 1select (select distinct Salary from Employee order by Salary desc limit 1,1) as SecondHighestSalary; 使用 DISTINCT 关键词去重，否则报错]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合两个表]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F07%2F175.%20%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[175. 组合两个表题目描述提示帮助提交记录社区讨论阅读解答 SQL架构随机一题 表1: Person 12345678+-------------+---------+| 列名 | 类型 |+-------------+---------+| PersonId | int || FirstName | varchar || LastName | varchar |+-------------+---------+PersonId 是上表主键 表2: Address 123456789+-------------+---------+| 列名 | 类型 |+-------------+---------+| AddressId | int || PersonId | int || City | varchar || State | varchar |+-------------+---------+AddressId 是上表主键 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息： 1FirstName, LastName, City, State 使用left join连接两个表 123select p.FirstName, p.LastName, a.City, a.Statefrom Person p left join Address aon p.PersonId=a.PersonId; SQL LEFT JOIN 关键字LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的层次遍历 II]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F06%2F107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II%2F</url>
    <content type="text"><![CDATA[107. 二叉树的层次遍历 II 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其自底向上的层次遍历为： 12345[ [15,7], [9,20], [3]] 解法： 使用队列来实现二叉树的层遍历。 1234567891011121314151617181920212223242526272829303132333435/** * 自下而上的层遍历 * 从叶子节点所在层到根节点所在的层，逐层从左向右遍历 * @param root * @return */public List&lt;List&lt;Integer&gt;&gt; cen1(TreeNode root)&#123; List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;(); if (root==null)&#123; return lists; &#125; LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;(); treeNodes.add(root); while(!treeNodes.isEmpty())&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); int size=treeNodes.size(); for (int i=0;i&lt;size;i++)&#123; TreeNode n=treeNodes.pop(); list.add(n.val); if (n.l!=null)&#123; treeNodes.add(n.l); &#125; if (n.r!=null)&#123; treeNodes.add(n.r); &#125; &#125; lists.add(list); &#125; List&lt;List&lt;Integer&gt;&gt; lists1=new ArrayList&lt;&gt;(); for(int i=lists.size()-1;i&gt;=0;i--)&#123; lists1.add(lists.get(i)); &#125; return lists1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的层次遍历1]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F06%2F102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[102. 二叉树的层次遍历给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 解法： 二叉树的层遍历使用队列，将节点放入队列中，当节点出队时判断该节点的左，右子树是否为空，如果不为空将其放入队列中，本题因为题目要求每次创建一个新的list将每一层的节点添加到list中，size为队列的大小，用来判断队列中的节点是否全部出来。 1234567891011121314151617181920212223242526272829/** * 自上而下层遍历 * @param root */public List&lt;List&lt;Integer&gt;&gt; cen2(TreeNode root)&#123; List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;(); if (root==null)&#123; return lists; &#125;//使用队列 LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;(); treeNodes.add(root); while(!treeNodes.isEmpty())&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); int size=treeNodes.size(); for (int i=0;i&lt;size;i++)&#123; TreeNode n=treeNodes.pop(); list.add(n.val); if (n.l!=null)&#123; treeNodes.add(n.l); &#125; if (n.r!=null)&#123; treeNodes.add(n.r); &#125; &#125; lists.add(list); &#125; return lists;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的创建，前序，中序，后序，层遍历]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F06%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%EF%BC%8C%E5%90%8E%E5%BA%8F%EF%BC%8C%E5%B1%82%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的创建，前序，中序，后序，层遍历深度优先搜素用栈，广度优先用队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256package T74;import sun.awt.image.ImageWatched;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Stack;public class BinTree &#123; private int size; /** * root为二叉树的头节点 */ private TreeNode root; private int [] date; BinTree(int [] date)&#123; this.date=date; this.size=date.length; this.root=CreatTree(0); &#125; class TreeNode&#123; TreeNode l; TreeNode r; int val; TreeNode(int val)&#123; this.val=val; &#125; &#125; /** *创建二叉树 * index为date数组的下标 * @param index */ public TreeNode CreatTree(int index)&#123; if (index&gt;=size)&#123; return null; &#125; TreeNode treeNode=new TreeNode(date[index]); treeNode.l=CreatTree(2*index+1); treeNode.r=CreatTree(2*(index+1)); return treeNode; &#125; /** * 递归实现前序遍历 * @param root */ public void qx(TreeNode root)&#123; if (root==null)&#123; return ; &#125; System.out.print(root.val+&quot; &quot;); qx(root.l); qx(root.r); &#125; /** * 用栈实现 * @param root */ public void qx1(TreeNode root)&#123; if (root==null)&#123; return ; &#125; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); while(root!=null||!stack.empty())&#123; while(root!=null)&#123; System.out.print(root.val+&quot; &quot;); stack.push(root); root=root.l; &#125; if (!stack.empty())&#123; root=stack.pop(); root=root.r; &#125; &#125; &#125; /** * 中序 递归 * @param root */ public void zx(TreeNode root)&#123; if (root!=null)&#123; zx(root.l); System.out.print(root.val+&quot; &quot;); zx(root.r); &#125; &#125; /** * 栈实现 中序 * @param root */ public void zx1(TreeNode root)&#123; if (root==null)&#123; return ; &#125; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); while (root!=null||!stack.empty())&#123; while(root!=null)&#123; stack.push(root); root=root.l; &#125; if (!stack.empty())&#123; root=stack.pop(); System.out.print(root.val+&quot; &quot;); root=root.r; &#125; &#125; &#125; /** * 递归 后序 * @param root */ public void hx(TreeNode root)&#123; if (root!=null)&#123; hx(root.l); hx(root.r); System.out.print(root.val+&quot; &quot;); &#125; &#125; /** * 栈实现 后序 * @param root */ public void hx1(TreeNode root)&#123; if (root==null)&#123; return ; &#125; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); //游标list指向节点的右子树，遍历完指向节点 TreeNode list=null; while(root!=null||!stack.empty())&#123; while(root!=null)&#123; stack.push(root); root=root.l; &#125; root=stack.peek(); //如果节点的右子树为空或者已经遍历完 if (root.r==null||root.r==list)&#123; System.out.print(root.val+&quot; &quot;); root=stack.pop(); list=root; root=null; &#125;else &#123; root=root.r; &#125; &#125; &#125; /** * 层遍历 * @param root */ public void cen(TreeNode root)&#123; if (root==null)&#123; return ; &#125; LinkedList&lt;TreeNode&gt; q=new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty())&#123; root=q.poll(); System.out.print(root.val+&quot; &quot;); if (root.l!=null)&#123; q.add(root.l); &#125; if (root.r!=null)&#123; q.add(root.r); &#125; &#125; &#125; /** * 自下而上的层遍历 * 从叶子节点所在层到根节点所在的层，逐层从左向右遍历 * @param root * @return */ public List&lt;List&lt;Integer&gt;&gt; cen1(TreeNode root)&#123; List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;(); if (root==null)&#123; return lists; &#125; LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;(); treeNodes.add(root); while(!treeNodes.isEmpty())&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); int size=treeNodes.size(); for (int i=0;i&lt;size;i++)&#123; TreeNode n=treeNodes.pop(); list.add(n.val); if (n.l!=null)&#123; treeNodes.add(n.l); &#125; if (n.r!=null)&#123; treeNodes.add(n.r); &#125; &#125; lists.add(list); &#125; List&lt;List&lt;Integer&gt;&gt; lists1=new ArrayList&lt;&gt;(); for(int i=lists.size()-1;i&gt;=0;i--)&#123; lists1.add(lists.get(i)); &#125; return lists1; &#125; /** * 自上而下层遍历 * @param root */ public List&lt;List&lt;Integer&gt;&gt; cen2(TreeNode root)&#123; List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;(); if (root==null)&#123; return lists; &#125; LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;(); treeNodes.add(root); while(!treeNodes.isEmpty())&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); int size=treeNodes.size(); for (int i=0;i&lt;size;i++)&#123; TreeNode n=treeNodes.pop(); list.add(n.val); if (n.l!=null)&#123; treeNodes.add(n.l); &#125; if (n.r!=null)&#123; treeNodes.add(n.r); &#125; &#125; lists.add(list); &#125; return lists; &#125; public static void main(String[] args) &#123; int [] date=new int[]&#123;1,2,3,4,5,6,7&#125;; BinTree tree=new BinTree(date); tree.hx(tree.root); System.out.println(); tree.hx1(tree.root); System.out.println(); tree.cen(tree.root); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的层次遍历]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F04%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的层次遍历给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 解法： 广度优先用队列 深度优先用栈 层次遍历是广度优先，所以用队列 使用队列实现树的分层遍历，先将树的头节点加入队列，然后将节点弹出队列，再判断这个节点的左子节点是否存在，如果存在加入队列，再判断这个节点的右子节点是否存在，如果存在加入队列。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; lists=new LinkedList&lt;&gt;(); if(root==null)&#123; return lists; &#125; //使用LinkedList实现队列 LinkedList&lt;TreeNode&gt; q=new LinkedList&lt;&gt;(); //将root加入队列 q.add(root); //遍历队列 while(!q.isEmpty())&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); //因为要分层输出，size为每层节点数 int size=q.size(); for (int i=0;i&lt;size;i++)&#123; TreeNode n=q.poll(); list.add(n.val); if (n.left!=null)&#123; q.add(n.left); &#125; if (n.right!=null)&#123; q.add(n.right); &#125; &#125; lists.add(list); &#125; return lists; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反转链表]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F04%2F%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转链表反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 递归实现：从后往前反转 12345678910111213public ListNode reverseList(ListNode head)&#123; //找到最后一个节点HEAD.NEXT if (head==null||head.next==null)&#123; return head; &#125; ListNode p=reverseList(head.next); //反转链表 head.next.next=head; //将head指向后一个节点的关系去掉 head.next=null; return p; &#125; 非递归：前往后 12345678910111213141516public ListNode sw(ListNode head)&#123; if (head==null)&#123; return head; &#125; //指向下一个节点 ListNode next=null; //反转后的头节点 ListNode pre=null; while(head!=null)&#123; next=head.next; head.next=pre; pre=head; head=next; &#125; return pre; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal源码分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ThreadLocal源码分析概述早在 JDK 1.2 的版本中就提供 java.lang.ThreadLocal，ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 ThreadLocal类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。ThreadLoacl类中使用map存储数据，key为线程而value为变量副本。ThreadLocal类中有一个ThreadLocalMap内部类，用来存储副本key为线程，而value为变量的副本。 使用：1234567891011121314151617181920package T616;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;public class threadlocalTest &#123; public static void main(String[] args) &#123; ExecutorService service=Executors.newCachedThreadPool(); ThreadLocal&lt;String&gt; local=new ThreadLocal&lt;&gt;(); service.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;------&quot;+local.get()); local.set(&quot;dasa&quot;); System.out.println(Thread.currentThread().getName()+&quot;------&quot;+local.get()); &#125; &#125;); &#125;&#125; 结果：pool-1-thread-1——null pool-1-thread-1——dasa 结构图一个ThreadLocal存储多个线程 的副本 一个线程存在多个ThreadLocal 参考 源码：get方法 123456789101112131415public T get() &#123;//获得当前线程 Thread t = Thread.currentThread(); //使用ThreadLocalMap进行存储变量 ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; ThreadLocalMap类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415static class ThreadLocalMap &#123;//Entry类扩展了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;//weakReference弱参考对象，不妨碍他们的参照物被定型，定型，然后回收。 大多数弱引用常用于实现规范化映射 static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** 线程的副本**/ Object value;//使用线程做主键 Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; /** * Entry[]数组的默认大小，必须是2的倍数. */ private static final int INITIAL_CAPACITY = 16; /** * Entry数组. */ private Entry[] table; /** *表格大小 */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 /** * Set the resize threshold to maintain at worst a 2/3 load factor. */ private void setThreshold(int len) &#123; threshold = len * 2 / 3; &#125; /** * Increment i modulo len. */ private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; /** * Decrement i modulo len. */ private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1); &#125; /** * ThreadLocalMap的构造函数 */ ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; //创建一个容量为16的Entry数组 table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; /** * Construct a new map including all Inheritable ThreadLocals * from given parent map. Called only by createInheritedMap. * * @param parentMap the map associated with parent thread. */ private ThreadLocalMap(ThreadLocalMap parentMap) &#123; Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j &lt; len; j++) &#123; Entry e = parentTable[j]; if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); if (key != null) &#123; Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode &amp; (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; &#125; &#125; &#125; &#125; /** * Get the entry associated with key. This method * itself handles only the fast path: a direct hit of existing * key. It otherwise relays to getEntryAfterMiss. This is * designed to maximize performance for direct hits, in part * by making this method readily inlinable. * * @param key the thread local object * @return the entry associated with key, or null if no such */ private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; /** * Version of getEntry method for use when key is not found in * its direct hash slot. * * @param key the thread local object * @param i the table index for key&apos;s hash code * @param e the entry at table[i] * @return the entry associated with key, or null if no such */ private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null; &#125; /** * Set the value associated with key. * * @param key the thread local object * @param value the value to be set */ private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don&apos;t use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; /** * Remove the entry for key. */ private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125; &#125; /** * Replace a stale entry encountered during a set operation * with an entry for the specified key. The value passed in * the value parameter is stored in the entry, whether or not * an entry already exists for the specified key. * * As a side effect, this method expunges all stale entries in the * &quot;run&quot; containing the stale entry. (A run is a sequence of entries * between two null slots.) * * @param key the key * @param value the value to be associated with key * @param staleSlot index of the first stale entry encountered while * searching for key. */ private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn&apos;t find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125; /** * Expunge a stale entry by rehashing any possibly colliding entries * lying between staleSlot and the next null slot. This also expunges * any other stale entries encountered before the trailing null. See * Knuth, Section 6.4 * * @param staleSlot index of slot known to have null key * @return the index of the next null slot after staleSlot * (all between staleSlot and this slot will have been checked * for expunging). */ private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i; &#125; /** * Heuristically scan some cells looking for stale entries. * This is invoked when either a new element is added, or * another stale one has been expunged. It performs a * logarithmic number of scans, as a balance between no * scanning (fast but retains garbage) and a number of scans * proportional to number of elements, that would find all * garbage but would cause some insertions to take O(n) time. * * @param i a position known NOT to hold a stale entry. The * scan starts at the element after i. * * @param n scan control: &#123;@code log2(n)&#125; cells are scanned, * unless a stale entry is found, in which case * &#123;@code log2(table.length)-1&#125; additional cells are scanned. * When called from insertions, this parameter is the number * of elements, but when from replaceStaleEntry, it is the * table length. (Note: all this could be changed to be either * more or less aggressive by weighting n instead of just * using straight log n. But this version is simple, fast, and * seems to work well.) * * @return true if any stale entries have been removed. */ private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed; &#125; /** * Re-pack and/or re-size the table. First scan the entire * table removing stale entries. If this doesn&apos;t sufficiently * shrink the size of the table, double the table size. */ private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize(); &#125; /** * Double the capacity of the table. */ private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab; &#125; /** * Expunge all stale entries in the table. */ private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j); &#125; &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock源码]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FReentrantLock%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ReentrantLock源码概述：重入锁,和与使用 synchronized方法差不多，但具有扩展功能的可重入互斥锁。 java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为 Java 类，而不是作为语言的特性来实现。这就为 Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。 ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM 可以花更少的时候来调度线程，把更多时间用在执行线程上。） ReentrantLock和synchronized比较比较 公平锁和非公平锁：公平锁使线程按照请求锁的顺序依次获得锁；而不公平锁则允许讨价还价，在这种情况下，线程有时可以比先请求锁的其他线程先得到锁。 源码：ReentrantLock构造 1234567public ReentrantLock() &#123; sync = new NonfairSync();&#125;//选择创建是否是公平锁public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 非公平锁 1234567891011121314151617181920//NonfairSync继承sync类static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** *执行锁步骤 */ final void lock() &#123; //使用cas操作将值从0变为1 if (compareAndSetState(0, 1)) //设置当前线程为锁的持有者 setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125;//尝试获取 protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 公平锁 123456789101112131415161718192021222324252627282930313233static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don&apos;t grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //判断队列中是否有其他的等待线程，如果没有则获取锁 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //判断当前线程是否是锁的持有者 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125;&#125; ReentrantLock类实现了Lock和java.io.Serializable接口 1234public class ReentrantLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync; 抽象Sync类继承了aqs，实同步现了锁的同步控制基础。分为公平和非公平版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; /** * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * 不公平尝试获取 */ final boolean nonfairTryAcquire(int acquires) &#123; //获取当前线程 final Thread current = Thread.currentThread(); //获得状态数值 int c = getState(); //如果为0 if (c == 0) &#123; //acqutres此时为1 if (compareAndSetState(0, acquires)) &#123; //设定当前线程拥有独占访问权限 setExclusiveOwnerThread(current); return true; &#125; &#125; //当前线程是否是由setExclusiveOwnerThread方法最后设定的线程 else if (current == getExclusiveOwnerThread()) &#123; //此时c为1，表示有锁，nextc为2 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125;//尝试释放 protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; protected final boolean isHeldExclusively() &#123; // While we must in general read state before owner, // we don&apos;t need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); &#125; final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; // Methods relayed from outer class final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; final boolean isLocked() &#123; return getState() != 0; &#125; /** * Reconstitutes the instance from a stream (that is, deserializes it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125;&#125;/** * 非公平锁 */static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * 锁实现 */ final void lock() &#123; //状态数值由0变为1 if (compareAndSetState(0, 1)) //设置当前线程是锁的持有者 setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 加锁和释放锁12345678//加锁public void lock() &#123; sync.lock();&#125;public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; 123public void unlock() &#123; sync.release(1);&#125; 总结：ReentrantLock是lock框架的一个抽象实现,是一个可重入的互斥锁，ReentranLock是通过sync实现的，sync又是继承aqs的，其内部又有公平锁和非公平锁类它们继承sync，它们实现了锁的公平获取和非公平获取的实现。 ​ 一个可重入的互斥锁定 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义，但功能更强大。ReentrantLock 将由最近成功获得锁定，并且还没有释放该锁定的线程所拥有。当锁定没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁定并返回。如果当前线程已经拥有该锁定，此方法将立即返回。可以使用 isHeldByCurrentThread() 和 getHoldCount() 方法来检查此情况是否发生。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CyclicBarrier源码分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FCyclicBarrier%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CyclicBarrier源码分析概述：cyclicbarrier同步屏障，它是一种同步协助，它允许一组线程等待彼此以达到共同的障碍点。CyclicBarriers 在涉及固定大小的线程的程序中非常有用，它必须偶尔等待对方，该屏障称为循环，因为它可以在等待线程释放后重新使用。 CyclicBarrier 好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。 构造函数parties爆发量，barrierAction当屏障被触发时执行的命令，如果没有任何操作，则执行{null} 12345678910public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;public CyclicBarrier(int parties) &#123; this(parties, null); &#125; 类的方法123456789101112131415161718public class CyclicBarrier &#123;private static class Generation &#123; boolean broken = false;&#125;//可重入锁private final ReentrantLock lock = new ReentrantLock();//条件队列private final Condition trip = lock.newCondition();//参与的线程数private final int parties;//屏障打开时运行的操作private final Runnable barrierCommand;//当前代private Generation generation = new Generation();//在屏障里等待的线程数量private int count;&#125; await方法1234567public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125; dowait方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; //使用了ReentrantLock（重入锁） final ReentrantLock lock = this.lock; lock.lock(); try &#123; //代 final Generation g = generation; if (g.broken) throw new BrokenBarrierException();//如果线程中断 if (Thread.interrupted()) &#123; //将当前的屏障生成设置为中断并唤醒每个人 breakBarrier(); throw new InterruptedException(); &#125;//到达屏障临界点的剩余线程数 int index = --count; if (index == 0) &#123; // tripped跳闸 boolean ranAction = false; try &#123; final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; //更新屏障状态，并且唤醒所有等待线程 nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) //将当前的屏障生成设置为中断，并唤醒每一个人 breakBarrier(); &#125; &#125; // loop until tripped, broken, interrupted, or timed out循环直到跳闸，断开，中断或超时 for (;;) &#123; try &#123; if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; // We&apos;re about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // &quot;belong&quot; to subsequent execution. Thread.currentThread().interrupt(); &#125; &#125; if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 可见CyclicBarrier是基于ReentrantLock(重入锁)实现的。 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package T616;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class cyclicBarrier &#123; public static void main(String[] args) &#123; CyclicBarrier barrier=new CyclicBarrier(3,new main1());/* * 等待开门的线程 */ new Thread(new play(1,barrier)).start(); new Thread(new play(2,barrier)).start(); new Thread(new play(3,barrier)).start(); &#125; static class main1 implements Runnable&#123; main1()&#123; &#125; @Override public void run() &#123; System.out.println(&quot;main&quot;); &#125; &#125; static class play implements Runnable&#123; CyclicBarrier barrier; int id; play(int id,CyclicBarrier barrier)&#123; this.barrier=barrier; this.id=id; &#125; @Override public void run() &#123; try &#123; System.out.println(id+&quot;------&quot;+Thread.currentThread().getName()+&quot;完成&quot;); barrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore源码分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FSemaphore%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Semaphore源码分析semaphore（信号量）用来控制同时访问特定资源的线程数，在获得物品之前，每个线程必须从信号量获得许可证，以确保物品可供使用。 当线程完成该项目时，它将返回到池，并且许可证返回到信号量，允许另一个线程获取该项目。请注意，在调用acquire时不会同步锁定，因为这会阻止将项目返回到池中。 信号量封装了用于限制对池的访问所需的同步，与为保持池自身一致性所需的任何同步分开。 源码： 12345public class Semaphore implements java.io.Serializable &#123; private static final long serialVersionUID = -3222578661600680210L; //所有机制都通过AbstractQueuedSynchronizer子类 private final Sync sync; &#125; semaphore的内部类sync Sync类继承AQS，实现信号量的同步，使用AQS表示信号量，分为公平版本和非公平。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 1192457210091910933L; Sync(int permits) &#123; setState(permits); &#125; final int getPermits() &#123; return getState(); &#125; final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error(&quot;Maximum permit count exceeded&quot;); if (compareAndSetState(current, next)) return true; &#125; &#125; final void reducePermits(int reductions) &#123; for (;;) &#123; int current = getState(); int next = current - reductions; if (next &gt; current) // underflow throw new Error(&quot;Permit count underflow&quot;); if (compareAndSetState(current, next)) return; &#125; &#125; final int drainPermits() &#123; for (;;) &#123; int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; &#125; &#125;&#125; 12345678910111213141516/** * 非公平版本 *NonfairSync继承Sync类 */static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L;//设置许可证的数量 NonfairSync(int permits) &#123; //使用sync的构造器 super(permits); &#125;//尝试获取共享 protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125;&#125; FairSync和NonfairSync都继承sync，唯一不同的是再获取时FairSync类加了一个hasQueuedPredecessors判断，判断是否有线程在 AQS 的 Sync Queue 里面进行等待获取 。 1234567891011121314151617181920212223/** * 共平版本 *继承sync类 */static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125;&#125; 获取信号量 123456789101112//Semaphore的构造方法public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;//可响应中断的获取信号量 public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; //不可响应中断的获取信号量 public void acquireUninterruptibly() &#123; sync.acquireShared(1); &#125; 尝试获取信号量 12345678910111213141516171819public boolean tryAcquire() &#123; return sync.nonfairTryAcquireShared(1) &gt;= 0;&#125;//有时间限制的尝试获取信号量 public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125; //尝试获取一定的数量的信号量 public boolean tryAcquire(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); return sync.nonfairTryAcquireShared(permits) &gt;= 0; &#125; //在一定时间尝试获取一定数量的信号量 public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException &#123; if (permits &lt; 0) throw new IllegalArgumentException(); return sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout)); &#125; 释放信号量 12345678910111213//释放一定数量的信号量public void release(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.releaseShared(permits);&#125;//返回此信号量中当前可用的许可证数量 public int availablePermits() &#123; return sync.getPermits(); &#125;//获取并返回所有立即可用的许可证。public int drainPermits() &#123; return sync.drainPermits(); &#125; 获取等待的线程数量 1234//返回等待获取的线程数的估计值public final int getQueueLength() &#123; return sync.getQueueLength();&#125; 使用semaphore（信号量）通过控制对资源同步的访问的线程的数量，比如模拟一个停车场停车信号，假设停车场只有两个车位，一开始两个车位都是空的。这时如果同时来了两辆车，看门人允许它们进入停车场，然后放下车拦。以后来的车必须在入口等待，直到停车场中有车辆离开。这时，如果有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开一辆，则又可以放入一辆，如此往复。[参考]（https://www.jianshu.com/p/d1bfa69f864d） 12345678910111213141516171819202122232425262728293031323334353637package T616;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class ThreadTest &#123; public static void main(String[] args) &#123; ExecutorService service=Executors.newFixedThreadPool(5); Semaphore semaphore=new Semaphore(2); for (int i=0;i&lt;5;i++)&#123; Runnable runnable=new Runnable() &#123; @Override public void run() &#123; try &#123; semaphore.acquire(); System.out.println(&quot;进入&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; semaphore.release(); System.out.println(&quot;释放&quot;); &#125; &#125;; service.execute(runnable); &#125; service.shutdown(); &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AbstractQueuedSynchronizer(AQS)]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FAbstractQueuedSynchronizer(AQS)%2F</url>
    <content type="text"><![CDATA[AbstractQueuedSynchronizer(AQS)什么是AQS提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器。是用来构建锁或者其他同步组件的基础框架。 synchronized 同步和AQSsynchronized 同步，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码需要关联到一个监视对象，当线程执行 monitorenter 指令时，需要首先获得获得监视对象的锁，这里监视对象锁就是进入同步块的凭证，只有获得了凭证才可以进入同步块，当线程离开同步块时，会执行 monitorexit 指令，释放对象锁。 在 AQS 同步中，使用一个 int 类型的变量 state 来表示当前同步块的状态。以独占式同步（一次只能有一个线程进入同步块）为例，state 的有效值有两个 0 和 1，其中 0 表示当前同步块中没有线程，1 表示同步块中已经有线程在执行。当线程要进入同步块时，需要首先判断 state 的值是否为 0，假设为 0，会尝试将 state 修改为 1，只有修改成功了之后，线程才可以进入同步块。注意上面提到的两个条件： state 为 0，证明当前同步块中没有线程在执行，所以当前线程可以尝试获得进入同步块的凭证，而这里的凭证就是是否成功将 state 修改为 1（在 synchronized 同步中，我们说的凭证是对象锁，但是对象锁的最终实现是否和这种方式类似，没有找到相关的资料） 成功将 state 修改为 1，通过使用 CAS 操作，我们可以确保即便有多个线程同时修改 state，也只有一个线程会修改成功。关于 CAS 的具体解释会在后面提到。 当线程离开同步块时，会修改 state 的值，将其设为 0，并唤醒等待的线程。所以在 AQS 同步中，我们说线程获得了锁，实际上是指线程成功修改了状态变量 state，而线程释放了锁，是指线程将状态变量置为了可修改的状态（在独占式同步中就是置为了 0），让其他线程可以再次尝试修改状态变量。在下面的表述中，我们说线程获得和释放了锁，就是上述含义， 这与 synchronized 同步中说的获得和释放锁的含义不同，需要区别理解 原文 AQS原理AQS的实现是依赖内部的同步队列（FIFO双向队列） ，如果当前线程获取同步状态失败，AQS会将线程以及等待状态等信息构成一个node，将其加到队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。 123 +------+ prev +-----+ +-----+* head | | &lt;---- | | &lt;---- | | tail* +------+ +-----+ +-----+ AQS结构图 源码node内部类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889static final class Node &#123; /** 标记以指示节点正在以共享模式等待 */ static final AbstractQueuedSynchronizer.Node SHARED = new AbstractQueuedSynchronizer.Node(); /** 标记以指示节点正在以独占模式等待 */ static final AbstractQueuedSynchronizer.Node EXCLUSIVE = null; // 结点状态 // CANCELLED，值为1，表示当前的线程被取消 // SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark // CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中 // PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行 // 值为0，表示当前节点在sync队列中，等待着获取锁 static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; /** * 状态字段只取下面的值： * SIGNAL: 该节点的后继者（或将很快）被阻塞（通过park），因此当前节点必须在释放或取消后取消其继任者。 * 为了避免竞争，获取方法必须首先表明他们需要一个信号，然后重试原子捕获，然后在失败时阻止阻塞 * CANCELLED: 由于超时或中断，此节点被取消。 * 节点永远不会离开这个状态。, 尤其是，具有取消节点的线程不会再次阻塞。 * CONDITION: 该节点当前处于条件队列中。 * PROPAGATE: releaseShared应该传播到其他*节点。 * 在doReleaseShared中设置这个（仅用于头节点）以确保传播继续，即使其他操作自干预以来也有*。 * 0: None of the above */ volatile int waitStatus; /** * 链接到当前节点/线程依赖*的前驱节点来检查waitStatus。 */ volatile AbstractQueuedSynchronizer.Node prev; /** * 链接到当前节点/线程*在释放后停止的后继节点。 */ volatile AbstractQueuedSynchronizer.Node next; /** * 排入此节点的线程。初始化施工并在使用后清空 */ volatile Thread thread; /** * 链接到下一个节点等待条件，或者特殊*值SHARED。 * 因为条件队列只有在独占模式下才被访问，所以我们只需要一个简单的*链接队列来等待*条件下的节点。 * 然后他们被转移到队列重新获得。 由于条件只能是排他性的，我们通过使用特殊值来保存字段以指示共享模式。 */ AbstractQueuedSynchronizer.Node nextWaiter; /** * 如果节点在共享模式下等待，则返回true。 */ final boolean isShared() &#123; return nextWaiter == SHARED; &#125; /** * 返回前一个节点，如果为null则抛出NullPointerException。 * 前驱不能为空时使用。, 空检查可能会被忽略，但是可以帮助虚拟机。 * * @return the predecessor of this node */ final AbstractQueuedSynchronizer.Node predecessor() throws NullPointerException &#123; AbstractQueuedSynchronizer.Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, AbstractQueuedSynchronizer.Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; AbstractQueuedSynchronizerAbstractQueuedSynchronizer类继承AbstractOwnableSynchronizer类，AbstractOwnableSynchronizer类同步器可能由线程专有。 这个类提供了创建锁和相关同步器的基础，这可能需要拥有所有权。 , AbstractOwnableSynchronizer类本身不管理或使用这些信息。 但是，子类和工具可以使用适当维护的值来帮助控制和监视访问并提供诊断。 1234567891011121314151617181920212223242526272829303132333435363738//队列头节点private transient volatile Node head;//尾节点private transient volatile Node tail;//同步状态 private volatile int state; //获得同步状态 protected final int getState() &#123; return state; &#125; //设置同步状态protected final void setState(int newState) &#123; state = newState; &#125;/**变更同步状态，基于cas操作，比较expect的值与存储位置的值是否相等*相等就将值变为update*/protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); &#125;//将节点插入队列 private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; AbstractOwnableSynchronizer类 12345678910111213/** *设置当前拥有独占访问权限的线程。 */protected final void setExclusiveOwnerThread(Thread thread) &#123; exclusiveOwnerThread = thread;&#125;/** * 返回最后由setExclusiveOwnerThread设置的线程，如果从未设置，则返回null。此方法不会以其他方式强制执行任何同步或字段访问。返回所有者线程 */protected final Thread getExclusiveOwnerThread() &#123; return exclusiveOwnerThread;&#125; 123public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; CountDownLatch源码概述：一个同步协助，允许一个或多个线程等待，直到完成其他线程中正在执行的一组操作。 源码：1234567891011121314151617181920212223242526272829303132private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125;/** * 重写 AQS 中的 tryAcquireShared * 尝试获取共享锁，如果当前 state 等于 0 返回 1 表示获取成功，否 则返回 -1 表示失败 */ protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; /** * 重写 AQS 中的 tryReleaseShared */ protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CountDownLatch分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FCountDownLatch%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CountDownLatch分析什么是CountDownLatchCountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。 CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。 使用AQS状态来表示计数，AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架 。 实现内部类 Sync继承AQS 123456789101112131415161718192021222324252627private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125; protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125;&#125; 1234public class CountDownLatch &#123; // 同步队列 private final Sync sync;&#125; 有参构造 1234567public CountDownLatch(int count) &#123;//如果count小于0时则返回IllegalArgumentException if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;); //初始化状态数 this.sync = new Sync(count);&#125; 无参构造 减少锁存器计数，如果计数为零，释放所有的等待的线程 123public void countDown() &#123; sync.releaseShared(1); &#125; await方法 ​ 等待锁存器计数为零时，再释放当前线程 123456public void await() throws InterruptedException &#123;//使用了aqs的方法//在共享模式下获取，如果中断则中止 sync.acquireSharedInterruptibly(1);&#125; 123456789//在共享模式下获取，如果中断则中止public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) //设置中断 doAcquireSharedInterruptibly(arg); &#125; doAcquireSharedInterruptibly方法 12345678910111213141516171819202122232425262728293031private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 添加节点至等待队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // 无限循环 // 获取node的前驱节点 final Node p = node.predecessor(); if (p == head) &#123; // 前驱节点为头结点 // 试图在共享模式下获取对象状态 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // 获取成功 // 设置头结点并进行繁殖 setHeadAndPropagate(node, r); // 设置节点next域 p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // 在获取失败后是否需要禁止线程并且进行中断检查 // 抛出异常 throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; await（long timeout, TimeUnit unit）方法 导致当前线程等待，直到锁存器计数到为零，除非线程中断，或经过了指定的等待时间 12345//尝试以共享模式获取，如果中断则中止，如果超时，则失败。public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));&#125; 使用： 1234567891011121314151617181920212223242526272829303132333435363738394041package T616;import java.util.concurrent.CountDownLatch;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class threadTst &#123; public static void main(String[] args) &#123; CountDownLatch end=new CountDownLatch(3); new Thread(new play1(1,end)).start(); new Thread(new play1(2,end)).start(); new Thread(new play1(3,end)).start(); try &#123; end.await(); System.out.println(&quot;main&quot;+&quot;****&quot;+Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class play1 implements Runnable&#123; int id; CountDownLatch end; public play1(int id,CountDownLatch end)&#123; this.id=id; this.end=end; &#125; @Override public void run() &#123; try &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+&quot;----&quot;+id); end.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exchanger的使用]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FExchanger%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Exchanger的使用概述：Exchanger可以让两个线程之间进行数据交换。 使用：使用：1234567891011121314151617181920212223242526272829303132333435363738package T616;import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class exchangerTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); Exchanger exchanger = new Exchanger(); service.execute(new Runnable() &#123; @Override public void run() &#123; dow(exchanger, &quot;date1&quot;); &#125; &#125;); service.execute(new Runnable() &#123; @Override public void run() &#123; dow(exchanger, &quot;date2&quot;); &#125; &#125;); service.shutdown(); &#125; public static void dow(Exchanger exchanger, String date) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;-----&quot; + date); Thread.sleep((long) (Math.random() * 1000)); String date1 = (String) exchanger.exchange(date); System.out.println(Thread.currentThread().getName() + &quot;-----&quot; + date1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果： pool-1-thread-1—–date1pool-1-thread-2—–date2pool-1-thread-1—–date2pool-1-thread-2—–date1 分析： 线程1执行exchange方法后线程阻塞，等线程2当线程2执行exchange方法时，线程数据交换。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现strStr()]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F27%2F%E5%AE%9E%E7%8E%B0strStr()%2F</url>
    <content type="text"><![CDATA[实现strStr()实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2: 12输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf()) 定义相符。 解法： 子字符串为空直接返回0，母字符串为空没有，返回-1，只要遍历母字符串-子字符串次数既可以，当haystack和needle的字符不同时，break，当j遍历到子字符串屁股时，返回i就是第一个出现的位置。 123456789101112131415161718192021222324class Solution &#123; public int strStr(String haystack, String needle) &#123; if (needle.isEmpty())&#123; return 0; &#125; if (haystack.isEmpty())&#123; return -1; &#125; int m=haystack.length(); int n=needle.length(); for (int i=0;i&lt;=m-n;i++)&#123; int j=0; for (;j&lt;n;j++)&#123; if (haystack.charAt(i+j)!=needle.charAt(j))&#123; break; &#125; &#125; if (j==n)&#123; return i; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F27%2Fjava%E7%9A%84%E5%BC%BA%EF%BC%8C%E8%BD%AF%EF%BC%8C%E5%BC%B1%EF%BC%8C%E8%99%9A%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[java的强，软，弱，虚引用借鉴]]></content>
  </entry>
  <entry>
    <title><![CDATA[字符串转整数（atoi）]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F25%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%EF%BC%88atoi%EF%BC%89%2F</url>
    <content type="text"><![CDATA[字符串转整数（atoi）实现 atoi，将字符串转为整数。 在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。 当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。 若函数不能执行有效的转换，返回 0。 说明： 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。如果数值超过可表示的范围，则返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 12输入: &quot;42&quot;输出: 42 示例 2: 1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4: 1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解法： 我的解法 1.使用String类的trim方法去掉空格。 2.判断字符串，如果是+，-，和0到9的数则添加到StringBuilder中，否则返回0。 3.直接用Integer中的parseInt方法将String转化成int类型，这一步如果大于或小于Integer边界会报错，在这用了try，catch。 4.根据第一个是正负号判断返回MIN_VALUE还是MAX_VALUE。 本地好使，但是leetcode跑不过 123456789101112131415161718192021222324252627public static int myAtoi(String str) &#123; if (str == null||str.length()==0) &#123; return 0; &#125; String str1 = str.trim(); StringBuilder st1 = new StringBuilder(str1.length()); int i = 0; while (i &lt; str1.length()) &#123; if (!(str1.charAt(i) &gt;= &apos;0&apos; &amp;&amp; str1.charAt(i) &lt;= &apos;9&apos; || str1.charAt(i) == &apos;-&apos;)) &#123; return 0; &#125; st1.append(str1.charAt(i)); i++; &#125; int re = 0; try &#123; re=Integer.parseInt(st1.toString()); &#125; catch (Exception e) &#123; if (st1.toString().charAt(0) == &apos;-&apos;) &#123; return Integer.MIN_VALUE; &#125; return Integer.MAX_VALUE; &#125; return re; &#125; 其他解法: 123456789101112131415161718192021public int myAtoi(String str) &#123; str = str.trim(); int result = 0; boolean isPos = true; for(int i = 0; i &lt; str.length(); i++)&#123; char c = str.charAt(i); if(i==0 &amp;&amp; (c==&apos;-&apos;||c==&apos;+&apos;))&#123; isPos = c==&apos;+&apos;?true:false; &#125; else if (c&gt;=&apos;0&apos; &amp;&amp; c&lt;=&apos;9&apos;)&#123; // 检查溢出情况 if(result&gt;(Integer.MAX_VALUE - (c - &apos;0&apos;))/10)&#123; return isPos? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; result *= 10; result += c - &apos;0&apos;; &#125; else &#123; return isPos?result:-result; &#125; &#125; return isPos?result:-result; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证回文字符串]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F23%2F%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[验证回文字符串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 解法： 用两个指针一个放在头，一个放在屁股，比较就行。这题比较麻烦的是只考虑字母和数字字符，可以忽略字母的大小写。 1234567891011121314151617181920212223242526public static boolean isPalindrome(String s) &#123; if (s == null) &#123; return false; &#125; StringBuilder s1 = new StringBuilder(); int i = 0;//大写转化为小写 String str=s.toLowerCase(); //去除除去字母和数字字符 while (i&lt;str.length()) &#123; if (str.charAt(i)&gt;=&apos;a&apos;&amp;&amp;str.charAt(i)&lt;=&apos;z&apos;||(str.charAt(i)&lt;=&apos;9&apos;&amp;&amp;str.charAt(i)&gt;=&apos;0&apos;))&#123; s1.append(str.charAt(i)); &#125; i++; &#125; int j = s1.length() - 1; int m=0; while (m &lt; j) &#123; if (s1.charAt(j) != s1.charAt(m)) &#123; return false; &#125; m++; j--; &#125; return true;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有效的字母异位词]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F19%2F%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[有效的字母异位词给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 解法：使用长度为26的两个数组分别存储字符串s和字符串t，然后将两个数组进行比较。 123456789101112131415161718192021class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s==null||t==null||s.length()!=t.length())&#123; return false; &#125; int [] z=new int[26]; int [] z2=new int[26]; for (int i=0;i&lt;s.length();i++)&#123; z[s.charAt(i)-'a']++; &#125; for (int i=0;i&lt;t.length();i++)&#123; z2[t.charAt(i)-'a']++; &#125; for (int i=0;i&lt;26;i++)&#123; if (z[i]!=z2[i])&#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串中的第一个唯一字符]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F18%2F2018-06-18-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[字符串中的第一个唯一字符 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例: 12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 注意事项：您可以假定该字符串只包含小写字母。 解法：因为字母有26个所以用一个长度为26的int数组来存储字符串转化的char数组 123456789101112131415public static int firstUniqChar(String s) &#123; if (s==null)&#123; return -1; &#125; int [] a=new int[26]; for (int i=0;i&lt;s.length();i++)&#123; a[s.charAt(i)-&apos;a&apos;]++; &#125; for (int i=0;i&lt;s.length();i++)&#123; if (a[s.charAt(i)-&apos;a&apos;]==1)&#123; return i; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单件模式]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F18%2F%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单件模式概述用来创建一个独一无二的，只有一个实例的对象的入场券。有些对象其实我们只需要一个就行，比如：线程池，缓存，对话框等。可以利用一个私有的构造器，和一个静态方法，一个静态变量实现单例模式。 实现延迟实例化： 12345678910111213//在单线程下可用public class danli &#123; private static danli mydanli; private danli()&#123; &#125; public static danli getMydanli()&#123; if (mydanli==null)&#123; mydanli=new danli(); &#125; return mydanli; &#125;&#125; 单件模式：确保一个类只有一个实例，并提供一个全局访问点。 利用延迟实例化的方式创建单件，这种做法对资源敏感的对象特别重要。 多线程情况多线程情况下使用上面的代码，会创建不止一个对象。 解决方法1.使用synchronized关键字将getMydanli（）变成同步，但对性能可能有影响。123456789101112public class danli &#123; private static danli mydanli; private danli()&#123; &#125; public static synchronized danli getMydanli()&#123; if (mydanli==null)&#123; mydanli=new danli(); &#125; return mydanli; &#125;&#125; 2.使用“急切”创建实例，而不用延迟实例化的做法。 12345678910public class danli &#123; //在静态初始化器中创建单件，确保线程安全 private static danli mydanli=new danli(); private danli()&#123; &#125; public static danli getMydanli()&#123; return mydanli; &#125;&#125; 3.用“双重检查加锁”，在 getMydanli（）中减少使用同步 这个做法可以大大的减少getMydanli()的时间消耗 1234567891011121314151617181920212223242526public class danli &#123; /** * volatile关键词确保，当mydanli变量被初始化成danli的实例时 * 多个线程正确的处理mydanli变量 */ private volatile static danli mydanli; private danli() &#123; &#125; public static danli getMydanli() &#123; /** * 只有第一次才彻底执行这里的代码。 */ if (mydanli == null) &#123; synchronized (danli.class) &#123; if (mydanli == null) &#123; mydanli = new danli(); &#125; &#125; &#125; return mydanli; &#125;&#125; 要点 单件模型确保程序中一个类最多只有一个实例。 单件模型也提供访问这个实例的全局点。 在java中实现单件模式需要一个私有的构造器，一个静态方法，一个静态变量。 确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，已解决多线程问题 使用多个类加载器可能导致单件失效而产生多个实例]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颠倒整数]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2F2018-06-17-%E9%A2%A0%E5%80%92%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个 32 位有符号整数，将整数中的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 解法 将int转化为String再转化为char数组,然后使用两个指针将char数组的值进行翻转， 再使用Integer.parseInt（）方法将String转化成int类型。 123456789101112131415161718192021222324252627class Solution &#123; public int reverse(int x) &#123; if (x&gt;Integer.MAX_VALUE||x&lt;Integer.MIN_VALUE)&#123; return 0; &#125; String a = Integer.toString(x); char[] chars = a.toCharArray(); int i = 0; int j = chars.length - 1; if (x&lt;0)&#123; i++; &#125; while (i &lt; j) &#123; char tmp = chars[i]; chars[i] = chars[j]; chars[j] = tmp; i++; j--; &#125; String str = new String(chars); try &#123; return Integer.parseInt(str); &#125;catch (Exception e)&#123; return 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 和 Vector比较]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayList 和 Vector比较ArrayListArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。 123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ArrayList类继承了AbstractList类实现了List这个*接口的用户可以精确控制列表中每个元素插入的位置。, 用户可以通过其整数索引（列表中的位置）访问元素，并在列表中搜索元素, RandomAccess支持快速的随机法访问, Cloneable允许clone, java.io.Serializable可序列化接口. 实现ArrayList的元素存储在其中的数组缓冲区，底层使用的是一个Object[]数组。 1transient Object[] elementData; // non-private to simplify nested class access 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 构造初始容量为10的空列表。 contains方法123public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; indexof方法123456789101112131415//如果数组中有o则返回第一个下标，否则返回-1public int indexOf(Object o) &#123;//因为ArrayList中可以为null if (o == null) &#123; //遍历查找 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; lastIndexOf方法12345678910111213//数组中有o返回最后一个下标public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; get方法12345678//返回列表指定位置的元素public E get(int index) &#123;//检查给定索引是否在范围内。, 如果不是，则抛出一个适当的运行时异常。//索引为负的化会抛出ArrayIndexOutOfBoundsException rangeCheck(index);//elementData数组获取 return elementData(index);&#125; set方法12345678//使用element更换列表指定位置的元素public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 扩容123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //扩容为原来的1.5倍大小 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; Fail-Fast 机制ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。 关于 Fail-Fast 的更详细的介绍，我在之前将 HashMap 中已经提到。 VectorVector类实现了一个动态数组。和ArrayList和相似，但是两者是不同的： Vector是同步访问的。 Vector包含了许多传统的方法，这些方法不属于集合框架。 Vector主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 1234public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; Vector类继承AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable接口和ArrayList相同。 123456789101112131415//构造一个空向量，使其内部数据数组的大小为10码，其标准容量增量为零。public Vector() &#123; this(10);&#125; public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); // initialCapacity初始容量 this.elementData = new Object[initialCapacity]; //capacityIncrement当矢量溢出时，容量增加的量 this.capacityIncrement = capacityIncrement; &#125; 底层实现12//Object[]数组protected Object[] elementData; setsize方法123456789101112//因为方法被synchronized修饰，所以是线程安全的public synchronized void setSize(int newSize) &#123; modCount++; if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize;&#125; trimToSize12345678//修剪此向量的容量为向量的当前大小public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, elementCount); &#125;&#125; elementAt方法12345678910111213141516171819202122//获取指定索引位置的元素public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; return elementData(index);&#125;//返回第一个索引位置的元素public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(0); &#125; //返回最后一个索引位置的元素public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(elementCount - 1); &#125; setElementAt方法12345678//将此矢量的指定 index中的组件设置为指定的对象。 该位置的前一个组件被丢弃。public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; elementData[index] = obj;&#125; addElement方法123456//将指定的组件添加到此向量的末尾public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 扩容123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //capacityIncrement当矢量的容量大于容量时，矢量的容量自动增加的量。, 如果*容量增量小于或等于零，则每次需要增加时，矢量的容量就会增加一倍。 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; 区别1.线程安全，vector是同步的所以是线程安全的，而arraylist不是线程安全的。 2.性能，因为vector是同步的所以在单线程情况下arraylist的性能比vector高。 3.扩容大小不同，arraylist扩容后的大小是原来的1.5倍，而vector根据capacityIncrement当矢量的容量大于容量时，矢量的容量自动增加的量。, 如果*容量增量小于或等于零，则每次需要增加时，矢量的容量就会增加一倍。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 和 Vector比较]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2FArrayList%20%20%E5%92%8C%20%20Vector%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[ArrayList 和 Vector比较ArrayListArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。 123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ArrayList类继承了AbstractList类实现了List这个*接口的用户可以精确控制列表中每个元素插入的位置。, 用户可以通过其整数索引（列表中的位置）访问元素，并在列表中搜索元素, RandomAccess支持快速的随机法访问, Cloneable允许clone, java.io.Serializable可序列化接口. 实现ArrayList的元素存储在其中的数组缓冲区，底层使用的是一个Object[]数组。 1transient Object[] elementData; // non-private to simplify nested class access 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 构造初始容量为10的空列表。 contains方法123public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; indexof方法123456789101112131415//如果数组中有o则返回第一个下标，否则返回-1public int indexOf(Object o) &#123;//因为ArrayList中可以为null if (o == null) &#123; //遍历查找 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; lastIndexOf方法12345678910111213//数组中有o返回最后一个下标public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; get方法12345678//返回列表指定位置的元素public E get(int index) &#123;//检查给定索引是否在范围内。, 如果不是，则抛出一个适当的运行时异常。//索引为负的化会抛出ArrayIndexOutOfBoundsException rangeCheck(index);//elementData数组获取 return elementData(index);&#125; set方法12345678//使用element更换列表指定位置的元素public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 扩容123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //扩容为原来的1.5倍大小 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; Fail-Fast 机制ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。 关于 Fail-Fast 的更详细的介绍，我在之前将 HashMap 中已经提到。 VectorVector类实现了一个动态数组。和ArrayList和相似，但是两者是不同的： Vector是同步访问的。 Vector包含了许多传统的方法，这些方法不属于集合框架。 Vector主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 1234public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; Vector类继承AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable接口和ArrayList相同。 123456789101112131415//构造一个空向量，使其内部数据数组的大小为10码，其标准容量增量为零。public Vector() &#123; this(10);&#125; public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); // initialCapacity初始容量 this.elementData = new Object[initialCapacity]; //capacityIncrement当矢量溢出时，容量增加的量 this.capacityIncrement = capacityIncrement; &#125; 底层实现12//Object[]数组protected Object[] elementData; setsize方法123456789101112//因为方法被synchronized修饰，所以是线程安全的public synchronized void setSize(int newSize) &#123; modCount++; if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize;&#125; trimToSize12345678//修剪此向量的容量为向量的当前大小public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, elementCount); &#125;&#125; elementAt方法12345678910111213141516171819202122//获取指定索引位置的元素public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; return elementData(index);&#125;//返回第一个索引位置的元素public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(0); &#125; //返回最后一个索引位置的元素public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(elementCount - 1); &#125; setElementAt方法12345678//将此矢量的指定 index中的组件设置为指定的对象。 该位置的前一个组件被丢弃。public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; elementData[index] = obj;&#125; addElement方法123456//将指定的组件添加到此向量的末尾public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 扩容123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //capacityIncrement当矢量的容量大于容量时，矢量的容量自动增加的量。, 如果*容量增量小于或等于零，则每次需要增加时，矢量的容量就会增加一倍。 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; 区别1.线程安全，vector是同步的所以是线程安全的，而arraylist不是线程安全的。 2.性能，因为vector是同步的所以在单线程情况下arraylist的性能比vector高。 3.扩容大小不同，arraylist扩容后的大小是原来的1.5倍，而vector根据capacityIncrement当矢量的容量大于容量时，矢量的容量自动增加的量。, 如果*容量增量小于或等于零，则每次需要增加时，矢量的容量就会增加一倍。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有效的数独]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2F%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 1: 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2: 123456789101112131415输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 给定数独永远是 9x9 形式的。123456789101112131415161718192021222324252627public class isValidSudoku &#123; public boolean isValidSudoku(char[][] board) &#123; if (board==null)&#123; return false; &#125; //row[0][8] 表示在第一行是否有8 boolean [][] row=new boolean[9][9]; //col[0][8] 表示在第9列是否有0 boolean [][] col=new boolean[9][9]; //cell[3*(i/3)+j/3][a]表示在3*3的矩阵中是否有a，i为行数j为列数 boolean [][] cell=new boolean[9][9]; for (int i=0;i&lt;9;i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] &gt;= '0' &amp;&amp; board[i][j] &lt;= '9') &#123; int a = board[i][j] - '1'; if (row[i][a] || col[a][j] || cell[3 * (i / 3) + j / 3][a]) &#123; return false; &#125; row[i][a] = true; col[a][j] = true; cell[3 * (i / 3) + j / 3][a] = true; &#125; &#125; &#125; return true; &#125;&#125; 1234567891011121314151617181920212223func isValidSudoku(board [][]byte) bool &#123; if board == nil &#123; return false &#125; var row [9][9] bool var col[9][9] bool var cell[9][9] bool for i:=0;i&lt;9 ;i++ &#123; for j:=0;j&lt;9 ;j++ &#123; if board[i][j]&gt;='1'&amp;&amp;board[i][j]&lt;='9' &#123; a:=board[i][j]-'1' if row[i][a]||col[a][j]||cell[3*(i/3)+j/3][a] &#123; return false &#125; row[i][a]=true col[a][j]=true cell[3*(i/3)+j/3][a]=true &#125; &#125; &#125; return true&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hashtable]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2FHashtable%2F</url>
    <content type="text"><![CDATA[HashtableHashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。 然而，Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。 像HashMap一样，Hashtable在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。 然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。 Hashtable和HashMap的区别HashMap 和 Hashtable 都实现了 Map 接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步 (synchronization)，以及速度。 HashMap 几乎可以等价于 Hashtable，除了 HashMap 是非 synchronized 的，并可以接受 null(HashMap 可以接受为 null 的键值 (key) 和值(value)，而 Hashtable 则不行)。 HashMap 是非 synchronized，而 Hashtable 是 synchronized，这意味着 Hashtable 是线程安全的，多个线程可以共享一个 Hashtable；而如果没有正确的同步的话，多个线程是不能共享 HashMap 的。Java 5 提供了 ConcurrentHashMap，它是 HashTable 的替代，比 HashTable 的扩展性更好。 另一个区别是 HashMap 的迭代器 (Iterator) 是 fail-fast 迭代器，而 Hashtable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），将会抛出 ConcurrentModificationException，但迭代器本身的 remove()方法移除元素则不会抛出 ConcurrentModificationException 异常。但这并不是一个一定发生的行为，要看 JVM。这条同样也是 Enumeration 和 Iterator 的区别。 由于 Hashtable 是线程安全的也是 synchronized，所以在单线程环境下它比 HashMap 要慢。如果你不需要同步，只需要单一线程，那么使用 HashMap 性能要好过 Hashtable。 HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 源码构造函数默认Hashtable的初始容量为11，负载因子是0.75 123public Hashtable() &#123; this(11, 0.75f);&#125; 同步的实现Hashtable中每个方法都被synchronized修饰来实现线程安全的。 1234567891011public synchronized int size() &#123; return count;&#125;public synchronized boolean isEmpty() &#123; return count == 0; &#125; public synchronized Enumeration&lt;K&gt; keys() &#123; return this.&lt;K&gt;getEnumeration(KEYS); &#125; Hashtable中使用的是Entry数组 get方法1234567891011121314//方法被synchronized修饰所以是线程安全的public synchronized V get(Object key) &#123; Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); //key的哈希值与上int的最大值在和tab数组的长度取余 int index = (hash &amp; 0x7FFFFFFF) % tab.length; //遍历链表 for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return (V)e.value; &#125; &#125; return null;&#125; put方法1234567891011121314151617181920212223242526//同步public synchronized V put(K key, V value) &#123; // value不能为空 if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; //遍历 for(; entry != null ; entry = entry.next) &#123; //如果链表中存在相同的key则进行覆盖 if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125; addEntry(）方法12345678910111213141516171819private void addEntry(int hash, K key, V value, int index) &#123; modCount++; Entry&lt;?,?&gt; tab[] = table; if (count &gt;= threshold) &#123; //如果超出阈值，则重新筛查表格 rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; //创建一个新的Entry @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; &#125; rehash（）方法扩容，当散列表中的键数超过散列表容量*和加载因子时，将自动调用此方法 1234567891011121314151617181920212223242526272829protected void rehash() &#123; int oldCapacity = table.length; Entry&lt;?,?&gt;[] oldMap = table; // overflow-conscious code int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; &#125; Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F14%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[位运算 操作符 描述 例子 ＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 \ 如果相对应位都是0，则结果为0，否则为1 （A \ B）得到61，即 0011 1101 ^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F14%2FConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap源码分析ConcurrentHashMap 是 J.U.C(java.util.concurrent 包) 的重要成员，它是 HashMap 的一个线程安全的、支持高效并发的版本。 在默认理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作及任意数量线程的读操作。 HashMap是非线程安全的，当HashMap在线程中使用时在进行扩容是Entry链可能会产生环，一旦Entry链中有环在HashMap增删查时可能陷入死循环。 ####结构图 ####ConcurrentHashMap源码 ConcurrentHashMap继承了AbstractMap实现了提供线程安全性和原子性保证的ConcurrentMap接口和序列化Serializable接口。 1234public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable &#123; .... &#125; 12345678910111213141516171819202122232425262728293031private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * 默认的初始表格容量 */private static final int DEFAULT_CAPACITY = 16;/** * 最大可能（两个非功率）阵列大小。 */static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * 此表的默认并发级别。 */private static final int DEFAULT_CONCURRENCY_LEVEL = 16;/** * 负载因子 */private static final float LOAD_FACTOR = 0.75f;/** *bin使用树而不是列表的bin数阈值。 */static final int TREEIFY_THRESHOLD = 8;/** * 用于在调整大小操作期间对（拆分）箱进行非订货的箱数阈值。 */static final int UNTREEIFY_THRESHOLD = 6; #####寻址方式 Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。同样为了避免不太好的Key的hashCode设计，它通过如下方法计算得到Key的最终哈希值。不同的是，Java 8的ConcurrentHashMap作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将Key的hashCode值与其高16位作异或并保证最高位为0（从而保证最终结果为正整数）。 123static final int spread(int h) &#123; return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125; #####put方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 public V put(K key, V value) &#123; return putVal(key, value, false); &#125; /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); //通过spread方法获得哈希值 int hash = spread(key.hashCode()); //用于记录相应链的长度 int binCount = 0; for (ConcurrentHashMap.Node&lt;K,V&gt;[] tab = table;;) &#123; ConcurrentHashMap.Node&lt;K,V&gt; f; int n, i, fh; //如果数组为空，则使用sizeCtl中记录的大小初始化表 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 找该 hash 值对应的数组下标，得到第一个节点 f else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 如果数组该位置为空， // 用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了 // 如果 CAS 失败，那就是有并发操作，进到下一个循环就好了 if (casTabAt(tab, i, null, new ConcurrentHashMap.Node&lt;K,V&gt;(hash, key, value, null))) break; // 添加到空箱时不锁 &#125; else if ((fh = f.hash) == MOVED) //帮助数据转移 tab = helpTransfer(tab, f); else &#123; // 到这里就是说，f 是该位置的头结点，而且不为空 V oldVal = null; // 获取数组该位置的头结点的监视器锁 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; //正常节点散列可用位 if (fh &gt;= 0) &#123; //用于记录相应链表的长度 binCount = 1; //遍历链表 for (ConcurrentHashMap.Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; //如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; ConcurrentHashMap.Node&lt;K,V&gt; pred = e; //如果到链表的尾部，则在后面加一个新的node if ((e = e.next) == null) &#123; pred.next = new ConcurrentHashMap.Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; //红黑树 else if (f instanceof ConcurrentHashMap.TreeBin) &#123; ConcurrentHashMap.Node&lt;K,V&gt; p; binCount = 2; //插入红黑树 if ((p = ((ConcurrentHashMap.TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; // if (binCount != 0) &#123; //如果超过8就使用红黑树而不是链表 if (binCount &gt;= TREEIFY_THRESHOLD) // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换， // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null; &#125;&#125; #####initTable方法扩容12345678910111213141516171819202122232425262728293031private final ConcurrentHashMap.Node&lt;K,V&gt;[] initTable() &#123; ConcurrentHashMap.Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; //sizeCtl为负数时表示正在初始化 if ((sc = sizeCtl) &lt; 0) //线程 Thread.yield(); // lost initialization race; just spin // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; // DEFAULT_CAPACITY 默认初始容量是 16 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(&quot;unchecked&quot;) //新建一个大小为n的node数组 ConcurrentHashMap.Node&lt;K,V&gt;[] nt = (ConcurrentHashMap.Node&lt;K,V&gt;[])new ConcurrentHashMap.Node&lt;?,?&gt;[n]; // 将这个数组赋值给 table，table 是 volatile 的 table = tab = nt; // 如果 n 为 16 的话，那么这里 sc = 12 // 其实就是 0.75 * n sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; // 设置 sizeCtl 为 sc，我们就当是 12 吧 sizeCtl = sc; &#125; break; &#125; &#125; return tab; &#125; 引用：ConcurrentHashMap 并发容器之ConcurrentHashMap(JDK 1.8版本) Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashSet源码]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F13%2FHashSet%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[HashSet源码HashSet类继承AbstractSet类，实现Set接口，Cloneable接口，java.io.Serializable序列化接口。 12345678910public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123;static final long serialVersionUID = -5024744406713321676L; private transient HashMap&lt;E,Object&gt; map; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); 无参构造函数123public HashSet() &#123; map = new HashMap&lt;&gt;();&#125; 可见HashSet是基于HashMap，所以初始容量为16，负载因子为0.75 构造一个包含指定集合中元素的新集合 1234public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125; 123public boolean contains(Object o) &#123; return map.containsKey(o); &#125; add方法 add方法也是调用的hashmap的put的方法，只是value值给的是虚拟值。 1234//PRESENTpublic boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; contains方法 判断key是否在set中 123public boolean contains(Object o) &#123; return map.containsKey(o); &#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F12%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final关键字修饰类 被final关键字修饰的类，不能被继承，如：string类就是final修饰，所以string类不能被继承 修饰方法 被final关键字修饰的方法，把方法锁定，以防任何继承类修改它的含义 修饰变量 1.如果是基本数据类型变量，则其数值一旦在初次初始化后就不能改变。 2.如果是引用类型的变量，则在对其初次初始化之后便不能再让其指向另一个对象。]]></content>
      <categories>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>java关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jvm]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F11%2FJvm%2F</url>
    <content type="text"><![CDATA[##jvm ###类加载机制概念类的加载机制是指将.class文件中的二进制数据通过类加载器加载到内存中，并在堆区间上创建一个java.lang.class对象，用来封装方法区内的数据结构。类加载最后的产品就是堆区间生成class对象，Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。生命周期类加载包括，加载，连接，初始化，使用，卸载，前三步为加载过程。加载：将.class文件中的二进数据读到内存中，将其放在运行时数据区的方法区内，并在堆区间java.lang.class对象。连接： 包括1.验证：验证数据是否正确 2.准备：为静态变量分配内存，并初始为默认值 3.解析：把类中的符号引用转化为直接引用初始化：伪静态变量赋值使用：new出对象在程序中使用卸载：垃圾回收类加载器 类加载器是将Java类加载到内存中，一般步骤是java源文件（.java文件）经过编译生成（.class文件），类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。 java.long.ClassLoader类 数组类的Class 对象不是由class 加载器创建的，而是根据Java运行时的需要自动创建的。 由getClassLoader（）返回的数组类的类加载器与其元素类的类加载器相同;, 如果元素类型是基本类型，那么数组类没有类加载器。 12345getParent() 返回委托的父类加载器findClass(String name) 使用指定的二进制查找类findLoadedClass(String name) 查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。defineClass(String name, byte[] b, int off, int len) 把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。 resolveClass(Class&lt;?&gt; c) 链接指定的类。, 这个（具有误导性的命名）方法可以被类加载器用来链接一个类。, 如果类 c已经被链接了，那么这个方法简单地返回。 类加载器类型 Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个： 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 我们可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。 除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。 类加载器关系，箭头指向的是父类。 双亲委派模型 ClassLoader 类使用委托模型来搜索类和资源。 , 关联的父类加载器。, 当请求查找类或资源时，ClassLoader实例会在尝试查找类或资源本身之前，将对类或资源的搜索委托给其父类加载器。, 虚拟机的内置类加载器称为“引导类加载器”，它本身不具有父类，但可以作为ClassLoader实例的父类。 类加载器代理模式 类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。 代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。 不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。 参考https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html 加载类的过程 因为代理机制所以类的加载首先代理给其他类进行加载尝试，这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。 定义加载器：完成类的加载工作，通过调用defineClass来实现的，在java虚拟机判断类是否相同使用。 初始加载器：启动类的加载过程是通过loadClass来实现的。 关系：一个类的定义加载器是它引用的其他类的初始加载器。 类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。 线程上下文类加载器线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 ###jvm内存结构 jvm java虚拟机，.java文件经过编译生成.class文件，jvm执行.class文件。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。因此实现java平台无关性。它是 Java 程序能在多平台间进行无缝移植的可靠保证 。 jvm是编译后java程序（.class文件）和硬件系统之间的接口 jvm=类加载器classloader+执行引擎execution engine+运行时数据区域runtime date area 类加载器将.class文件加载到jvm中的运行时数据区，执行引擎负责类文件是否执行 运行时数据区在所有线程间共享（方法区，堆） 运行时数据区线程私有（虚拟机栈，本地方法栈，程序计数器） 方法区各个线程共享的内存区域，它用于存储类的二进制文件，被虚拟机加载的类信息，常量，静态变量。 堆运行时数据区在所有线程间共享，用于存储类加载生成的java.lang,Class对象实例，几乎所有的对象实例都在这里分配内存。java堆被所有的线程共享的一块内存区域，在虚拟机启动时创建。 虚拟机栈虚拟机栈对所有线程是私有的，生命周期和线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用来存储局部变量，操作栈，动态链接，方法出口等信息。每个方法被调用到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈它也是线程私有的，本地方法栈和虚拟机栈差不多，不同就是虚拟机栈是为java方法服务，而本地方法栈是为Native方法服务。 程序计数器程序计数器是线程私有的，它的作用可以看做是当前线程所执行的字节码的行号指示器。参考：jvm ###GC垃圾回收 垃圾收集（Garbage Collection，GC），用于内存的动态分配和内存回收。 GC基本的算法标记清除法步骤：先将要回收的对象标记出来，在标记完成后统一回收所有标记的对象。 不足：1.效率不高 ​ 2.空间问题，回收标记的对象后产生许多琐碎的内存碎片，空间碎片太多可能导致以后在程序运行 时要获得一个大的对象存储空间时，空间不够因而触发另一次垃圾回收。 复制法步骤：将内存分为两块，每次只使用一个，当一个使用完后就将还存活的对象复制到另一个区域，并清除前一个区域。 缺点：内存缩小 目前商业的虚拟机都是这种算法回收新生代，将内存分为较大空间的Eden空间和两个较小的Survivor空间，每次使用Eden和一个Survivor空间，当回收时，将Eden和Survivor空间还存活的对象复制到另一个Survivor空间中，清除原来的Eden和Survivor空间。HotSpot虚拟机默认的Eden和Survivor空间大小是8:1 每次新生代内存空间为整个新生代容量的90%。 标记整理法复制法在对象存活率高时会复制多次，效率将会变低，而且不想浪费空间。 老年代使用标记整理法 步骤：和标记清除法一样，但后面不是清除，而是让所有存活的对象向一端移动，然后清除端边界以外的内存。 分代收集法当前商业虚拟机的垃圾回收都使用分代手机法。 根据对象的生命周期将内存划分成几块。一般将java堆分成新生代和老年代，这样根据不同代的特点使用不同的算法 ，新生代中，每次垃圾回收时会发现大量的对象挂了，只有少量存活，所以一般使用复制算法。 而老年代中因为对象的存活率高，没有额外空间对他进行分配担保，就使用“标记消除”或“标记整理”来进行垃圾回收。 ###GC调优 Java GC分析参考：jvm系列(五)Java GC 分析 调优命令 Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 jmap，JVM Memory Map命令用于生成heap dump文件 jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 jstack，用于生成java虚拟机当前时刻的线程快照。 jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。 详细的命令使用参考这里：jvm系列(四):jvm调优-命令篇 调优工具 常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。 jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控 jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。 MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 GChisto，一款专业分析gc日志的工具]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F10%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式工厂模式将对象的创建和实现分开工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。依赖倒置原则指的是和一般oo设计的思考方式完全相反。一般的oo设计思想是自上而下的依赖，而依赖倒置是指底层的组件依赖着高层的抽象，同样高层组件现在也依赖相同的抽象。要遵循依赖倒置原则，工厂方法不是唯一的技巧，但却是最有威力的技巧之一。 设计原则：要依赖抽象，不要依赖具体类。避免违反OO设计中违反依赖倒置原则：1.变量不可以持有具体类的引用（如果使用new就会持有具体类的引用）2.不要让类派生自具体类。（如果派生自具体类，就会依赖具体类，应该派生自一个抽象）3.不要覆盖基类中已经实现的方法（如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享） 要点所有的工厂都是用来封装对象的创建 简单工厂：简单的工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦。 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。 工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 所有的工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。 工厂方法允许类将实例化延迟到子类进行。 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。 依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象。 工厂是很有威力的技巧，帮助我们针对抽象编程，而不是针对具体类编程。 工厂模式图 抽象工厂模式图]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stomp面向简单文本的消息传递协议]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2FStomp%E9%9D%A2%E5%90%91%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Stomp面向简单文本的消息传递协议是什么：STOMP是简单（或流式）文本定向消息协议。 STOMP提供可互操作的线路格式，以便STOMP客户端可以与任何STOMP消息代理进行通信，以便在多种语言，平台和代理之间提供简单和广泛的消息互操作性。 设计： STOMP是一个非常简单易用的协议，来自HTTP设计学院; 服务器端可能很难实现，但编写客户端以便连接起来非常容易。例如，您可以使用Telnet登录到任何STOMP代理并与其交互！ WebSocket是一种在单个Tcp连接上进行全双工通讯的协议在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 背景：WebSocket协议是由HTML5定义的，它能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 Websocket使用ws或wss的统一资源标志符，类似于HTTPS，其中wss表示在TLS之上的Websocket。 Websocket使用和 HTTP 相同的 TCP 端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。 优点：1.较少的控制开销。 在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。2.更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。3.保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。4.更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。5.可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。6.更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。 握手协议：WebSocket 是独立的、创建在 TCP 上的协议。Websocket 通过 HTTP/1.1 协议的101状态码进行握手。为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。 例子:一个典型的Websocket握手请求如下：客户端请求1234567GET / HTTP/1.1Upgrade: websocket //表示希望升级到Websocket协议。Connection: Upgrade //表示客户端希望连接升级Host: example.com Origin: http://example.comSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ== //Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。Sec-WebSocket-Version: 13 //表示支持的Websocket版本。 服务器回应12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=Sec-WebSocket-Location: ws://example.com/ HTTPS超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过电脑网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。 主要思想HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。 HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构（如Symantec、Comodo、GoDaddy和GlobalSign等）（意即“我信任证书颁发机构告诉我应该信任的”）。因此，一个到某网站的HTTPS连接可被信任，当且仅当： 用户相信他们的浏览器正确实现了HTTPS且安装了正确的证书颁发机构；用户相信证书颁发机构仅信任合法的网站；被访问的网站提供了一个有效的证书，意即，它是由一个被信任的证书颁发机构签发的（大部分浏览器会对无效的证书发出警告）；该证书正确地验证了被访问的网站（如，访问https://example.com时收到了给example.com而不是其它组织的证书）；或者互联网上相关的节点是值得信任的，或者用户相信本协议的加密层（TLS或SSL）不能被窃听者破坏。HTTPS不应与在 RFC 2660 中定义的安全超文本传输协议（S-HTTP）相混淆。 与HTTP差别与HTTP的URL由“http://”起始且默认使用端口80不同，HTTPS的URL由“https://”起始且默认使用端口443。 HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，并在正确配置时被认为是安全的。 HTTP超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 协议概述HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMap ：带符号右移。正数右移高位补0，负数右移高位补1。比如： 4 &gt;&gt; 1，结果是2；-4 &gt;&gt; 1，结果是-2。-2 &gt;&gt; 1，结果是-1。 ：无符号右移。无论是正数还是负数，高位通通补0。 对于正数而言，&gt;&gt;和&gt;&gt;&gt;没区别。 简介1.HashMap基于哈希的map接口实现。2.HashMap 类大致相当于 Hashtable ，只是它是非同步的并且允许为空值。3.HashMap根据键的hashCode值存储数据，一般直接可以定位到它的值，但他遍历顺序是不确定的。HashMap只允许key中只有一个null，而value可以是多个，HashMap是非线程安全的。如果要满足线程安全，可以用Collection的synchronizedMap方法使的HashMap具有线程安全的能力，或使用ConcurrentHashMap。 内部实现从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。 1.HashMap中有Node&lt;K,V&gt;[] table 即哈希桶数组。HashMap的内部类123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 2.HashMap构造方法。12345678910111213141516/**使用指定的初始容量和指定加载因子构造一个空的HashMap*/public HashMap(int initialCapacity, float loadFactor)&#123;...&#125;/**使用指定的初始容量和默认加载因子（0.75）构造一个空的HashMap*/ public HashMap(int initialCapacity)&#123;...&#125; /* *使用默认的初始容量（16）和默认加载因子（0.75）构造一个空的HashMap */ public HashMap() &#123;...&#125; /* *使用与指定的&lt;tt&gt; Map &lt;/ tt&gt;相同的映射构造一个新的HashMapHashMap用默认加载因子 *（0.75）和一个初始容量来创建，该容量足以将映射保存在指定的Map */ public HashMap(Map&lt;? extends K, ? extends V&gt; m)&#123;...&#125; 3.jdk1.8 HashMap的put方法源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i;// 判断table是否为空，创建默认大小 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length;// 计算index，并对null做处理 （有点懵） if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; HashMap.Node&lt;K,V&gt; e; K k; //节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //判断是否是红黑树 else if (p instanceof HashMap.TreeNode) e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //该链为链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //key存在就覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //超过阈值就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 4.HashMap 扩容扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。 （1）.jdk1.7的扩容是当容量大于阈值时，使用大的数组代替小的数组 12345678910111213141516171819202122232425262728293031 void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 &#125; //用于将原来的数组中的数据拷贝到新的数组 void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null);&#125;&#125; &#125; jdk1.7扩容后会重新计算每个元素在数组中的位置，当put时数据会放在链表的前面，所以最先插入的数据应该在链表的末尾。（2）.jdk1.8123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final HashMap.Node&lt;K,V&gt;[] resize() &#123; HashMap.Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //判断是否大于最大容量 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //当小于最大容量时，扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) HashMap.Node&lt;K,V&gt;[] newTab = (HashMap.Node&lt;K,V&gt;[])new HashMap.Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; HashMap.Node&lt;K,V&gt; e; //遍历老数组，并释放它 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) //e的哈希和新的容量-1做与运算 得出在新数组的位置 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof HashMap.TreeNode)//判断它是红黑树 ((HashMap.TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 HashMap.Node&lt;K,V&gt; loHead = null, loTail = null; HashMap.Node&lt;K,V&gt; hiHead = null, hiTail = null; HashMap.Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 线程安全性HashMap是非线程安全的，线程安全的ConcurrentHashMap。在多线程情况下HashMap会产生死循环]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[##两数之和 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 使用hashmap将数组中的值作为key，下标作为value值放入map中，查的时候只找map中是否有target-nums[i]，则返回的就是i和target-nums[i]的下标。1234567891011121314public static int[] twoSum1(int[] nums, int target) &#123; if (nums == null) &#123; return null; &#125; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(target-nums[i])) &#123; return new int[]&#123;map.get(target - nums[i]), i&#125;; &#125;else &#123; map.put(nums[i], i); &#125; &#125; return null; &#125; 返回两个数的值指针i指向数组的头，而j指向屁股，然后直到他俩相遇123456789101112131415161718192021222324252627282930public static int[] twoSum(int[] nums, int target) &#123; if (nums == null) &#123; return null; &#125; int i = 0; int j = nums.length - 1; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int x = 0; x &lt; nums.length; x++) &#123; while (i &lt; x &amp;&amp; j &gt; x) &#123; if (Math.abs(i - j) == 1) &#123; break; &#125; if (j &gt;= 0 &amp;&amp; target &lt; nums[j]) &#123; j--; &#125; if (i &lt; nums.length &amp;&amp; j &gt;= 0 &amp;&amp; nums[i] + nums[j] == target) &#123; list.add(nums[i]); i++; list.add(nums[j]); j--; &#125; &#125; &#125; int[] re = new int[list.size()]; for (int i1 = 0; i1 &lt; re.length; i1++) &#123; re[i1] = list.get(i1); &#125; return re; &#125; 123456789101112131415161718func twoSum(nums []int, target int) []int &#123; if nums==nil &#123; return nil &#125; m:=make(map[int]int) for i:=0;i&lt;len(nums) ;i++ &#123; captial,ok:=m[target-nums[i]] if ok&#123; s:=[] int&#123;captial,i&#125; return s &#125;else &#123; m[nums[i]]=i &#125; &#125;return nil&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组加一]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2F%E6%95%B0%E7%BB%84%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[加一 给定一个非负整数组成的非空数组，在该数的基础上加一，返回一个新的数组。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 #####Java：1234567891011121314151617public static int[] plusOne(int[] digits) &#123; int creay=1; for (int i=digits.length-1;i&gt;=0;i--)&#123; if (creay==0)&#123; return digits; &#125; int tmp=digits[i]+creay; creay=tmp/10; digits[i]=tmp%10; &#125; if (creay!=0) &#123; int [] re=new int[digits.length+1]; re[0]=1; return re; &#125; return digits;&#125; #####go:1234567891011121314151617func plusOne(a [] int) [] int&#123; crray:=1 for i:=len(a)-1;i&gt;=0 ; i-- &#123; if crray==0 &#123; return a &#125; tmp:=a[i]+crray crray=tmp/10 a[i]=tmp%10 &#125; if crray!=0 &#123; var newa [] int=make([]int,len(a)+1) newa[0]=1 return newa &#125; return a&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 并发编程实战 读书笔记]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2Fjava-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[对象的共享简述：已知同步方法和同步代码块，可以以原子性的方式执行。同步还可以通过内存可见性实现。当多个线程对一个公共的数据进行set和get ，如果set和get方法不用synchronized修饰是非线程安全的。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 失效数据多个线程调用一个数据时，一个线程获取的数据不是最新的，而是一个过期的数据。失效问题：一个线程set后另一个线程get的数据可能不是最新的获知可能获取不到。 非原子的64位操作非volatile类型double，long变量，jvm在对64位的double或long变量的读操作或写操作是分为高位32和低位32位进行操作的，在进行操作时可能是取一个数的高32位而取另一个数的低32位。所以在多线程情况下要使用volatile关键字对double，long变量进行修饰。 volatile变量volatile变量是一种稍微的同步机制。volatile变量不会存在寄存器或者对其他处理器不可见的地方，因此每次读取的数据都是最新的。volatile是一种比synchronization稍微弱的同步机制。访问volatile变量时不需要加锁操作，因此也就不会使执行线程阻塞的。正确使用方法：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如，初始化或关闭）局限性：volatile变量通常用做某个操作完成，发生中断或者状态的标志。 ####### 加锁机制能可以确保原子性和可见性，而volatile只能确保可见性。使用volatile前提：1.对变量的写入操作不依赖变量的当前值；2.该变量不会与其他状态变量一起纳入不变性条件中。3.在访问时不需要加锁。 线程封闭一种避免使用同步的方法就是不共享数据。线程封闭是实现线程安全性的最简单的方式之一。Ad-hoc线程封闭Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担，它是非常脆弱的，因为没有任何一种语言特性，能将对象封闭到目标线程上。一般不使用。栈封闭在栈封闭中，只能通过局部变量才能访问对象。局部变量封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭也被称为线程内部使用或线程局部使用。比Ad-hoc更加易于维护，更加健壮。ThreadLocal类ThreadLocal类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。ThreadLoacl类中使用map存储数据，key为线程而value为变量副本。ThreadLocal类中有一个ThreadLocalMap内部类，用来存储副本key为线程，而value为变量的副本。 不变性什么是不变性不变性指对象的状态不改变。不变性对象一定是线程安全的。满足条件1.对象创建后其状态不再改变2.对象的所有域都是final类型的3.对象是正确创建的（在对象创建之间，this引用没有逸出） Final域final域能确保初始化过程中的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象的时无须同步。 除非需要更高的可见性，否则应将所有的域都声明为私有域除非需要某个域是可变的，否则应将其声明为final域####使用volatile类型来发布不可变对象在某些情况下，不可变对象能提供一种弱形式的原子性，对于在访问和更新多个相关变量的竞争问题，可以将这些变量存储在一个不变对象中来消除。如果是一个可变对象，只能用锁来确保原子性。如果是一个不可变对象，当一个线程获得他的值后，另一个线程不能改变对象的状态。更新这些变量时，创建一个新的容器对象，但其他使用原有对象的线程仍然会看到对象处于一致状态。使用不可变对象容器的volatile类型引用以缓存最新的结果。volatile在修饰不可变对象容器时是线程安全的。 ##安全发布为什么要安全发布要在足够同步的情况下发布对象，不安全的发布会导致其他线程看见尚未完成的对象。对象在不完全发布时会出现两个问题：1.当一个对象未安全发布时除了发布对象的线程外其他线程看见的对象要么是旧值，要么是空引用。2.某一个线程在第一次读取时得到失效值，而再一次读取这个域时会得到一个更新值。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机2]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路：因为要获取最大利润，所以只要后面比前面的大就获利123456789101112131415161718192021222324252627282930313233343536java版本:class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices==null || prices.length==0)&#123; return 0; &#125; int min=prices[0]; int sum=0; for (int i=1;i&lt;prices.length;i++)&#123; if (prices[i]&gt;min)&#123; sum+=prices[i]-min; min=prices[i]; &#125;else &#123; min=prices[i]; &#125; &#125; return sum; &#125;&#125; 1234567891011121314151617go版本:func max(a []int) int &#123; if len(a)==0 &#123; return 0 &#125; min := a[0] sum :=0 for i:=0;i&lt;len(a) ;i++ &#123; if min&lt;a[i] &#123; sum+=(a[i]-min) min=a[i] &#125;else &#123; min=a[i] &#125; &#125; return sum&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F29%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[旋转数组给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明:123- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。- 要求使用空间复杂度为 O(1) 的原地算法。 方法一：123456789101112-利用length-k将数组分为两部分-分别调换两段数组-再转化整个数组例如： 1 2 3 4 5 6 7 如果k = 3 的话， 会变成 5 6 7 1 2 3 4 1 2 3 4 5 6 7 middle = 7 - 3 = 4，分为左边 4个数字，右边 3个数字 4 3 2 1 7 6 5 分别把左右swap 一下 5 6 7 1 2 3 4 把总数组swap 一下就会得到答案​` java:​123456789101112131415161718192021class Solution &#123; public void rotate(int[] nums, int k) &#123; if (nums.length==0||nums==null||k%nums.length==0)&#123; return ; &#125; int t=k%nums.length; int sta=nums.length-t; swap(nums,0,sta-1); swap(nums,sta,nums.length-1); swap(nums,0,nums.length-1); &#125; public static void swap(int[] a, int i, int j) &#123; while(i&lt;j) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; &#125;&#125; go:12345678910111213141516171819func rotate(nums []int,k int) &#123; if len(nums)==0 || nums==nil ||k%len(nums)==0 &#123; return &#125; t:=k%len(nums) sta:=len(nums)-t swap(nums,0,sta-1) swap(nums,sta,len(nums)-1) swap(nums,0,len(nums)-1)&#125;func swap(a [] int,i int,j int) &#123; for i&lt;j&#123; tmp:=a[i] a[i]=a[j] a[j]=tmp i++ j-- &#125;&#125; 方法二：12-创建一个大小相同的数组-然后将原数组中的值写到新数组中，关键点（a[(i + k) % nums.length] = nums[i];） 12345678public static int[] rotate1(int[] nums, int k) &#123; int[] a = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; //关键点 a[(i + k) % nums.length] = nums[i]; &#125; return a; &#125; go:12345678func rotate1(nums [] int,k int) []int&#123; //go中切片 相当于动态数组 切片的长度不是固定的，在追加时可能使的容量增大 var a [] int=make([]int,len(nums)) for i:=0;i&lt;len(nums) ;i++ &#123; a[(i+k)%len(nums)]=nums[i] &#125; return a&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql配置]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fmysql%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[踩过的坑 防止再掉 1.mysql文件和文件夹(linux 配置文件文件后缀为cnf) bin 放可执行性文件 include 存放头文件 lib 存放库文件 share 存放字符集，语言等信息 my.ini mysql软件正在使用的配置文件 my-huge.ini 当mysql软件为超大型数据库时使用的配置文件 my-small.ini 当mysql软件为小型数据库时使用的配置文件 my-template.ini 配置文件模板 2.my.ini配置文件中的内容可实现修改数据库实例的参数（linux中为my.cnf） 客户端 [mysql] 客户端的端口号 prot=3306 客户端默认字符集 default-character-set=utf8 [mysqld] 服务端 prot=3306 数据库服务器的安装目录 basedir=？？？？ mysql数据库数据文件的目录 datadir=？？？ mysql软件端的字符集 character-set-server=utf8 mysql软件的存储引擎 default-storage-engine=INNODB mysql最大连接数 max-connections=100 mysql软件缓存 query_cache_size=0 mysql中可以打开表的总数 table_cache=256 mysql软件内存中可以存储临时表的最大值 tem_table_size=9m mysql软件可以保留的客户端链接线程数 thread_cache_size=8 mysql软件重建索引时允许的最大临时文件的大小 myisam_max_sort_file_size=10G mysql软件重建索引时允许的最大缓存的大小 myisam_sort_buffer_size=17m mysql软件中最大关键字缓存的大小 key_buffer_size=10m mysql软件全扫描myisam表时的缓存大小 read_buffer_size=6k mysql软件可以插入排序好的数据的缓存的小 read_rnd_buffer_size=256k mysql软件用户排序时缓存的大小 sort_buffer_size=256k 关于INNODB存储引擎参数设置附加内存池大小 innodb_additional_mem_pool_size=2m 关于提交日志的时机 innodb_flush_log_at_trx_commit=1 存储日志数据的缓存区的大小 innodb_log_buffer_size=1m 缓存池中缓存区的大小 innodb_buffer_pool_size=17m 日记文件的大小 innodb_log_file_size=10m 允许线程的最大数 innodb_thread_concurrency=8]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 和 StringBuffer 和 StringBuilder]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2FString%20%E5%92%8C%20StringBuffer%20%E5%92%8C%20StringBuilder%2F</url>
    <content type="text"><![CDATA[三者不同点 1，string 类是不可变的，一旦创建了String对象，那她就无法改变2，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 线程安全StringBuffer是线程安全的，而StringBuilder是非线程安全的。 运行速度1.StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 2.StringBuffer 和 StringBuilder 长度可变 StringBuffer &amp;&amp; StringBuilder &amp;&amp; String StringBuffer：一个线程安全的，可变的字符序列。字符串缓冲区就像一个String，但可以修改。在任何时候它都包含一些特定的字符序列，但是序列的长度和内容可以通过某些方法调用来改变。字符串缓冲区对于多线程来说是安全的。这些方法在必要时进行同步，以便任何特定实例上的所有操作的行为就好像它们以某种连续顺序发生，这与每个涉及的单个线程所进行的方法调用的顺序一致。 上的主要操作StringBuffer是 append和insert方法，其被重载，以便接受任何类型的数据。每个函数都有效地将给定的数据转换为字符串，然后将该字符串的字符附加或插入到字符串缓冲区中。该 append方法总是将这些字符添加到缓冲区的末尾; 该insert方法在指定的点添加字符。 如果sb指的是a的一个实例StringBuffer，那么sb.append(x)效果与之相同 sb.insert(sb.length(), x)。 每个字符串缓冲区都有一个容量 只要包含在字符串缓冲区中的字符序列的长度不超过容量，就不需要分配新的内部缓冲区数组。如果内部缓冲区溢出，它会自动变大。从版本JDK 5开始，这个类已经补充了一个为单个线程设计的等价类StringBuilder。由于StringBuilder类支持所有相同的操作，所以通常会优先使用StringBuilder类，但速度更快，因为它不执行同步操作。 StringBuilder：一个可变的字符序列。这个类提供了一个兼容的API StringBuffer，但不保证同步。这个类被设计成在StringBuffer单个线程正在使用字符串缓冲区的地方（如通常情况下）用作嵌入式替换 。在可能的情况下，建议优先使用此类， StringBuffer因为在大多数实现中它会更快。 上的主要操作StringBuilder是 append和insert方法，其被重载，以便接受任何类型的数据。每个有效地将给定的数据转换为一个字符串，然后将该字符串的字符追加或插入到字符串生成器。该 append方法总是在构建器的最后添加这些字符; 该insert方法在指定的点添加字符。 StringBuilder多线程使用的实例不安全。如果需要这种同步，则建议StringBuffer使用。 String：String类代表字符串。Java程序中的所有字符串文字，例如”abc”，都被实现为这个类的实例。字符串是不变的; 他们的价值创造后不能改变。字符串缓冲区支持可变字符串。因为String对象是不可变的，所以它们可以共享。 StringBuffer源码1.StringBuffer一个线程安全的，可变的字符序列。2.StringBuffer就像一个String，但可以修改。在任何时间点，它都包含一些特定的字符列，但是序列的长度和内容可以通过某些方法调用来改变3.字符串缓冲区对于多线程使用是安全的。 方法在必要时进行同步，以便任何特定实例上的所有操作的行为就好像它们以某种连续顺序发生一样，这与每个涉及的各个线程所进行的方法调用的顺序一致。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123; /** * 构造一个没有字符的字符串缓冲区，并且字符的初始容量为16个字符。 */ public StringBuffer() &#123; super(16); &#125; /* *构造一个没有字符的字符串缓冲区，并且指定的初始容量 */ public StringBuffer(int capacity) &#123; super(capacity); &#125; /* *构造一个字符串缓冲区，初始化为*指定字符串的内容。, 字符串缓冲区的初始容量是16加上字符串参数 *的长度。 */ public StringBuffer(String str) &#123; super(str.length() + 16); append(str); &#125; /** * 构造一个字符串缓冲区，其中包含与指定CharSequence相同的字符字符串缓冲区的初始 *容量是 16加上CharSequence参数的长度。 * @param seq */ public StringBuffer(CharSequence seq) &#123; this(seq.length() + 16); append(seq); &#125; //最常用的append 将sb加到该序列 synchronized修饰线程安全的 public synchronized StringBuffer append(StringBuffer sb) &#123; toStringCache = null; super.append(sb); return this; &#125; @Override public synchronized StringBuffer append(CharSequence s) &#123; toStringCache = null; super.append(s); return this; &#125; @Override synchronized StringBuffer append(AbstractStringBuilder asb) &#123; toStringCache = null; super.append(asb); return this; &#125; &#125; ####StringBufer类final修饰说明这个类是“终态的”,不能被继承。类中的方法默认是final所以不能被覆盖。final方法 方法将不能被覆盖 #####StringBuilder 一个可变的字符序列，该类提供一个api与stringCuffer兼容，但不是同步的。这个类被设计在单个线程使用字符串缓存的地方用作（StringBuffer）的嵌入替代品，在大多数实现中它更快。 1234567891011121314151617181920/**StringBuilder和stringBuffer 继承和实现的接口相同*/public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123;/**构造方法和StringBuffer相同*/ public StringBuilder() &#123; super(16); &#125; /* *不同就是append方法 StringBuffer的append方法被synchronized修饰所以是线程安 *全的 */ public StringBuilder append(StringBuffer sb) &#123; super.append(sb); return this; &#125; #####String是不可变的，他们的值创建后无法改变]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[java反射一 概念1.JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。通过class类调用自身的方法属性等二 class对象获得Class对象的由来是将class文件读入内存，并为之创建一个Class对象。通过这个对象可以获取类的相关信息 获取Class对象的三种方式1.1 Object ——&gt; getClass();1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性1.3 通过Class类的静态方法：forName（String ?className）(常用) public static void main(String[] args) { T515 t515=new T515(); /** * 1.返回此的运行时类 */ Class aClass=t515.getClass(); /** * 2.获取class对象 */ Class aClass1=T515.class; try { /** * 3.用给定的字符串名返回与类或接口关联的Class对象 */ Class aClass2 = Class.forName(&quot;T515.T515&quot;); System.out.println(aClass2==aClass); }catch (Exception e){ e.printStackTrace(); } System.out.println(aClass==aClass1); } 结果为 两个true 三 可以通过class对象获取类的相关类信息]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis 一对一级联 一对多]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fmybats%E7%BA%A7%E8%81%94%2F</url>
    <content type="text"><![CDATA[一：一对一 用association 一 建表 course 课程与score 课程成绩表是一对一关系 course课程表 score课程成绩表 连接数据库dbconf.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN” “http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 写一个db.properties文件jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybajdbc.username=rootjdbc.password=××× 二 使用mybatis插件自动生成相对应表的配置文件 CourseMapper.xml &lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; SELECT myba.course.* from myba.course WHERE coid=#{coid} CourseMapper接口*CourseMapper.xml是对接口的实现 所以 select 的id与接口中方法名相同package com.ygy.mapper; import com.ygy.model.Course;import com.ygy.model.CourseExample;import java.util.List;import org.apache.ibatis.annotations.Param; public interface CourseMapper { public Course selectcou(int id);} ScoreMapper.xml&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; select myba.score. from myba.score WHERE myba.score.scsid=#{id} ScoreMapper接口package com.ygy.mapper;import com.ygy.model.Score;import com.ygy.model.ScoreExample;import java.util.List;import org.apache.ibatis.annotations.Param;public interface ScoreMapper { public Score selectscore(int id);}在score的model中加上private Course course;//get set方法三 测试@Test public void main(){ SqlSessionFactory sqlSessionFactory; InputStream inputStream; try { inputStream= Resources.getResourceAsStream(“dbconf.xml”); sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); sqlSession=sqlSessionFactory.openSession()； //SCORC和course一对一 ScoreMapper scoreMapper=sqlSession.getMapper(ScoreMapper.class); Score score=scoreMapper.selectscore(1); System.out.println(score.getCourse().getConame()); } catch (IOException e) { e.printStackTrace(); }finally { sqlSession.close(); }二：一对多 collection加入学生表stud插件生成对应的接口什么的&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; SELECT myba.stud. FROM myba.stud WHERE myba.stud.sid=#{id} 接口package com.ygy.mapper; import com.ygy.model.Stud;import com.ygy.model.StudExample;import java.util.List;import org.apache.ibatis.annotations.Param; public interface StudMapper { public Stud selectsud(int id);} 测试@Test public void main(){ SqlSessionFactory sqlSessionFactory; InputStream inputStream; try { inputStream= Resources.getResourceAsStream(&quot;dbconf.xml&quot;); sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); sqlSession=sqlSessionFactory.openSession(); StudMapper studMapper=sqlSession.getMapper(StudMapper.class); Stud stud=studMapper.selectsud(1); System.out.println(stud.getScoreList().get(1).getMark()); } catch (IOException e) { e.printStackTrace(); }finally { sqlSession.close(); } 结果：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F23%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[mybatis自动生成代码插件]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F23%2Fmybatis%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一.generatorconfig.xml文件12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;mysqlgenerator&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ygy&quot; userId=&quot;root&quot; password=&quot;***&quot; /&gt; 1&lt;!--targetProject 后面跟的是model放的位置 targetPackage放的包名--&gt; 123456789101112 &lt;javaModelGenerator targetPackage=&quot;com.nomico271.model&quot; targetProject=&quot;src&quot; /&gt; &lt;sqlMapGenerator targetPackage=&quot;com.nomico271.mapper&quot; targetProject=&quot;src&quot; /&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.nomico271.mapper&quot; targetProject=&quot;src&quot; /&gt; &lt;table tableName=&quot;ygy1&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; ##二.pox.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;generator&lt;/groupId&gt; &lt;artifactId&gt;generator&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;generator Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt;//××引包 &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;generator&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 12 12完成上面的配置 然后打开maven--&gt;plugins---&gt;mybatis-generator---&gt;mybatis-generator:generate运行mybatis-generator:generate完成自动生成所需要的文件 123456789101112131415161718192021222324252627282930313233## 三.添加数据到数据库中import com.nomico271.model.Ygy1;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;public class main &#123; static Reader reader; static SqlSession session; public static void main(String[] args) &#123; try &#123; reader= Resources.getResourceAsReader(&quot;ygy.xml&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader); session=sqlSessionFactory.openSession(); Ygy1 ygy1=new Ygy1(); ygy1.setId(3); ygy1.setName(&quot;sdhuaik&quot;); session.insert(&quot;insert&quot;,ygy1); session.commit(); session.close(); &#125; &#125;&#125;运行程序显示 说明添加成功（其他删，改，查相似）]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
