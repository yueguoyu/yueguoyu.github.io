<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Stomp面向简单文本的消息传递协议]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2FStomp%E9%9D%A2%E5%90%91%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Stomp面向简单文本的消息传递协议是什么：STOMP是简单（或流式）文本定向消息协议。 STOMP提供可互操作的线路格式，以便STOMP客户端可以与任何STOMP消息代理进行通信，以便在多种语言，平台和代理之间提供简单和广泛的消息互操作性。 设计： STOMP是一个非常简单易用的协议，来自HTTP设计学院; 服务器端可能很难实现，但编写客户端以便连接起来非常容易。例如，您可以使用Telnet登录到任何STOMP代理并与其交互！ WebSocket是一种在单个Tcp连接上进行全双工通讯的协议在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 背景：WebSocket协议是由HTML5定义的，它能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 Websocket使用ws或wss的统一资源标志符，类似于HTTPS，其中wss表示在TLS之上的Websocket。 Websocket使用和 HTTP 相同的 TCP 端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。 优点：1.较少的控制开销。 在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。2.更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。3.保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。4.更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。5.可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。6.更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。 握手协议：WebSocket 是独立的、创建在 TCP 上的协议。Websocket 通过 HTTP/1.1 协议的101状态码进行握手。为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。 例子:一个典型的Websocket握手请求如下：客户端请求1234567GET / HTTP/1.1Upgrade: websocket //表示希望升级到Websocket协议。Connection: Upgrade //表示客户端希望连接升级Host: example.com Origin: http://example.comSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ== //Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。Sec-WebSocket-Version: 13 //表示支持的Websocket版本。 服务器回应12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=Sec-WebSocket-Location: ws://example.com/ HTTPS超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过电脑网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。 主要思想HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。 HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构（如Symantec、Comodo、GoDaddy和GlobalSign等）（意即“我信任证书颁发机构告诉我应该信任的”）。因此，一个到某网站的HTTPS连接可被信任，当且仅当： 用户相信他们的浏览器正确实现了HTTPS且安装了正确的证书颁发机构；用户相信证书颁发机构仅信任合法的网站；被访问的网站提供了一个有效的证书，意即，它是由一个被信任的证书颁发机构签发的（大部分浏览器会对无效的证书发出警告）；该证书正确地验证了被访问的网站（如，访问https://example.com时收到了给example.com而不是其它组织的证书）；或者互联网上相关的节点是值得信任的，或者用户相信本协议的加密层（TLS或SSL）不能被窃听者破坏。HTTPS不应与在 RFC 2660 中定义的安全超文本传输协议（S-HTTP）相混淆。 与HTTP差别与HTTP的URL由“http://”起始且默认使用端口80不同，HTTPS的URL由“https://”起始且默认使用端口443。 HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，并在正确配置时被认为是安全的。 HTTP超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 协议概述HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMap ：带符号右移。正数右移高位补0，负数右移高位补1。比如： 4 &gt;&gt; 1，结果是2；-4 &gt;&gt; 1，结果是-2。-2 &gt;&gt; 1，结果是-1。 ：无符号右移。无论是正数还是负数，高位通通补0。 对于正数而言，&gt;&gt;和&gt;&gt;&gt;没区别。 简介1.HashMap基于哈希的map接口实现。2.HashMap 类大致相当于 Hashtable ，只是它是非同步的并且允许为空值。3.HashMap根据键的hashCode值存储数据，一般直接可以定位到它的值，但他遍历顺序是不确定的。HashMap只允许key中只有一个null，而value可以是多个，HashMap是非线程安全的。如果要满足线程安全，可以用Collection的synchronizedMap方法使的HashMap具有线程安全的能力，或使用ConcurrentHashMap。 内部实现从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。 1.HashMap中有Node&lt;K,V&gt;[] table 即哈希桶数组。HashMap的内部类123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 2.HashMap构造方法。12345678910111213141516/**使用指定的初始容量和指定加载因子构造一个空的HashMap*/public HashMap(int initialCapacity, float loadFactor)&#123;...&#125;/**使用指定的初始容量和默认加载因子（0.75）构造一个空的HashMap*/ public HashMap(int initialCapacity)&#123;...&#125; /* *使用默认的初始容量（16）和默认加载因子（0.75）构造一个空的HashMap */ public HashMap() &#123;...&#125; /* *使用与指定的&lt;tt&gt; Map &lt;/ tt&gt;相同的映射构造一个新的HashMapHashMap用默认加载因子 *（0.75）和一个初始容量来创建，该容量足以将映射保存在指定的Map */ public HashMap(Map&lt;? extends K, ? extends V&gt; m)&#123;...&#125; 3.jdk1.8 HashMap的put方法源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i;// 判断table是否为空，创建默认大小 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length;// 计算index，并对null做处理 （有点懵） if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; HashMap.Node&lt;K,V&gt; e; K k; //节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //判断是否是红黑树 else if (p instanceof HashMap.TreeNode) e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //该链为链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //key存在就覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //超过阈值就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 4.HashMap 扩容扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。 （1）.jdk1.7的扩容是当容量大于阈值时，使用大的数组代替小的数组 12345678910111213141516171819202122232425262728293031 void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 &#125; //用于将原来的数组中的数据拷贝到新的数组 void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null);&#125;&#125; &#125; jdk1.7扩容后会重新计算每个元素在数组中的位置，当put时数据会放在链表的前面，所以最先插入的数据应该在链表的末尾。（2）.jdk1.8123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final HashMap.Node&lt;K,V&gt;[] resize() &#123; HashMap.Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //判断是否大于最大容量 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //当小于最大容量时，扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) HashMap.Node&lt;K,V&gt;[] newTab = (HashMap.Node&lt;K,V&gt;[])new HashMap.Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; HashMap.Node&lt;K,V&gt; e; //遍历老数组，并释放它 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) //e的哈希和新的容量-1做与运算 得出在新数组的位置 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof HashMap.TreeNode)//判断它是红黑树 ((HashMap.TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 HashMap.Node&lt;K,V&gt; loHead = null, loTail = null; HashMap.Node&lt;K,V&gt; hiHead = null, hiTail = null; HashMap.Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 线程安全性HashMap是非线程安全的，线程安全的ConcurrentHashMap。在多线程情况下HashMap会产生死循环]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组加一]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[##两数之和 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 使用hashmap将数组中的值作为key，下标作为value值放入map中，查的时候只找map中是否有target-nums[i]，则返回的就是i和target-nums[i]的下标。1234567891011121314public static int[] twoSum1(int[] nums, int target) &#123; if (nums == null) &#123; return null; &#125; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(target-nums[i])) &#123; return new int[]&#123;map.get(target - nums[i]), i&#125;; &#125;else &#123; map.put(nums[i], i); &#125; &#125; return null; &#125; 返回两个数的值指针i指向数组的头，而j指向屁股，然后直到他俩相遇123456789101112131415161718192021222324252627282930public static int[] twoSum(int[] nums, int target) &#123; if (nums == null) &#123; return null; &#125; int i = 0; int j = nums.length - 1; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int x = 0; x &lt; nums.length; x++) &#123; while (i &lt; x &amp;&amp; j &gt; x) &#123; if (Math.abs(i - j) == 1) &#123; break; &#125; if (j &gt;= 0 &amp;&amp; target &lt; nums[j]) &#123; j--; &#125; if (i &lt; nums.length &amp;&amp; j &gt;= 0 &amp;&amp; nums[i] + nums[j] == target) &#123; list.add(nums[i]); i++; list.add(nums[j]); j--; &#125; &#125; &#125; int[] re = new int[list.size()]; for (int i1 = 0; i1 &lt; re.length; i1++) &#123; re[i1] = list.get(i1); &#125; return re; &#125; 123456789101112131415161718func twoSum(nums []int, target int) []int &#123; if nums==nil &#123; return nil &#125; m:=make(map[int]int) for i:=0;i&lt;len(nums) ;i++ &#123; captial,ok:=m[target-nums[i]] if ok&#123; s:=[] int&#123;captial,i&#125; return s &#125;else &#123; m[nums[i]]=i &#125; &#125;return nil&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组加一]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2F%E6%95%B0%E7%BB%84%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[加一 给定一个非负整数组成的非空数组，在该数的基础上加一，返回一个新的数组。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 #####Java：1234567891011121314151617public static int[] plusOne(int[] digits) &#123; int creay=1; for (int i=digits.length-1;i&gt;=0;i--)&#123; if (creay==0)&#123; return digits; &#125; int tmp=digits[i]+creay; creay=tmp/10; digits[i]=tmp%10; &#125; if (creay!=0) &#123; int [] re=new int[digits.length+1]; re[0]=1; return re; &#125; return digits;&#125; #####go:1234567891011121314151617func plusOne(a [] int) [] int&#123; crray:=1 for i:=len(a)-1;i&gt;=0 ; i-- &#123; if crray==0 &#123; return a &#125; tmp:=a[i]+crray crray=tmp/10 a[i]=tmp%10 &#125; if crray!=0 &#123; var newa [] int=make([]int,len(a)+1) newa[0]=1 return newa &#125; return a&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 并发编程实战 读书笔记]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2Fjava-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[对象的共享简述：已知同步方法和同步代码块，可以以原子性的方式执行。同步还可以通过内存可见性实现。当多个线程对一个公共的数据进行set和get ，如果set和get方法不用synchronized修饰是非线程安全的。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 失效数据多个线程调用一个数据时，一个线程获取的数据不是最新的，而是一个过期的数据。失效问题：一个线程set后另一个线程get的数据可能不是最新的获知可能获取不到。 非原子的64位操作非volatile类型double，long变量，jvm在对64位的double或long变量的读操作或写操作是分为高位32和低位32位进行操作的，在进行操作时可能是取一个数的高32位而取另一个数的低32位。所以在多线程情况下要使用volatile关键字对double，long变量进行修饰。 volatile变量volatile变量是一种稍微的同步机制。volatile变量不会存在寄存器或者对其他处理器不可见的地方，因此每次读取的数据都是最新的。volatile是一种比synchronization稍微弱的同步机制。访问volatile变量时不需要加锁操作，因此也就不会使执行线程阻塞的。正确使用方法：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如，初始化或关闭）局限性：volatile变量通常用做某个操作完成，发生中断或者状态的标志。 ####### 加锁机制能可以确保原子性和可见性，而volatile只能确保可见性。使用volatile前提：1.对变量的写入操作不依赖变量的当前值；2.该变量不会与其他状态变量一起纳入不变性条件中。3.在访问时不需要加锁。 线程封闭一种避免使用同步的方法就是不共享数据。线程封闭是实现线程安全性的最简单的方式之一。Ad-hoc线程封闭Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担，它是非常脆弱的，因为没有任何一种语言特性，能将对象封闭到目标线程上。一般不使用。栈封闭在栈封闭中，只能通过局部变量才能访问对象。局部变量封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭也被称为线程内部使用或线程局部使用。比Ad-hoc更加易于维护，更加健壮。ThreadLocal类ThreadLocal类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。ThreadLoacl类中使用map存储数据，key为线程而value为变量副本。ThreadLocal类中有一个ThreadLocalMap内部类，用来存储副本key为线程，而value为变量的副本。 不变性什么是不变性不变性指对象的状态不改变。不变性对象一定是线程安全的。满足条件1.对象创建后其状态不再改变2.对象的所有域都是final类型的3.对象是正确创建的（在对象创建之间，this引用没有逸出） Final域final域能确保初始化过程中的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象的时无须同步。 除非需要更高的可见性，否则应将所有的域都声明为私有域除非需要某个域是可变的，否则应将其声明为final域]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机2]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路：因为要获取最大利润，所以只要后面比前面的大就获利123456789101112131415161718192021222324252627282930313233343536java版本:class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices==null || prices.length==0)&#123; return 0; &#125; int min=prices[0]; int sum=0; for (int i=1;i&lt;prices.length;i++)&#123; if (prices[i]&gt;min)&#123; sum+=prices[i]-min; min=prices[i]; &#125;else &#123; min=prices[i]; &#125; &#125; return sum; &#125;&#125; 1234567891011121314151617go版本:func max(a []int) int &#123; if len(a)==0 &#123; return 0 &#125; min := a[0] sum :=0 for i:=0;i&lt;len(a) ;i++ &#123; if min&lt;a[i] &#123; sum+=(a[i]-min) min=a[i] &#125;else &#123; min=a[i] &#125; &#125; return sum&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F29%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[旋转数组给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明:123- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。- 要求使用空间复杂度为 O(1) 的原地算法。 方法一：123456789101112-利用length-k将数组分为两部分-分别调换两段数组-再转化整个数组例如： 1 2 3 4 5 6 7 如果k = 3 的话， 会变成 5 6 7 1 2 3 4 1 2 3 4 5 6 7 middle = 7 - 3 = 4，分为左边 4个数字，右边 3个数字 4 3 2 1 7 6 5 分别把左右swap 一下 5 6 7 1 2 3 4 把总数组swap 一下就会得到答案​` java:​123456789101112131415161718192021class Solution &#123; public void rotate(int[] nums, int k) &#123; if (nums.length==0||nums==null||k%nums.length==0)&#123; return ; &#125; int t=k%nums.length; int sta=nums.length-t; swap(nums,0,sta-1); swap(nums,sta,nums.length-1); swap(nums,0,nums.length-1); &#125; public static void swap(int[] a, int i, int j) &#123; while(i&lt;j) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; &#125;&#125; go:12345678910111213141516171819func rotate(nums []int,k int) &#123; if len(nums)==0 || nums==nil ||k%len(nums)==0 &#123; return &#125; t:=k%len(nums) sta:=len(nums)-t swap(nums,0,sta-1) swap(nums,sta,len(nums)-1) swap(nums,0,len(nums)-1)&#125;func swap(a [] int,i int,j int) &#123; for i&lt;j&#123; tmp:=a[i] a[i]=a[j] a[j]=tmp i++ j-- &#125;&#125; 方法二：12-创建一个大小相同的数组-然后将原数组中的值写到新数组中，关键点（a[(i + k) % nums.length] = nums[i];） 12345678public static int[] rotate1(int[] nums, int k) &#123; int[] a = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; //关键点 a[(i + k) % nums.length] = nums[i]; &#125; return a; &#125; go:12345678func rotate1(nums [] int,k int) []int&#123; //go中切片 相当于动态数组 切片的长度不是固定的，在追加时可能使的容量增大 var a [] int=make([]int,len(nums)) for i:=0;i&lt;len(nums) ;i++ &#123; a[(i+k)%len(nums)]=nums[i] &#125; return a&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql配置]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fmysql%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[踩过的坑 防止再掉 1.mysql文件和文件夹(linux 配置文件文件后缀为cnf) bin 放可执行性文件 include 存放头文件 lib 存放库文件 share 存放字符集，语言等信息 my.ini mysql软件正在使用的配置文件 my-huge.ini 当mysql软件为超大型数据库时使用的配置文件 my-small.ini 当mysql软件为小型数据库时使用的配置文件 my-template.ini 配置文件模板 2.my.ini配置文件中的内容可实现修改数据库实例的参数（linux中为my.cnf） 客户端 [mysql] 客户端的端口号 prot=3306 客户端默认字符集 default-character-set=utf8 [mysqld] 服务端 prot=3306 数据库服务器的安装目录 basedir=？？？？ mysql数据库数据文件的目录 datadir=？？？ mysql软件端的字符集 character-set-server=utf8 mysql软件的存储引擎 default-storage-engine=INNODB mysql最大连接数 max-connections=100 mysql软件缓存 query_cache_size=0 mysql中可以打开表的总数 table_cache=256 mysql软件内存中可以存储临时表的最大值 tem_table_size=9m mysql软件可以保留的客户端链接线程数 thread_cache_size=8 mysql软件重建索引时允许的最大临时文件的大小 myisam_max_sort_file_size=10G mysql软件重建索引时允许的最大缓存的大小 myisam_sort_buffer_size=17m mysql软件中最大关键字缓存的大小 key_buffer_size=10m mysql软件全扫描myisam表时的缓存大小 read_buffer_size=6k mysql软件可以插入排序好的数据的缓存的小 read_rnd_buffer_size=256k mysql软件用户排序时缓存的大小 sort_buffer_size=256k 关于INNODB存储引擎参数设置附加内存池大小 innodb_additional_mem_pool_size=2m 关于提交日志的时机 innodb_flush_log_at_trx_commit=1 存储日志数据的缓存区的大小 innodb_log_buffer_size=1m 缓存池中缓存区的大小 innodb_buffer_pool_size=17m 日记文件的大小 innodb_log_file_size=10m 允许线程的最大数 innodb_thread_concurrency=8]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 和 StringBuffer 和 StringBuilder]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2FString%20%E5%92%8C%20StringBuffer%20%E5%92%8C%20StringBuilder%2F</url>
    <content type="text"><![CDATA[三者不同点 1，string 类是不可变的，一旦创建了String对象，那她就无法改变2，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 线程安全StringBuffer是线程安全的，而StringBuilder是非线程安全的。 运行速度1.StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 2.StringBuffer 和 StringBuilder 长度可变 StringBuffer &amp;&amp; StringBuilder &amp;&amp; String StringBuffer：一个线程安全的，可变的字符序列。字符串缓冲区就像一个String，但可以修改。在任何时候它都包含一些特定的字符序列，但是序列的长度和内容可以通过某些方法调用来改变。字符串缓冲区对于多线程来说是安全的。这些方法在必要时进行同步，以便任何特定实例上的所有操作的行为就好像它们以某种连续顺序发生，这与每个涉及的单个线程所进行的方法调用的顺序一致。 上的主要操作StringBuffer是 append和insert方法，其被重载，以便接受任何类型的数据。每个函数都有效地将给定的数据转换为字符串，然后将该字符串的字符附加或插入到字符串缓冲区中。该 append方法总是将这些字符添加到缓冲区的末尾; 该insert方法在指定的点添加字符。 如果sb指的是a的一个实例StringBuffer，那么sb.append(x)效果与之相同 sb.insert(sb.length(), x)。 每个字符串缓冲区都有一个容量 只要包含在字符串缓冲区中的字符序列的长度不超过容量，就不需要分配新的内部缓冲区数组。如果内部缓冲区溢出，它会自动变大。从版本JDK 5开始，这个类已经补充了一个为单个线程设计的等价类StringBuilder。由于StringBuilder类支持所有相同的操作，所以通常会优先使用StringBuilder类，但速度更快，因为它不执行同步操作。 StringBuilder：一个可变的字符序列。这个类提供了一个兼容的API StringBuffer，但不保证同步。这个类被设计成在StringBuffer单个线程正在使用字符串缓冲区的地方（如通常情况下）用作嵌入式替换 。在可能的情况下，建议优先使用此类， StringBuffer因为在大多数实现中它会更快。 上的主要操作StringBuilder是 append和insert方法，其被重载，以便接受任何类型的数据。每个有效地将给定的数据转换为一个字符串，然后将该字符串的字符追加或插入到字符串生成器。该 append方法总是在构建器的最后添加这些字符; 该insert方法在指定的点添加字符。 StringBuilder多线程使用的实例不安全。如果需要这种同步，则建议StringBuffer使用。 String：String类代表字符串。Java程序中的所有字符串文字，例如”abc”，都被实现为这个类的实例。字符串是不变的; 他们的价值创造后不能改变。字符串缓冲区支持可变字符串。因为String对象是不可变的，所以它们可以共享。 StringBuffer源码1.StringBuffer一个线程安全的，可变的字符序列。2.StringBuffer就像一个String，但可以修改。在任何时间点，它都包含一些特定的字符列，但是序列的长度和内容可以通过某些方法调用来改变3.字符串缓冲区对于多线程使用是安全的。 方法在必要时进行同步，以便任何特定实例上的所有操作的行为就好像它们以某种连续顺序发生一样，这与每个涉及的各个线程所进行的方法调用的顺序一致。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123; /** * 构造一个没有字符的字符串缓冲区，并且字符的初始容量为16个字符。 */ public StringBuffer() &#123; super(16); &#125; /* *构造一个没有字符的字符串缓冲区，并且指定的初始容量 */ public StringBuffer(int capacity) &#123; super(capacity); &#125; /* *构造一个字符串缓冲区，初始化为*指定字符串的内容。, 字符串缓冲区的初始容量是16加上字符串参数 *的长度。 */ public StringBuffer(String str) &#123; super(str.length() + 16); append(str); &#125; /** * 构造一个字符串缓冲区，其中包含与指定CharSequence相同的字符字符串缓冲区的初始 *容量是 16加上CharSequence参数的长度。 * @param seq */ public StringBuffer(CharSequence seq) &#123; this(seq.length() + 16); append(seq); &#125; //最常用的append 将sb加到该序列 synchronized修饰线程安全的 public synchronized StringBuffer append(StringBuffer sb) &#123; toStringCache = null; super.append(sb); return this; &#125; @Override public synchronized StringBuffer append(CharSequence s) &#123; toStringCache = null; super.append(s); return this; &#125; @Override synchronized StringBuffer append(AbstractStringBuilder asb) &#123; toStringCache = null; super.append(asb); return this; &#125; &#125; ####StringBufer类final修饰说明这个类是“终态的”,不能被继承。类中的方法默认是final所以不能被覆盖。final方法 方法将不能被覆盖 #####StringBuilder 一个可变的字符序列，该类提供一个api与stringCuffer兼容，但不是同步的。这个类被设计在单个线程使用字符串缓存的地方用作（StringBuffer）的嵌入替代品，在大多数实现中它更快。 1234567891011121314151617181920/**StringBuilder和stringBuffer 继承和实现的接口相同*/public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123;/**构造方法和StringBuffer相同*/ public StringBuilder() &#123; super(16); &#125; /* *不同就是append方法 StringBuffer的append方法被synchronized修饰所以是线程安 *全的 */ public StringBuilder append(StringBuffer sb) &#123; super.append(sb); return this; &#125; #####String是不可变的，他们的值创建后无法改变]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[java反射一 概念1.JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。通过class类调用自身的方法属性等二 class对象获得Class对象的由来是将class文件读入内存，并为之创建一个Class对象。通过这个对象可以获取类的相关信息 获取Class对象的三种方式1.1 Object ——&gt; getClass();1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性1.3 通过Class类的静态方法：forName（String ?className）(常用) public static void main(String[] args) { T515 t515=new T515(); /** * 1.返回此的运行时类 */ Class aClass=t515.getClass(); /** * 2.获取class对象 */ Class aClass1=T515.class; try { /** * 3.用给定的字符串名返回与类或接口关联的Class对象 */ Class aClass2 = Class.forName(&quot;T515.T515&quot;); System.out.println(aClass2==aClass); }catch (Exception e){ e.printStackTrace(); } System.out.println(aClass==aClass1); } 结果为 两个true 三 可以通过class对象获取类的相关类信息]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis 一对一级联 一对多]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fmybats%E7%BA%A7%E8%81%94%2F</url>
    <content type="text"><![CDATA[一：一对一 用association 一 建表 course 课程与score 课程成绩表是一对一关系 course课程表 score课程成绩表 连接数据库dbconf.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN” “http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 写一个db.properties文件jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybajdbc.username=rootjdbc.password=××× 二 使用mybatis插件自动生成相对应表的配置文件 CourseMapper.xml &lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; SELECT myba.course.* from myba.course WHERE coid=#{coid} CourseMapper接口*CourseMapper.xml是对接口的实现 所以 select 的id与接口中方法名相同package com.ygy.mapper; import com.ygy.model.Course;import com.ygy.model.CourseExample;import java.util.List;import org.apache.ibatis.annotations.Param; public interface CourseMapper { public Course selectcou(int id);} ScoreMapper.xml&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; select myba.score. from myba.score WHERE myba.score.scsid=#{id} ScoreMapper接口package com.ygy.mapper;import com.ygy.model.Score;import com.ygy.model.ScoreExample;import java.util.List;import org.apache.ibatis.annotations.Param;public interface ScoreMapper { public Score selectscore(int id);}在score的model中加上private Course course;//get set方法三 测试@Test public void main(){ SqlSessionFactory sqlSessionFactory; InputStream inputStream; try { inputStream= Resources.getResourceAsStream(“dbconf.xml”); sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); sqlSession=sqlSessionFactory.openSession()； //SCORC和course一对一 ScoreMapper scoreMapper=sqlSession.getMapper(ScoreMapper.class); Score score=scoreMapper.selectscore(1); System.out.println(score.getCourse().getConame()); } catch (IOException e) { e.printStackTrace(); }finally { sqlSession.close(); }二：一对多 collection加入学生表stud插件生成对应的接口什么的&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; SELECT myba.stud. FROM myba.stud WHERE myba.stud.sid=#{id} 接口package com.ygy.mapper; import com.ygy.model.Stud;import com.ygy.model.StudExample;import java.util.List;import org.apache.ibatis.annotations.Param; public interface StudMapper { public Stud selectsud(int id);} 测试@Test public void main(){ SqlSessionFactory sqlSessionFactory; InputStream inputStream; try { inputStream= Resources.getResourceAsStream(&quot;dbconf.xml&quot;); sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); sqlSession=sqlSessionFactory.openSession(); StudMapper studMapper=sqlSession.getMapper(StudMapper.class); Stud stud=studMapper.selectsud(1); System.out.println(stud.getScoreList().get(1).getMark()); } catch (IOException e) { e.printStackTrace(); }finally { sqlSession.close(); } 结果：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis自动生成代码插件]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F23%2Fmybatis%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一.generatorconfig.xml文件12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;mysqlgenerator&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ygy&quot; userId=&quot;root&quot; password=&quot;***&quot; /&gt; 1&lt;!--targetProject 后面跟的是model放的位置 targetPackage放的包名--&gt; 123456789101112 &lt;javaModelGenerator targetPackage=&quot;com.nomico271.model&quot; targetProject=&quot;src&quot; /&gt; &lt;sqlMapGenerator targetPackage=&quot;com.nomico271.mapper&quot; targetProject=&quot;src&quot; /&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.nomico271.mapper&quot; targetProject=&quot;src&quot; /&gt; &lt;table tableName=&quot;ygy1&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; ##二.pox.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;generator&lt;/groupId&gt; &lt;artifactId&gt;generator&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;generator Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt;//××引包 &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;generator&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 12 12完成上面的配置 然后打开maven--&gt;plugins---&gt;mybatis-generator---&gt;mybatis-generator:generate运行mybatis-generator:generate完成自动生成所需要的文件 123456789101112131415161718192021222324252627282930313233## 三.添加数据到数据库中import com.nomico271.model.Ygy1;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;public class main &#123; static Reader reader; static SqlSession session; public static void main(String[] args) &#123; try &#123; reader= Resources.getResourceAsReader(&quot;ygy.xml&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader); session=sqlSessionFactory.openSession(); Ygy1 ygy1=new Ygy1(); ygy1.setId(3); ygy1.setName(&quot;sdhuaik&quot;); session.insert(&quot;insert&quot;,ygy1); session.commit(); session.close(); &#125; &#125;&#125;运行程序显示 说明添加成功（其他删，改，查相似）]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F23%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
</search>
