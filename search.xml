<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[质数因子]]></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F10%2F%E8%B4%A8%E6%95%B0%E5%9B%A0%E5%AD%90%2F</url>
    <content type="text"><![CDATA[质数因子题目描述功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（如180的质因子为2 2 3 3 5 ） 最后一个数后面也要有空格 详细描述： 函数接口说明： public String getResult(long ulDataInput) 输入参数： long ulDataInput：输入的正整数 返回值： String 输入描述:1输入一个long型整数 输出描述:1按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。 示例1 输入复制 1180 输出复制 12 2 3 3 5 解：使用递归，将大问题化简成小问题，质数就是只是能被自身和1整除。质数因子就是所有质数相乘等于这个数。 2x2x3x3x5=180 1234567891011121314151617181920212223242526272829import java.util.*;/** * 测试 * * @author ygy ygy * @create 2020-04-03 20:28 **/public class Main&#123; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while(scanner.hasNext())&#123; long num = scanner.nextLong(); canculate(num); &#125; &#125; public static void canculate(long num)&#123; for (int i=2;i&lt;=num;i++)&#123; if (num%i==0)&#123; System.out.print(i+" "); canculate(num/i); return; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F10%2F%E5%AD%97%E4%B8%B2%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[title: 字串的连接最长路径查找date: 2020-4-10 16:40:25tags: leetCodecategories: 算法 字串的连接最长路径查找题目描述给定n个字符串，请对n个字符串按照字典序排列。 输入描述:1输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述:1数据输出n行，输出结果为按照字典序排列的字符串。 示例1 输入复制 123456789109captocatcardtwotooupboatboot 输出复制 123456789boatbootcapcardcattotootwoup 解：使用Arrays的sort方法直接排序 注意使用scanner.next()方法而不是使用nextLine()方法，nextLine()方法不会去掉空格，会使输入少一行。123456789101112131415161718192021222324import java.util.*;/** * 测试 * * @author ygy ygy * @create 2020-04-03 20:28 **/public class Main &#123; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while (scanner.hasNext())&#123; int n=scanner.nextInt(); String[] str=new String[n]; for (int i=0;i&lt;n;i++)&#123; str[i]=scanner.next(); &#125; Arrays.sort(str); for (String s:str)&#123; System.out.println(s); &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[句子逆序]]></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F10%2F%E5%8F%A5%E5%AD%90%E9%80%86%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[句子逆序题目描述将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 接口说明 /* \ 反转句子 * * @param sentence 原句子 * @return 反转后的句子 */public String reverse(String sentence); 输入描述:1将一个英文语句以单词为单位逆序排放。 输出描述:1得到逆序的句子 示例1 输入复制 1I am a boy 输出复制 1boy a am I 解：next（）输入和nextLine()输入的区别，next（）会自动消去有效字符前的空格，只返回输入的字符，不能得到带空格的字符串。nextLine（）会保留空格。直接将string使用split（）方法按空格切分变成string[],直接倒着遍历输出 1234567891011121314151617181920import java.util.*;/** * 测试 * * @author ygy ygy * @create 2020-04-03 20:28 **/public class Main &#123; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while (scanner.hasNext())&#123; String s=scanner.nextLine(); String[] ns=s.split(" "); for (int i=0;i&lt;ns.length;i++)&#123; System.out.print(ns[ns.length-1-i]+" "); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F10%2F%E6%95%B0%E5%AD%97%E9%A2%A0%E5%80%92%2F</url>
    <content type="text"><![CDATA[title: 数字颠倒date: 2020-4-10 14:07:25tags: leetCodecategories: 算法 数字颠倒题目描述描述： 输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 输入描述:1输入一个int整数 输出描述:1将这个整数以字符串的形式逆序输出 示例1 输入复制 11516000 输出复制 10006151 解：将int使用String的ValueOf方法转换成String类型，使用toCharArray方法将string转换成char[]，然后反向遍历。 123456789101112131415161718192021import java.util.*;/** * 测试 * * @author ygy ygy * @create 2020-04-03 20:28 **/public class Main &#123; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while(scanner.hasNext())&#123; int n=scanner.nextInt(); String str= String.valueOf(n); char[] cs= str.toCharArray(); for (int i=0;i&lt;cs.length;i++)&#123; System.out.print(cs[cs.length-i-1]); &#125; &#125; &#125;&#125; 2.直接使用StringBuffer直接使用StringBuffer的reverse()方法，直接反转字符串。 12345678910111213141516171819import java.util.*;/** * 测试 * * @author ygy ygy * @create 2020-04-03 20:28 **/public class ygymain &#123; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while(scanner.hasNext())&#123; int n=scanner.nextInt(); StringBuffer sb=new StringBuffer(String.valueOf(n)); sb.reverse(); System.out.println(sb); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F10%2F%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[title: 字符个数统计date: 2020-4-10 13:47:25tags: leetCodecategories: 算法 字符个数统计题目描述编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)，换行表示结束符，不算在字符里。不在范围内的不作统计。 输入描述:1输入N个字符，字符在ACSII码范围内。 输出描述:1输出范围在(0~127)字符的个数。 示例1 输入复制 1abc 输出复制 13 解：直接使用toCharArray方法将string转化成char[]，然后遍历。使用set的add方法添加，set的add方法当set里面没有这个数值时添加并返回true，有这个值时返回false。 12345678910111213141516171819202122232425import java.util.*;/** * 测试 * * @author ygy ygy * @create 2020-04-03 20:28 **/public class Main &#123; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while (scanner.hasNext())&#123; Set&lt;Character&gt; set=new HashSet&lt;&gt;(); String s= scanner.next(); char[] cs= s.toCharArray(); int num=0; for (int i=0;i&lt;cs.length;i++)&#123; if (set.add(cs[i]))&#123; num++; &#125; &#125; System.out.println(num); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F10%2F%E6%8F%90%E5%8F%96%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[title: 进制转换date: 2020-4-10 13:32:25tags: leetCodecategories: 算法 提取不重复的整数题目描述输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 输入描述:1输入一个int型整数 输出描述:1按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 示例1 输入复制 19876673 输出复制 137689 解：将int直接转换成string，然后使用split(“”)将string变成string[]数组。然后反向遍历，使用set判断是否有重复。 1234567891011121314151617181920212223import java.util.*;/** * 测试 * * @author ygy ygy * @create 2020-04-03 20:28 **/public class Main &#123; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while (scanner.hasNext())&#123; Set&lt;String&gt; set=new HashSet&lt;&gt;(); int n=scanner.nextInt(); String[] cs= String.valueOf(n).split(""); for (int i=0;i&lt;cs.length;i++)&#123; if (set.add(cs[cs.length-i-1]))&#123; System.out.print(cs[cs.length-1-i]); &#125; &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F10%2F%E5%90%88%E5%B9%B6%E8%A1%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[title: 合并表记录date: 2020-4-10 10:35:25tags: leetCodecategories: 算法 合并表记录题目描述数据表记录包含表索引和数值（int范围的整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。 输入描述:12先输入键值对的个数然后输入成对的index和value值，以空格隔开 输出描述:1输出合并后的键值对（多行） 示例1 输入复制 1234540 10 21 23 4 输出复制 1230 31 23 4 解：直接使用TreeMap就行，开始没有看见题目要求 按照从小往大的顺序输出。直接使用HashMap结果只通过80%。 123456789101112131415161718192021222324252627282930313233import java.util.*;/** * 测试 * * @author ygy ygy * @create 2020-04-03 20:28 **/public class Main &#123; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while(scanner.hasNext())&#123; Map&lt;Integer,Integer&gt; map=new TreeMap&lt;&gt;(); int n=scanner.nextInt(); if (n&lt;=0)&#123;return;&#125; for (int i=0;i&lt;n;i++)&#123; int key=scanner.nextInt(); int va=scanner.nextInt(); if (map.containsKey(key))&#123; map.put(key,map.get(key)+va); &#125;else &#123; map.put(key,va); &#125; &#125; for (Integer key : map.keySet()) &#123; System.out.println(key + " " + map.get(key)); &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F10%2F%E5%8F%96%E8%BF%91%E4%BC%BC%E5%80%BC%2F</url>
    <content type="text"><![CDATA[title: 取近似值date: 2020-4-10 10:04:25tags: leetCodecategories: 算法 取近似值题目描述写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。 输入描述:1输入一个正浮点数值 输出描述:1输出该数值的近似整数值 示例1 输入复制 15.5 输出复制 16 解：java一般的float转int直接是去掉小数点后的值，题目要求是四舍五入，所以要判断输入的值的正负号，给float值乘10然后加5然后转换int 123456789101112131415161718192021222324252627import java.util.*;/** * 测试 * * @author ygy ygy * @create 2020-04-03 20:28 **/public class Main &#123; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while(scanner.hasNext())&#123; float fl=scanner.nextFloat(); int re; if (fl&gt;0)&#123; re=(int)((fl*10)+5)/10; &#125;else if (fl&lt;0)&#123; re=(int)((fl*10)-5)/10; &#125;else&#123; re=0; &#125; System.out.println(re); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F09%2F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[进制转换题目描述写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ） 输入描述:1输入一个十六进制的数值字符串。 输出描述:1输出该数值的十进制字符串。 示例1 输入复制 10xA 输出复制 110 解：直接使用Integer的parseInt方法，第一个属性为String，第二个为进制数。题目主要输入时是按照，0xA的形式进行输入的。但是parseInt方法输入时是0A这种形式所以需要将x去掉。 12345678910111213141516171819202122import java.util.*;/** * 测试 * * @author ygy ygy * @create 2020-04-03 20:28 **/public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNext())&#123; String s=sc.nextLine(); String[] ss= s.split("x"); String re=ss[0]+ss[1]; System.out.println(Integer.parseInt(re,16)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F09%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E9%9A%94%2F</url>
    <content type="text"><![CDATA[title: 字符串分隔date: 2020-4-09 16:25:25tags: leetCodecategories: 算法 字符串分隔题目描述•连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 输入描述:1连续输入字符串(输入2次,每个字符串长度小于100) 输出描述:1输出到长度为8的新字符串数组 示例1 输入复制 12abc123456789 输出复制 123abc000001234567890000000 解：先对字符串添加到8个以上，然后使用substring方法，先返回0到8字符串，然后在截取8以后的字符串。 12345678910111213141516import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); while(sc.hasNext())&#123; String s = new String(sc.nextLine()); if(s.length()%8 !=0 ) s = s + "00000000"; while(s.length()&gt;=8)&#123; System.out.println(s.substring(0, 8)); s = s.substring(8); &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F09%2FTreeSet%E5%92%8CHashSet%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[title: 明明的随机数date: 2020-4-09 15:00:25tags: leetCodecategories: 算法 TreeSet和HashSet区别1.set的简述Set是一个不包含重复元素的 collection。 1.继承于Collection接口，具有增删查改的方法！ 2.AbstractCollection抽象类，实现了Collection接口，并实现了里面的一些方法，如isEmpty、contains等。 3.Set的两个实现类，HashSet和TreeSet HashSet实现本质其实就是HashMap，HashSet里面的元素是无序的。 TreeSet实现本质其实就是TreeSet,TreeSet里面的元素是有序的。 2.HashSet，TreeSet，LinkedHashSet HashSet使用哈希表实现的，元素是无序的。添加、删除操作时间复杂度都是O(1)。TreeSet内部结构是一个树结构(红黑树)，元素是有序的，添加、删除操作时间复杂度为O(log(n))，并且提供了first(), last(), headSet(), tailSet()等方法来处理有序集合。 LinkedHashSet是介于HashSet 和 TreeSet之间，内部是一个双向链表结构，所以它的插入是有序的，时间复杂度是O(1)。]]></content>
  </entry>
  <entry>
    <title><![CDATA[明明的随机数]]></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F09%2F%E6%98%8E%E6%98%8E%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[明明的随机数题目描述明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 Input Param n 输入随机数的个数 inputArray n个随机整数组成的数组 Return Value OutputArray 输出处理后的随机整数 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 样例输入解释： 样例有两组测试 第一组是3个数字，分别是：2，2，1。 第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。 输入描述:1输入多行，先输入随机整数的个数，再输入相应个数的整数 输出描述:1返回多行，处理后的结果 示例1 输入复制 12345678910111213141516322111102040326740208930040015 输出复制 12345678910111210152032406789300400 解：使用TreeSet，因为要去重并且要排序，所以使用TreeSet合适，TreeSet使用红黑树实现的 1.TreeSet是基于TreeMap实现的，支持自然排序和自定义排序，可以进行逆序输出； 2.TreeSet允许为空值； 3.TreeSet不是线程安全的，多线程环境下可以使用SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...))； TreeSet保存的对象有顺序性，也有不可重复性。顺序性有两种方法实现，一个是类实现Comparable接口；另一个是构造比较器，将比较器对象作为TreeSet的构造函数的参数传入。顺序性和不可重复性都是在compareTo()方法中实现的。 1234567891011121314151617181920212223242526272829import java.util.*;public class Main&#123; public static void reString(int[] str)&#123; Set&lt;Integer&gt; set=new TreeSet&lt;&gt;(); for (Integer s:str)&#123; set.add(s); &#125; for (Iterator&lt;Integer&gt; it=set.iterator();it.hasNext();)&#123; System.out.println(it.next()); &#125; &#125; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while (scanner.hasNext())&#123; int n=scanner.nextInt(); int[] num=new int[n]; for (int i=0;i&lt;n;i++)&#123; num[i]=scanner.nextInt(); &#125; reString(num); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证二叉搜索树]]></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F08%2F2020-4-08-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[计算字符个数题目描述写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 输入描述:1第一行输入一个有字母和数字以及空格组成的字符串，第二行输入一个字符。 输出描述:1输出输入字符串中含有该字符的个数。 示例1 输入复制 12ABCDEFA 输出复制 11 解：使用hashmap对出现的个数进行保存，直接将字符串使用split方法转变成syring【】，然后遍历数组进行比较，每次取出数值加一然后放回。 要 考虑字母的大小写，不然通过不了123456789101112131415161718192021222324public class ygymain &#123; public static int reString(String str,char s)&#123; str= str.toLowerCase(); HashMap&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); map.put(s,0); String[] s1= str.split(""); for (int i=0;i&lt;s1.length;i++)&#123; if (s1[i].charAt(0)==s)&#123; int num= map.get(s); num++; map.put(s,num); &#125; &#125; return map.get(s); &#125; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); String str=scanner.nextLine(); char s=scanner.next().charAt(0); System.out.println(reString(str,s)); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串最后一个单词的长度]]></title>
    <url>%2Fyueguoyu.github.io%2F2020%2F04%2F08%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[字符串最后一个单词的长度题目描述计算字符串最后一个单词的长度，单词以空格隔开。 输入描述:1一行字符串，非空，长度小于5000。 输出描述:1整数N，最后一个单词的长度。 示例1 输入复制 1hello world 输出复制 15 解：使用String中的split方法直接将字符串按照空格切分成String[],直接返回最后一个数组的字符串长度就行。 123456789101112131415import java.util.*;public class Main &#123;public static int reString(String str)&#123; String[] num=str.split(" "); return num[num.length-1].length();&#125;public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); while (scanner.hasNext())&#123; String str=scanner.nextLine(); System.out.println(reString(str)); &#125;&#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F12%2F09%2Fjs%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[js随笔js允许标签 1234567top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log('i=' + i + ', j=' + j); &#125; &#125; 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。]]></content>
  </entry>
  <entry>
    <title><![CDATA[摆动排序 II]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F15%2F%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F-II%2F</url>
    <content type="text"><![CDATA[摆动排序 II给定一个无序的数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... 的顺序。 示例 1: 12输入: nums = [1, 5, 1, 1, 6, 4]输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6] 示例 2: 12输入: nums = [1, 3, 2, 2, 3, 1]输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2] 说明:你可以假设所有输入都会得到有效的结果。 进阶:你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？ 解法： 将数组排序然后分成两个数组，从前面的数组末尾取一个，然后从后面的数组末尾取一个，以此类推，再将数组赋值回去。 1234567891011121314151617class Solution &#123; public void wiggleSort(int[] nums) &#123; int len=nums.length; if (nums!=null)&#123; int[] n=new int[len]; Arrays.sort(nums); int mid=(len+1)/2; int j=len; for (int i=0;i&lt;len;i++)&#123; n[i]=i%2==1?nums[--j]:nums[--mid]; &#125; for (int i=0;i&lt;len;i++)&#123; nums[i]=n[i]; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找重复数]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F14%2F%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[寻找重复数给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 12输入: [1,3,4,2,2]输出: 2 示例 2: 12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解法： set的使用 12345678910111213141516class Solution &#123; public int findDuplicate(int[] nums) &#123; if(nums==null||nums.length==0)&#123; return 0; &#125; Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); for (int num:nums)&#123; if (!set.contains(num)) &#123; set.add(num); &#125;else &#123; return num; &#125; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盛最多水的容器]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F14%2F%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解法： 暴力 1234567891011121314151617181920class Solution &#123; public int maxArea(int[] height) &#123; if (height==null||height.length&lt;=1)&#123; return 0; &#125; int len=height.length; int max=0; int sum=0; for (int i=0;i&lt;len;i++)&#123; for (int j=len-1;j&gt;i;j--) &#123; sum = (j - i) * (Math.min(height[i], height[j])); if (max &lt; sum) &#123; max = sum; &#125; &#125; &#125; return max; &#125;&#125; 优化i和j分别指数组两头向中间运动，当发现a【i】&lt;a[j]时i++，反之j– 123456789101112131415161718192021222324252627class Solution &#123; public int maxArea(int[] height) &#123; if (height==null||height.length&lt;=1)&#123; return 0; &#125; int len=height.length; int i=0,j=len-1; int max=0; while(i!=j)&#123; if (height[i]&lt;height[j]) &#123; int sum = (j - i) * height[i]; if (max &lt; sum) &#123; max = sum; &#125; i++; &#125;else &#123; int sum = (j - i) * height[j]; if (max &lt; sum) &#123; max = sum; &#125; j--; &#125; &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四数相加 II]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F14%2F%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-II%2F</url>
    <content type="text"><![CDATA[四数相加 II给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。 例如: 12345678910111213输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 解法： 开始想直接暴力解决，发现超时，看网上的代码发现，分开求和将ab的和存在map中，在map中查找ab和的相反数。 12345678910111213141516171819202122class Solution &#123; public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; if (A==null&amp;&amp;B==null&amp;&amp;C==null&amp;&amp;D==null)&#123; return 0; &#125; int re=0; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); for (int a:A)&#123; for (int b:B)&#123; map.put(a+b,map.getOrDefault(a+b,0)+1); &#125; &#125; for(int c:C)&#123; for (int d:D)&#123; int tmp=c+d; int key=-tmp; re+=map.getOrDefault(key,0); &#125; &#125; return re; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Perfect Squares]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F14%2FPerfect-Squares%2F</url>
    <content type="text"><![CDATA[Perfect Squares给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2: 123输入: n = 13输出: 2解释: 13 = 4 + 9. 解法： 因为求最小，并且问题可化解成许多小问题，所以使用动态规划，开始想使用贪心算法发现不对 如 12=9+3 结果等于4， 使用两个循环i从0到n，j为1，4，9，16.。。。，从小推大的,将每个都试一下取最小的。 a【i+j*j】=min{a[i+j**j],a[i]+1} 123456789101112131415161718class Solution &#123; public int numSquares(int n) &#123; if(n==0)&#123; return 0; &#125; int [] a=new int[n+1]; for (int i=0;i&lt;n+1;i++)&#123; a[i]=Integer.MAX_VALUE; &#125; a[0]=0; for (int i=0;i&lt;=n;i++)&#123; for (int j=1;j*j+i&lt;=n;j++)&#123; a[j*j+i]=Math.min(a[j*j+i],a[i]+1); &#125; &#125; return a[n]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘积最大子序列]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F13%2F%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[乘积最大子序列给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。示例 2: 输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。解法：求乘积最大的连续子序列，因为是连续的所以最大数要莫是maxn【i】，要不是n【i】每次记住最大值和最小值注意 考虑负负得正1.max=max{max{premaxn【i】，n【i】}//n【i】为正，minn【i】//n【i】为负}2.min=min{min{premaxn【i】，n【i】}//n【i】为负，min*n【i】//n【i】为正}3.最后返回max12345678910111213141516171819class Solution &#123; public int maxProduct(int[] nums) &#123; if (nums==null||nums.length==0)&#123; return 0; &#125; int max=nums[0]; int min=nums[0]; int remax=max; for (int i=1;i&lt;nums.length;i++)&#123; int tmp=max; max=Math.max(Math.max(nums[i],nums[i]*tmp),min*nums[i]); min=Math.min(Math.min(nums[i],tmp*nums[i]),min*nums[i]); if (max&gt;remax)&#123; remax=max; &#125; &#125; return remax; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock with Cooldown]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F13%2FBest%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock with Cooldown给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。示例: 输入: [1,2,3,0,2]输出: 3解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]解法：因为结果和前面的值息息相关所以用动态规划，1.因为有三种状态使用buy【i】表示在i时买入，sell【i】表示卖出和冷冻期2.buy【i】=max{buy【i-1】，sell【i-2】-n【i】}当结束状态为买入时的总利润3.sell【i】=max{sell【i-1】，buy【i-1】+n【i】}当结束状态为冷却或卖出时的总利润123456789101112131415161718class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices==null||prices.length==0)&#123; return 0; &#125; int len=prices.length; int bug[]=new int[len]; int sell[]=new int[len]; bug[0]=-prices[0]; sell[0]=0; for (int i=1;i&lt;len;i++)&#123; sell[i]=Math.max(sell[i-1],bug[i-1]+prices[i]); bug[i]=Math.max(bug[i-1],(i&gt;1?sell[i-2]:0)-prices[i]); &#125; return sell[len-1]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长连续序列]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F12%2F%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[最长连续序列给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例: 123输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 解法：将数组放进set里面，然后找出第一个数，pre表示这个树的前一个，next表示后一个，最后返回next-pre+1就是最长连续序列。 123456789101112131415161718192021class Solution &#123; public int longestConsecutive(int[] nums) &#123; if (nums==null||nums.length==0)&#123; return 0; &#125; int res=0; Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); for (int num:nums)&#123; set.add(num); &#125; for (int num:nums)&#123; if (set.remove(num))&#123; int pre=num-1,next=num+1; while (set.remove(pre))&#123;--pre;&#125; while(set.remove(next))&#123;++next;&#125; res=Math.max(res,next-pre-1); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个缺失的正数]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F12%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[#第一个缺失的正数 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1: 12输入: [1,2,0]输出: 3 示例 2: 12输入: [3,4,-1,1]输出: 2 示例 3: 12输入: [7,8,9,11,12]输出: 1 说明: 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 解法： 将数组放进set里面，然后在从1开始找 12345678910111213141516class Solution &#123; public int firstMissingPositive(int[] nums) &#123; if (nums==null)&#123; return 0; &#125; Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); for (int num:nums)&#123; set.add(num); &#125; int i=1; while(set.contains(i))&#123; i++; &#125; return i; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最接近的三数之和]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F06%2F%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解法： 1求三个数的和sum，使sum与target相差最小。这题实际上跟前面坐的2Sum，以及3Sum相差不是很大，大体的想法是先排序，然后外层的for循环遍历从小到大的数，然后从剩下的数中取三数之和，然后把最小的一步步保存下来，最终将最小的返回就行了。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; if (nums==null)&#123; return 0; &#125; int min=Integer.MAX_VALUE; int re=0; int sum=0; int tmp=0; int sta,end; Arrays.sort(nums); for (int i=0;i&lt;nums.length-2;i++)&#123; sta=i+1; end=nums.length-1; while(sta&lt;end) &#123; sum = nums[i] + nums[sta] + nums[end]; if ((tmp = Math.abs(sum - target)) &lt; min) &#123; min = tmp; re = sum; &#125; if (sum &gt; target) &#123; end--; &#125; else if (sum &lt; target) &#123; sta++; &#125; else &#123; return sum; &#125; &#125; &#125; return re; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring事务]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F06%2Fspring%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[spring事务传播行为： REQUIRED ，这个是默认的属性 Support a current transaction, create a new one if none exists. 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 被设置成这个级别时，会为每一个被调用的方法创建一个逻辑事务域。如果前面的方法已经创建了事务，那么后面的方法支持当前的事务，如果当前没有事务会重新建立事务。 MANDATORY,表示方法必须运行在一个事务中，如果当前事务不存在，就抛出异常。 NESTED,如果当前事务存在，则方法应该运行在一个嵌套事务中。 NEVER,不能运行在一个事务中，否则抛出异常。 NOT_SUPPORTED,表示方法不能运行在一个事务中，如果存在事务则该方法被挂起。 Supported，表示目前方法不需要运行在一个事务中，但如果右一个事务已经存在，该方法也可以运行在这个事务中。 REQUIRED,表示当前事务必须在一个事务中，如果当前存在事务，那么该方法运行在这个事务中，否则，将创建一个新的事务。 REQUIRES-NEW,表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起。 隔离级别： 在操作数据时，可能出现脏读，不可重复读，幻读。 标准的sql语句有四种隔离级别，而spring提供5种。 ISOLATION-DEFAULL 使用后端数据库默认的隔离级别 ISOLATION-UNCOMMITTRD 允许读取未提交的数据，可能出现脏读 ISOLATION-COMMITTED 读取提交的数据，避免脏读，会出现不可重复读 ISOLATION-REPEATABLE-READ 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读 SERIALIZABLE（串行化） 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。 只读： 事务超时：]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 类构造函数 & 析构函数]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F09%2F05%2FC%2B%2B%20%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%20%26%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C++ 类构造函数 &amp; 析构函数类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。 构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。 构造函数能抛出异常。 类的析构函数类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。 析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在排序数组中查找元素的第一个和最后一个位置]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F29%2F%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在排序数组中查找元素的第一个和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 解法： 题目要求时间复杂度为O(log n) 级别，所以采用二分法思想，并且给的数组是排好序的，先找到target这个数然后向两边扩展（求最大回文子串思想）求出最小和最大位置。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] re=new int[2]; re[0]=-1; re[1]=-1; if(nums.length==0||nums==null)&#123; return re; &#125; int left=0,right=nums.length-1; while (left&lt;=right) &#123; int mid = left + (right - left) / 2; if (nums[mid]&lt;target)&#123; left=mid+1; &#125; if (nums[mid]&gt;target)&#123; right=mid-1; &#125; if (nums[mid]==target)&#123; int min = mid; for (int i=mid;i&gt;=left;i--)&#123; if (nums[i]==target) &#123; min=Math.min(min,i); &#125; &#125; re[0]=min; int max=mid; for (int i=mid;i&lt;=right;i++)&#123; if (nums[i]==target)&#123; max=Math.max(max,i); &#125; &#125; re[1]=max; return re; &#125; &#125; return re; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找峰值]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F23%2F%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[寻找峰值峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1: 输入: nums = [1,2,3,1] 输出: 2 解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2: 输入: nums = [1,2,1,3,5,6,4] 输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN) 时间复杂度的。 解法： 直接查找的话时间复杂度为o（n），而题目要求是O(logN)，采用二分法的思想判断。 class Solution { public int findPeakElement(int[] nums) { if (nums==null){ return -1; } int left=0,right=nums.length-1; if (nums.length==1){ return 0; } if (nums.length==2){ if (nums[0]&gt;nums[1]){ return 0; }else { return 1; } } while(left&lt;right){ int mid=left+(right-left)/2; if (mid==0){ if (nums[mid]&gt;nums[mid+1]){ return 0; } return 1; } if (nums[mid]&gt;nums[mid-1]&amp;&amp;nums[mid]&gt;nums[mid+1]){ return mid; }else { if (nums[mid]&lt;nums[mid-1]){ right=mid-1; } else { left=mid+1; } } } return left; } }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文子串]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F21%2F%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot;也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 解法一： 从一个点向两边扩展，当两边的数值一样，那就是回文子串。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String longestPalindrome(String s) &#123; if(s==null)&#123; return null; &#125; int len=s.length(); int sta=0; int max=0; for (int i=0;i&lt;s.length();i++)&#123; //奇数 int low=i-1,height=i+1; while(low&gt;=0&amp;&amp;height&lt;len&amp;&amp;s.charAt(low)==s.charAt(height))&#123; low--; height++; &#125; if (height-low-1&gt;max)&#123; max=height-low-1; sta=low+1; &#125; //偶数 low=i-1; height=i; while (low&gt;=0&amp;&amp;height&lt;len&amp;&amp;s.charAt(low)==s.charAt(height))&#123; low--; height++; &#125; if (height-low-1&gt;max)&#123; max=height-low-1; sta=low+1; &#125; &#125; return s.substring(sta,sta+max); &#125;&#125; 解法二：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子集]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F18%2F%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解法： 先给一个空集【】，当数为1时将1加入变为，【】，【1】，再将2加入变为【】【1】，【2】，【1，2】，将3加入【】，【1】，【2】，【1，2】【3】【1，3】【2，3】【1，2，3】. 12345678910111213141516public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; if (nums == null) &#123; return null; &#125; List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); lists.add(new ArrayList&lt;&gt;()); for (int num:nums) &#123; int size = lists.size(); for (int j = 0; j &lt; size; j++) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(lists.get(j)); list.add(num); lists.add(list); &#125; &#125; return lists; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis分布式锁]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F16%2Fredis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[redis分布式锁乐观锁 redis可以使用watch命令来代替对数据进行加锁，因为watch只会在数据被其他客户端抢先修改的情况下通知执行了这个命令的客户端，而不会阻止其他客户端对数据进行修改，所以这个命令称为乐观锁。 使用redis构建锁的原因 1.为了对redis存储的数据进行排他性访问，客户端需要访问一各锁，这个锁必须定义在一个让所有客户端都能看见的范围内，即就放在redis本身内。 2.redis提供的setnx命令具有基本的加锁功能，但不完整，所以需要我们手动构建分布锁。 锁和事务比较 watch，multi和exec组成的事务，程序在尝试完成一个事务时，可能会因为事务执行失败而反复地进行重试。 使用锁后重试的次数减少。 redis构建锁 123456789101112131415import timeimport uuidimport redis# 获取锁def acquire_lock(conn,lockname,aquire_time=10): # 128位随机标识符 identifier=str(uuid.uuid4()) end=time.time()+aquire_time while time.time()&lt;end: # 尝试获取锁 if conn.setnx('lock:'+lockname,identifier): return identifier time.sleep(.001) return False 1234567891011121314151617181920# 释放锁def release_lock(conn,lockname,identifier): pipe=conn.pipeline(True) lockname='lock:'+lockname while True: try: # 检查是否仍然持有锁 pipe.watch(lockname) if pipe.get(lockname)==identifier: # 释放锁 pipe.multi() pipe.delete(lockname) pipe.execute() return True pipe.unwatch() break # 有其他客户端修改了锁，重试 except redis.exceptions.WatchError: pass return False 12345678910111213141516# 带有超时限制特性的锁def acquire_lock_with_time(conn,lockname,acquire_time=10,lock_timeout=10): identifier=str(uuid.uuid4()) lockname='lock:'+lockname # 确保是整数 lock_timeout=int(math.ceil(lock_timeout)) end=time.time()+lock_timeout while time.time()&lt;end: if conn.setnx(lockname,identifier): # 设置过期时间 conn.expire(lockname,lock_timeout) return identifier elif not conn.ttl(lockname): conn.expire(lockname,lock_timeout) time.sleep(.001) return False 总结： 使用锁可以减少重试的次数，降低延迟的时间，提升性能并将加锁的粒度调整至合适的大小。 dogpile效应执行事务所需要的时间越长，就会有越多的待处理的事务互相重叠，这种重叠增加了执行单个事务的时间，并使得哪些带有时间限制的事务失败的几率大幅上升，最终导致所有的事务执行失败的几率和进行重试的几率都大幅的上升。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F15%2F%E6%97%A0%E6%9D%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[无权最短路径给一个有向无权图，求最短路径。将起点的dis设为0其他的为Integer的最大数，使用广度优先搜索，使用一个队列将dis为0 的节点入队，当队列不为空时，使队列的第一个节点出队，判断其子节点（相邻的节点）当其没有被遍历过，更改其dis的值，并保存指向它的节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package t813;import java.util.*;public class Vertex &#123; static List&lt;myVertex&gt; myVertexList = new ArrayList&lt;&gt;(); static class myVertex &#123; private boolean known; private String name; private int dist; private myVertex path; private List&lt;myVertex&gt; list = new ArrayList&lt;&gt;(); myVertex(String name, int dist) &#123; this.name = name; this.dist = dist; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setDist(int dist) &#123; this.dist = dist; &#125; public void setList(List&lt;myVertex&gt; list) &#123; this.list = list; &#125; public void setPath(myVertex path) &#123; this.path = path; &#125; public String getName() &#123; return name; &#125; public int getDist() &#123; return dist; &#125; public List&lt;myVertex&gt; getList() &#123; return list; &#125; public myVertex getPath() &#123; return path; &#125; &#125; public static void unweighted(myVertex s) &#123; Queue&lt;myVertex&gt; queue = new LinkedList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); s.dist = 0; queue.add(s); while (!queue.isEmpty()) &#123; myVertex m = queue.poll(); for (myVertex w : m.getList()) &#123; if (w.dist == Integer.MAX_VALUE) &#123; w.dist = m.dist + 1; w.path = m; queue.add(w); &#125; &#125; &#125; &#125; public static void print(myVertex v) &#123; if (v.path != null) &#123; print(v.path); System.out.println("to"); &#125; System.out.println(v.name); &#125; public static void main(String[] args) &#123; myVertex v1 = new myVertex("v1", Integer.MAX_VALUE); myVertex v2 = new myVertex("v2", Integer.MAX_VALUE); myVertex v3 = new myVertex("v3", 0); myVertex v4 = new myVertex("v4", Integer.MAX_VALUE); myVertex v5 = new myVertex("v5", Integer.MAX_VALUE); myVertex v6 = new myVertex("v6", Integer.MAX_VALUE); myVertex v7 = new myVertex("v7", Integer.MAX_VALUE); v1.list.add(v2); v1.list.add(v4); v2.list.add(v4); v2.list.add(v5); v3.list.add(v1); v3.list.add(v6); v4.list.add(v3); v4.list.add(v5); v4.list.add(v6); v4.list.add(v7); v5.list.add(v7); v7.list.add(v6); unweighted(v3); print(v5); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F14%2F8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[8大排序算法时间复杂度 1234567891011121314151617181920/** * a * 插入排序 * * @param a */ public static void crsort(int[] a) &#123; if (a == null || a.length == 0) &#123; return; &#125; for (int i = 0; i &lt; a.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (a[i] &lt; a[j]) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; &#125; &#125; &#125; &#125; 1234567891011121314151617181920212223/** * 冒泡排序 * * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 * * 针对所有的元素重复以上的步骤，除了最后一个。 * * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 * * @param a */ public static void bubbleSort(int[] a) &#123; if (a == null || a.length == 0) &#123; return; &#125; for (int i = 0; i &lt; a.length; i++) &#123; for (int j = 0; j &lt; a.length - i - 1; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; int tmp = a[j + 1]; a[j + 1] = a[j]; a[j] = tmp; &#125; &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334/** * 快排 * * @param a * @param sta * @param end */ public static void sort(int[] a, int sta, int end) &#123; if (a.length == 0 || a == null) &#123; return; &#125; if (sta &lt; end) &#123; int l = sta; int r = end; int tmp = a[l]; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; a[r] &gt; tmp) &#123; r--; &#125; if (l &lt; r) &#123; a[l++] = a[r]; &#125; while (l &lt; r) &#123; l++; &#125; if (l &lt; r) &#123; a[r--] = a[l]; &#125; &#125; a[l] = tmp; sort(a, sta, l - 1); sort(a, l + 1, end); &#125; &#125; 1234567891011121314151617181920212223/** * 选择排序 * 每次从未遍历的数组中找到最小的和前面的数交换 * 在未排序序列中找到最小元素，存放到排序序列的起始位置 * * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 * * 以此类推，直到所有元素均排序完毕。 * * @param a */ public static void xzsort(int[] a) &#123; if (a.length == 0 || a == null) &#123; return; &#125; for (int i = 0; i &lt; a.length; i++) &#123; for (int j = a.length - 1; j &gt; i; j--) &#123; if (a[j] &lt; a[i]) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; &#125; &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334/** * 堆排序 * * @param a */ public static void heapsort(int[] a) &#123; for (int i = a.length / 2 - 1; i &gt;= 0; i--) &#123; hsort(a, i, a.length); &#125; for (int i = a.length - 1; i &gt; 0; i--) &#123; int tmp = a[0]; a[0] = a[i]; a[i] = tmp; hsort(a, 0, i); &#125; &#125; public static void hsort(int[] a, int i, int n) &#123; int left = (i &lt;&lt; 1) + 1; int right = left + 1; int max = i; if (left &lt; n &amp;&amp; a[left] &gt; a[i]) &#123; max = left; &#125; if (right &lt; n &amp;&amp; a[right] &gt; a[max]) &#123; max = right; &#125; if (i != max) &#123; int tmp = a[i]; a[i] = a[max]; a[max] = tmp; hsort(a, max, n); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 归并排序 * 将两个或多个已经排序的数组整合成一个数组 * 时间复杂度： 最坏情况 O（NlogN） * @param a * @param left * @param right */ public static void mergesort(int[] a, int left, int right) &#123; if (a == null || a.length == 0) &#123; return; &#125; int mid = left + (right - left) / 2; if (left &lt; right) &#123; mergesort(a, left, mid); mergesort(a, mid + 1, right); merge(a, left, mid, right); &#125; &#125;public static void merge(int[] a, int left, int mid, int right) &#123; int i = left; int j = mid + 1; int k = 0; int[] temp = new int[right - left + 1]; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (a[i] &lt; a[j]) &#123; temp[k++] = a[i++]; &#125; else &#123; temp[k++] = a[j++]; &#125; &#125; while (i &lt;= mid) &#123; temp[k++] = a[i++]; &#125; while (j &lt;= right) &#123; temp[k++] = a[j++]; &#125; for (int n = 0; n &lt; temp.length; n++) &#123; a[n + left] = temp[n]; &#125; &#125; 1234567891011121314151617181920/** * 希尔排序 * @param a */ public static void shellSort(int[] a)&#123; if (a==null||a.length==0)&#123; return; &#125; for (int gap=a.length/2;gap&gt;0;gap/=2)&#123; for (int i=gap;i&lt;a.length;i++)&#123; for (int j=i;j&gt;=gap;j-=gap) &#123; if (a[i] &lt; a[j - gap]) &#123; int temp = a[i]; a[i] = a[j - gap]; a[j - gap] = temp; &#125; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数相加]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F13%2F%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[两数相加给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解法： 直接算，使用carry来存储两数相加的进位数。 12345678910111213141516171819public ListNode addTwoNumbers1(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F12%2F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%2F</url>
    <content type="text"><![CDATA[title: 布隆过滤器，缓存穿透，缓存击穿，缓存雪崩date: 2018-08-12 15：40：12tags: 缓存categories: 缓存 布隆过滤器，缓存穿透，缓存击穿，缓存雪崩解决问题：如何查看一个东西是否在有大量数据的池子里面。 原理布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k 以上图为例，具体的操作流程：假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。 布隆过滤器添加元素 将要添加的元素给k个哈希函数 得到对应于位数组上的k个位置 将这k个位置设为1 布隆过滤器查询元素 将要查询的元素给k个哈希函数 得到对应于位数组上的k个位置 如果k个位置有一个为0，则肯定不在集合中 如果k个位置全部为1，则可能在集合中 引用（https://www.cnblogs.com/cpselvis/p/6265825.html） 缓存穿透缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 解决方案有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟 缓存雪崩缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。 解决方案缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 缓存击穿对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。 缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 解决方案永不过期。这里的“永远不过期”包含两层意思：(1) 从redis上看，确实没有设置过期时间。(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，若发现要过期或已经过期时，则通过一个后台异步线程进行缓存的构建。 从实战看，这种方法对性能非常友好，唯一不足的是构建缓存时，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。 使用互斥锁(mutex key)业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。12345678910111213141516public String get(key) &#123; String value = redis.get(key); if (value == null) &#123; //代表缓存值过期 //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db if (redis.setnx(key_mutex, 1, 3 * 60) == 1) &#123; //代表设置成功 value = db.get(key); redis.set(key, value, expire_secs); redis.del(key_mutex); &#125; else &#123; //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可 sleep(50); get(key); //重试 &#125; &#125; else &#123; return value; &#125; &#125; “提前”使用互斥锁(mutex key)：在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。伪代码如下： 12345678910111213141516171819202122232425262728v = memcache.get(key); if (v == null) &#123; if (memcache.add(key_mutex, 3 * 60 * 1000) == true) &#123; value = db.get(key); memcache.set(key, value); memcache.delete(key_mutex); &#125; else &#123; sleep(50); retry(); &#125; &#125; else &#123; if (v.timeout &lt;= now()) &#123; if (memcache.add(key_mutex, 3 * 60 * 1000) == true) &#123; // extend the timeout for other threads v.timeout += 3 * 60 * 1000; memcache.set(key, v, KEY_TIMEOUT * 2); // load the latest value from db v = db.get(key); v.timeout = KEY_TIMEOUT; memcache.set(key, value, KEY_TIMEOUT * 2); memcache.delete(key_mutex); &#125; else &#123; sleep(50); retry(); &#125; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树中第K小的元素]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F11%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[二叉搜索树中第K小的元素给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1: 1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 1 示例 2: 123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1输出: 3 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？ 解法： 因为给的是二叉搜索树，所以中序遍历是一个有序的，所以使用栈每次弹出一个数k减少1直到k为0就是第k小的值. 123456789101112131415161718192021public int kthSmallest(TreeNode root, int k) &#123; if (root==null||k==0)&#123; return -1; &#125; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); while(root!=null||!stack.empty())&#123; while(root!=null)&#123; stack.push(root); root=root.left; &#125; if (k&gt;0&amp;&amp;!stack.empty())&#123; root=stack.pop(); k--; if (k==0)&#123; return root.val; &#125; root=root.right; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长子串]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F10%2F%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[无重复字符的最长子串给定一个字符串，找出不含有重复字符的最长子串的长度。 示例： 给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。 给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。 给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 解法： 给一个头指针用来指向最长子串的开始的位置，lang为子串字符长度MAX为最大子串长度，使用map来记录字符串中各个字符对应的下标，key为字符而value为字符对应的下标数。从头指针开始遍历，如果字符没有在map中说明没有重复，则lang=i-head+1；每次更新max，当map中有该字符时将改变head的位置，算出子串的长度。每次都将字符pust到map中。 123456789101112131415161718192021222324public static int lengthOfLongestSubstring(String s) &#123; if (s==null||s.equals(""))&#123; return 0; &#125; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); int max=0; int lang=0; int head=0; for (int i=0;i&lt;s.length();i++)&#123; if (!map.containsKey(s.charAt(i)))&#123; lang=i-head+1; if (max&lt;lang)&#123; max=lang; &#125; &#125;else &#123; head=Math.max(head,map.get(s.charAt(i))+1); if (max&lt;i-head+1)&#123; max=i-head+1; &#125; &#125; map.put(s.charAt(i),i); &#125; return max; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字谜分组]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F10%2F%E5%AD%97%E8%B0%9C%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[字谜分组给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 解法： 因为字母异位词指字母相同，所以每个String排序后会出现相同的String，再使用map key唯一的特性将数组分开。 1234567891011121314151617public static List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if(strs==null)&#123; return null; &#125; Map&lt;String,List&lt;String&gt;&gt; map=new HashMap&lt;&gt;(); for (String s:strs)&#123; char[] c= s.toCharArray(); Arrays.sort(c); String key=String.valueOf(c); if (!map.containsKey(key))&#123; map.put(key,new ArrayList&lt;&gt;()); &#125; map.get(key).add(s); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三数之和]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F09%2F%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解法： 先将数组排序，然后从头遍历数组，在除了当前数的其他数组中设置left=i+1，right=nums.length-1，让这俩指针向中间运动，如果三数之和为0，则保存。 这题不跳过重复的显示超时。 1234567891011121314151617181920212223242526272829303132333435363738public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if (nums == null||nums.length&lt;3) &#123; return list; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length-2; i++) &#123; int left = i + 1; int right = nums.length - 1; if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123;continue;&#125;; if (nums[i]+nums[i+1]+nums[i+2]&gt;0)break; if (nums[right]+nums[right-1]+nums[i]&lt;0)continue; while (left &lt; right) &#123; List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; list1.add(nums[i]); list1.add(nums[left]); list1.add(nums[right]); if (!list.contains(list1)) &#123; list.add(list1); &#125; left++; right--; &#125;else if (sum &lt; 0) &#123; left++; //跳过重复的 while(left&lt;right&amp;&amp;nums[left]==nums[left-1])&#123;left++;&#125; &#125; else &#123; right--; //跳过重复的 while(left&lt;right&amp;&amp;nums[right]==nums[right+1])&#123;right--;&#125; &#125; &#125; &#125; return list; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[罗马数字转整数]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F07%2F%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[罗马数字转整数罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 12输入: &quot;III&quot;输出: 3 示例 2: 12输入: &quot;IV&quot;输出: 4 示例 3: 12输入: &quot;IX&quot;输出: 9 示例 4: 123输入: &quot;LVIII&quot;输出: 58解释: C = 100, L = 50, XXX = 30, III = 3. 示例 5: 123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解法 当前位置的数大于后面的数则相加，当前位置的数小于后面的数则相见。可用map或数组将字母和数一一对应。 1234567891011121314151617181920212223public static int romanToInt(String s) &#123; if (s==null)&#123; return 0; &#125; int tagVal[]=new int[256]; tagVal['I'] = 1; tagVal['V'] = 5; tagVal['X'] = 10; tagVal['C'] = 100; tagVal['M'] = 1000; tagVal['L'] = 50; tagVal['D'] = 500; int val = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if(i+1 &gt;= s.length() || tagVal[s.charAt(i+1)] &lt;= tagVal[s.charAt(i)]) &#123; val += tagVal[s.charAt(i)]; &#125; else &#123; val -= tagVal[s.charAt(i)]; &#125; &#125; return val;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一致性hash算法]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F04%2F%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一致性hash算法原文：http://afghl.github.io/2016/07/04/consistent-hashing.html 一致性哈希（Consistent Hashing）原理 看一些分布式相关的技术文章或书籍时，经常看到一个词，一致性哈希。对于这个技术一直似懂非懂。今天花了半天的时间好好研究了它的原理和实现，发现一点都不复杂。于是写篇文章分享一下。 下面，我们就从基本的Hash算法说起。 负载均衡与Hash算法分布式系统中（如：web存储），当服务增长到一定规模时，惯常的做法是集群化，引入负载均衡，这样做的好处是：1. 高可用。2. 解耦。从外部看，透明化了集群的内部细节（外部都通过负载均衡服务器通信，然后由负载均衡服务器分发请求）。 假设一个简单的场景：有4个cache服务器（后简称cache）组成的集群，当一个对象object传入集群时，这个对象应该存储在哪一个cache里呢？一种简单的方法是使用映射公式： 1Hash(object) % 4 这个算法就可以保证任何object都会尽可能随机落在其中一个cache中。一切运行正常。 然后考虑以下情况： 由于流量增大，需要增加一台cache，共5个cache。这时，映射公式就变成Hash(object) % 5。 有一个cache服务器down掉，变成3个cache。这时，映射公式就变成Hash(object) % 3。 可见，无论新增还是减少节点，都会改变映射公式，而由于映射公式改变，几乎所有的object都会被映射到新的cache中，这意味着一时间所有的缓存全部失效。 大量的数据请求落在app层甚至是db层上，这对服务器的影响当然是灾难性的。 这时，我们就需要新的算法。 一致性Hash一致性hash的出现就是为了解决这个问题：当节点数量改变时，能够使失效的缓存数量尽可能少。 一致性Hash的基本思想就是分两步走： 把object求hash（这一步和之前相同）； 把cache也求hash，然后把object和cache的hash值放入一个hash空间，通过一定的规则决定每个object落在哪一个cache中。 下面，会逐步说明它的实现。 成环考虑通常的Hash算法都是将value映射到一个32位的key值，也即是0 ~ 2 ^ 32 - 1次方的数值空间；我们可以将这个空间想象成一个首（0）尾（2 ^ 32 - 1）相接的圆环，如下图所示。 .jpg) 将object映射到环上比如有4个需要存储的object，先求出它们的hash值，根据hash值映射到环上。如图： .JPG) 将cache映射到环上假设有三台cache服务器：cache A，cache B，cache C。用同样的方法求出hash值（可根据机器的IP或名字作为key求hash，只要保证hash值足够分散），映射到同一个环上。如图： .jpeg) 将object按照规则配对cache这里的规则很简单：让object在环上顺时针转动，遇到的第一个cache即为对应的cache服务器。 根据上面的方法，对object1将被存储到cache A上；object2和object3对应到cache C；object4对应到cache B。 解决问题新的一致性hash算法成功解决了cache服务器增减时key的失效问题。现在，无论增减cache，只有部分key失效。 考虑增加新的缓存服务器的情况： .svg) 如图，新增了cache D节点，假设cache D在环上落在C和A之间，那么失效的只有部分落在cache A的key（现在落在cache D了）；也就是部分的红色圆弧，变成橙色圆弧（D）。 而cache B和cache C的key都没有失效。 可见，在新增节点时，这已经是最少失效了。 在移除节点时，情况也是和新增节点类似的。 虚拟节点hash算法的一个考量指标是平衡性。在本例中，我们希望每一个object落在任意一个cache的机会都尽可能接近。 从图上很容易直观的看到，对于一个object来说，它落在环上的任何位置的概率都是一样的，那么落在一个cache的概率就和圆弧的长度成正比。于是，我们希望每个cache所占的圆弧长度更接近。 其实，理论上，只要cache足够多，每个cache在圆环上就会足够分散。但是在真实场景里，cache服务器只会有很少，所以，引入了“虚拟节点”（virtual node）的概念： 以仅部署cache A和cache C的情况为例，引入虚拟节点，cache A1, cache A2代表了cache A；cache C1，cache C2代表了cache C。 .jpg) 此时，对象到“虚拟节点”的映射关系为： objec1-&gt;cache A2；objec2-&gt;cache A1；objec3-&gt;cache C1；objec4-&gt;cache C2； 因此对象object1和object2都被映射到了cache A上，而object3和object4映射到了cache C上；平衡性有了很大提高。 虚拟节点技术实则是做了两次matching，如图： .jpg)]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F08%2F04%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[消息队列概述： 消息队列是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。 消息队列最大的特点是将同步操作转化成异步操作，将多服务共同操作转为职责单一的单服务操作，做到了服务间的解耦。 特点： 1.异步性，将同步操作转化为异步操作 2.松耦合，消息队列减少了服务之间的耦合，服务之间通过消息队列通信。 3.可靠性 消息队列一般会把接收到的消息存储到本地硬盘上（当消息被处理完之后，存储信息根据不同的消息队列实现，有可能将其删除），这样即使应用挂掉或者消息队列本身挂掉，消息也能够重新加载。 转载：（https://blog.csdn.net/he90227/article/details/50800646） 消息队列的使用场景消息队列应场景，异步处理，应用解耦，流量削峰，消息通讯。 2.1 异步处理场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1. 串行的方式；2. 并行方式。 （1）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。（架构 KKQ：466097527，欢迎加入） （2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。 假设三个业务节点每个使用 50 毫秒钟，不考虑网络等其他开销，则串行方式的时间是 150 毫秒，并行的时间可能是 100 毫秒。 因为 CPU 在单位时间内处理的请求数是一定的，假设 CPU1 秒内吞吐量是 100 次。则串行方式 1 秒内 CPU 可处理的请求量是 7 次（1000/150）。并行方式处理的请求量是 10 次（1000/100）。 小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？ 引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下： 按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是 50 毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是 50 毫秒。因此架构改变后，系统的吞吐量提高到每秒 20 QPS。比串行提高了 3 倍，比并行提高了两倍。 2.2 应用解耦场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：（架构 KKQ：466097527，欢迎加入） 传统模式的缺点： 1） 假如库存系统无法访问，则订单减库存将失败，从而导致订单失败； 2） 订单系统与库存系统耦合； 如何解决以上问题呢？引入应用消息队列后的方案，如下图： 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。 库存系统：订阅下单的消息，采用拉 / 推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。 假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。 2.3 流量削锋流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。 应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。 可以控制活动的人数； 可以缓解短时间内高流量压垮应用； 用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面； 秒杀业务根据消息队列中的请求信息，再做后续处理。 2.4 日志处理日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。架构简化如下：（架构 KKQ：466097527，欢迎加入） 日志采集客户端，负责日志数据采集，定时写受写入 Kafka 队列； Kafka 消息队列，负责日志数据的接收，存储和转发； 日志处理应用：订阅并消费 kafka 队列中的日志数据； 以下是新浪 kafka 日志处理应用案例： 转自（http://cloud.51cto.com/art/201507/484338.htm） (1)Kafka：接收用户日志的消息队列。 (2)Logstash：做日志解析，统一成 JSON 输出给 Elasticsearch。 (3)Elasticsearch：实时日志分析服务的核心技术，一个 schemaless，实时的数据存储服务，通过 index 组织数据，兼具强大的搜索和统计功能。 (4)Kibana：基于 Elasticsearch 的数据可视化组件，超强的数据可视化能力是众多公司选择 ELK stack 的重要原因。 2.5 消息通讯消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 点对点通讯： 客户端 A 和客户端 B 使用同一队列，进行消息通讯。 聊天室通讯： 客户端 A，客户端 B，客户端 N 订阅同一主题，进行消息发布和接收。实现类似聊天室效果。 以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis事务]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F31%2Fredis%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[redis事务概述redis也支持事务，和关系型数据库不同的是，简单的redis事务：在redis中以特殊命令MULTI开始，然后传入多个命令，最后以EXEC作为结束，在EXEC之前命令不会执行。 流水线： 概念：因为直到客户端发送EXEC命令时，redis的命令才会执行，所以右的客户端才会一次性将MULTI+命令+EXEC全部发送给redis，然后等待直到接收所有命令的回复为止，这种一次性发送多个命令，然后再等待所有回复出现，的做法通常被称为“流水线”。 延迟执行事务有助于提升性能。 用到的命令MULTI:发送命令开始的命令。 EXEC:命令结束的特殊命令。 WATCH: 监视一个或多个键，发现数据是否改变。 UNWATCH:取消 WATCH 命令对所有 key 的监视。 如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了 的话，那么就不需要再执行 UNWATCH 了。 因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。 DISCARD: 可用在MULTI命令执行之前对连接进行重置，还可以在MULTI 开始一个新的事务，将多个命令放在事务队列中，仍可以调用DISCARD命令来取消WATCH命令并清除所有的已入队的命令。 redis的加锁redis没有实现典型的加锁功能，在访问以写入为目的的数据的时候，关系型数据库会对被访问的数据进行加锁，直到事务被提交或回滚为止。如果其他客户端对加锁的数据进行写入，那么就会被阻塞，直到第一个事务执行完成，这种称为悲观锁。 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 而redis为了减少客户端的等待时间，并不会在执行WATCH命令时对数据进行加锁，相反的，redis只有在数据已经被其他客户端更改的情况下，通知执行了WATCH命令的客户端，这种称为乐观锁。 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉明距离]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F30%2F%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[汉明距离 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 231. 示例: 12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 解法： 先求两个数的异或运算得到的值的一的个数就是韩明距离。 12345678910111213public static int hammingDistance(int x, int y) &#123; if (x==0&amp;&amp;y==0)&#123; return 0; &#125; //x与y进行异或 int a=x^y; int re=0; while(a!=0)&#123; a=a&amp;(a-1); re++; &#125; return re; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位1的个数]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F30%2F%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[位1的个数编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 示例 : 123输入: 11输出: 3解释: 整数 11 的二进制表示为 00000000000000000000000000001011 示例 2: 123输入: 128输出: 1解释: 整数 128 的二进制表示为 00000000000000000000000010000000 解法： 看别人大神的解法 当n与n-1相与时，正数从右开始非零的第一个1变为零，因为负数在电脑中用补码表示，所以大致相同。 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 ​ 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 1234567891011public static int hammingWeight(int n) &#123; if (n == 0) &#123; return 0; &#125; int re = 0; while (n != 0) &#123; n = n &amp; (n - 1); re++; &#125; return re; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis持久化]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F30%2Fredis%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[redis持久化简介​ 持久化是指将redis中存储的数据写入到硬盘中。redis中可以使用快照和只追加文件将redis中的数据写入到硬盘中，可以单独使用或者同时使用。 快照概述 ​ redis可以通过快照获取在某个时间点，redis存储的所有数据的副本。在创建快照之后，用户可以对快照进行备份，以备后用。 将某一时刻的所有数据都写入硬盘里面。 创建快照 创建快照的5种方法： 客户端通过redis发送BGSAVE命令创建一个快照。除了windows平台不支持，其他平台都支持BGSAVE命令，执行时redis会调用fork创建一个子进程，由子进程负责将快照写入硬盘，父进程继续处理命令请求。 客户端还可以向redis发送SAVE命令创建快照，与BGSAVE的区别是，redis服务器在收到SAVE命令时，服务器在没有创建完快照之前不在响应任何其他命令。 可以通过设置save配置选项实现创建快照，如：save 60 1000 “当60秒之内有1000次写入”redis会触发BGSAVE选项创建快照。 当redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准的TERM信号时，会执行一个SAVE命令，阻塞所有的客户端，不在执行客户端发送的任何命令，并在执行完后关闭服务器。 当一个redis服务器连接另一个redis服务器的，并向对方发送SYNC命令来开始一次复制操作的时候，如果主服务器没有执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器就会执行BGSAVE命令。 注意事项 在只是用快照持久化来保存数据时，如果系统发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。所以快照持久化适用于即使丢失一部分数据也不会造成问题的应用程序。 只追加文件（AOF）概述 AOF持久化会将被执行的写命令写到AOF文件的末尾，来记录数据发生的变化，所以redis从头执行一次aof文件就可以还原出来数据集。 它会在执行命令时，将被执行的写命令复制到硬盘里面。 创建aop 配置appendonly 选项 always 每个redis写命令都要同步写入硬盘。严重降低redis的速度，会降低固态硬盘的使用寿命 everysec 每秒执行一次同步 ，显式地将多个写命令同步到硬盘 no 让操作系统来决定应该何时进行同步，系统崩溃会丢失不定数量的数据。2.如果用户的硬盘处理写入操作的速度不够快，当缓存区满了的话，redis的写入操作将被阻塞，会严重的影响redis处理命令的速度。不推荐使用。 重写和压缩AOF文件 aof文件存在的问题： 1.随着redis的执行，AOF文件的体积也来越大。 2.redis在启动的时候会重新执行Aof文件来恢复数据，如果AOF文件的体积太大所需的开启时间也就越大。 解决AOF文件体积太大的问题： 1.用户向redis发送BGREWRITEAOF命令，这个命令会移除Aof文件种冗余的命令来重写AOF文件，减少AOF文件的体积。 BGREWRITEAOF和BGSAVE差不多，都是创建一个子进程来对AOF文件进行重写。 2.通过设置auto-aof-rewrite-percentage选项，auto-aof-rewrite-min-size选项来自动执行BGREWRITEAOF命令。 auto-aof-rewrite-percentage：100 auto-aof-rewrite-min-size：64mb 当aof文件的体积大于64mb并且体积比上一次aof文件体积大了100%。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring mvc启动流程]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F28%2Fspring%20mvc%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[spring mvc启动流程spring mvc项目中的web.xml文件1234567891011121314151617181920212223242526&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--上下文参数--&gt; &lt;context-param&gt; &lt;!--上下文配置位置，将此位置定义的bean放在容器中--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ContextLoaderListener类ContextLoaderListener类继承ContextLoader 类和实现了 ServletContextListener接口。ContextLoader 类执行根应用程序上下文的实际初始化工作。ServletContextListener接口此接口的实现接收有关它们所属的Web应用程序的servlet上下文的更改的通知。 12345678910111213141516171819202122232425public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123; /* *两个构造函数 */ public ContextLoaderListener() &#123; &#125; public ContextLoaderListener(WebApplicationContext context) &#123; super(context); &#125; /* *初始化根Web应用程序上下文。 */ @Override public void contextInitialized(ServletContextEvent event) &#123; initWebApplicationContext(event.getServletContext()); &#125; /* *关闭根Web应用程序上下文。 */@Override public void contextDestroyed(ServletContextEvent event) &#123; closeWebApplicationContext(event.getServletContext()); ContextCleanupListener.cleanupAttributes(event.getServletContext()); &#125; &#125; 初始化web根应用程序上下文，调用ContextLoader类的initWebApplicationContext()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 初始化web上下文 * * @param servletContext servlet上下文 * @return */ public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123; /** *判断是否已有根应用上下文 */ if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) &#123; throw new IllegalStateException( "Cannot initialize context because there is already a root application context present - " + "check whether you have multiple ContextLoader* definitions in your web.xml!"); &#125; Log logger = LogFactory.getLog(ContextLoader.class); servletContext.log("Initializing Spring root WebApplicationContext"); if (logger.isInfoEnabled()) &#123; logger.info("Root WebApplicationContext: initialization started"); &#125; long startTime = System.currentTimeMillis(); try &#123; // 将上下文存储在本地实例变量中，以保证这一点 // 它在ServletContext关闭时可用。 if (this.context == null) &#123; //根据当前的servlet上下文创建web应用上下文 this.context = createWebApplicationContext(servletContext); &#125; //判断创建的web应用上下文是否式ConfigurableWebApplicationContext类的一个实例 if (this.context instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context; //如果上下文不是活动状态 if (!cwac.isActive()) &#123; // 上下文尚未刷新 - &gt;提供诸如此类的服务 // 设置父上下文，设置应用程序上下文ID等 if (cwac.getParent() == null) &#123; // 注入上下文实例时没有显式父 - &gt; // 确定根Web应用程序上下文的父级（如果有） ApplicationContext parent = loadParentContext(servletContext); cwac.setParent(parent); &#125; //配置和刷新web应用上下文 configureAndRefreshWebApplicationContext(cwac, servletContext); &#125; &#125; //将对象绑定到此servlet上下文中的给定属性名称。 servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); //获取当前线程的上下文类加载器 ClassLoader ccl = Thread.currentThread().getContextClassLoader(); if (ccl == ContextLoader.class.getClassLoader()) &#123; currentContext = this.context; &#125; else if (ccl != null) &#123; currentContextPerThread.put(ccl, this.context); &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Published root WebApplicationContext as ServletContext attribute with name [" + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + "]"); &#125; if (logger.isInfoEnabled()) &#123; long elapsedTime = System.currentTimeMillis() - startTime; logger.info("Root WebApplicationContext: initialization completed in " + elapsedTime + " ms"); &#125; return this.context; &#125; catch (RuntimeException ex) &#123; logger.error("Context initialization failed", ex); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex); throw ex; &#125; catch (Error err) &#123; logger.error("Context initialization failed", err); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err); throw err; &#125; &#125; initWebApplicationContext()方法如上注解讲述，主要目的就是创建root WebApplicationContext对象即根IoC容器，其中比较重要的就是，整个Web应用如果存在根IoC容器则有且只能有一个，根IoC容器作为全局变量存储在ServletContext即application对象中。将根IoC容器放入到application对象之前进行了IoC容器的配置和刷新操作，调用了configureAndRefreshWebApplicationContext()方法，该方法源码如下: 配置web应用程序上下文configureAndRefreshWebApplicationContext类 123456789101112131415161718192021222324252627282930313233343536373839/** * 配置和刷新web应用上下文 * @param wac * @param sc */protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123; if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123; //应用程序上下文ID仍设置为其原始默认值 // -&gt; 根据可用信息分配更有用的ID //返回参数值的string String idParam = sc.getInitParameter(CONTEXT_ID_PARAM); if (idParam != null) &#123; wac.setId(idParam); &#125; else &#123; // Generate default id... wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getContextPath())); &#125; &#125; wac.setServletContext(sc); String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM); if (configLocationParam != null) &#123; wac.setConfigLocation(configLocationParam); &#125; // The wac environment's #initPropertySources will be called in any case when the context // is refreshed; do it eagerly here to ensure servlet property sources are in place for // use in any post-processing or initialization that occurs below prior to #refresh ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) &#123; ((ConfigurableWebEnvironment) env).initPropertySources(sc, null); &#125; customizeContext(sc, wac); //加载或刷新配置的持久表示， wac.refresh();&#125; refresh()方法在AbstractApplicationContext类的重写方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 准备此上下文以进行刷新。 prepareRefresh(); // 告诉子类刷新内部bean工厂。 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 准备bean工厂以在此上下文中使用。 prepareBeanFactory(beanFactory); try &#123; //允许在上下文子类中对bean工厂进行后处理。 postProcessBeanFactory(beanFactory); //在上下文中调用注册为bean的工厂处理器。 invokeBeanFactoryPostProcessors(beanFactory); // 注册拦截bean创建的bean处理器。 registerBeanPostProcessors(beanFactory); // 初始化此上下文的消息源。 initMessageSource(); // 初始化此上下文的事件多播器。 initApplicationEventMulticaster(); // 在特定上下文子类中初始化其他特殊bean。 onRefresh(); // 检查监听器bean并注册它们。 registerListeners(); // 实例化所有剩余（非延迟初始化）单例。 finishBeanFactoryInitialization(beanFactory); //最后一步：发布相应的事件。 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // 摧毁已经创建的单身人士以避免悬空资源。 destroyBeans(); // 重置'有效'标志。 cancelRefresh(ex); //向调用者传播异常。 throw ex; &#125; finally &#123; // 从我们开始，重置Spring核心中的常见内省缓存 // 也许再也不需要单例bean的元数据...... resetCommonCaches(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数质数]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F26%2F%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[计数质数统计所有小于非负整数 n 的质数的数量。 示例: 123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解法 解法：埃拉托斯特尼筛法 Sieve of Eratosthenes 如果一个数是另一个数的倍数，那这个数肯定不是质数。利用这个性质，可以建立一个质数数组，从2开始将素数的倍数都标注为不是质数。第一轮将4、6、8等表为非质数，然后遍历到3，发现3没有被标记为非质数，则将6、9、12等标记为非质数，一直到N为止，再数一遍质数数组中有多少质数。 123456789101112131415161718192021222324class Solution &#123; public int countPrimes(int n) &#123; if (n&lt;=0)&#123; return 0; &#125; boolean [] b=new boolean[n]; Arrays.fill(b,true); int re=0; for (int i=2;i&lt;n;i++)&#123; if (b[i]) &#123; //i的2到n倍 for (int j=2*i;j&lt;n;j=j+i)&#123; b[j]=false; &#125; &#125; &#125; for (int i=2;i&lt;n;i++)&#123; if (b[i])&#123; re++; &#125; &#125; return re; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeanFactory 和 ApplicationContext 有什么区别]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F25%2FBeanFactory%20%E5%92%8C%20ApplicationContext%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[总结BeanFactory 和 ApplicationContext 有什么区别？1.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。 BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。 2.applicationcontext接口对beanfactory进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成 springbean的生命周期？ 实例化bean -增加属性-aware接口实现-beanpostprocessor预初始化方法–initializingBean接口的afterPropertiesSet 初始化bean—调用自定义的初始化方法–Beanpostprocess接口的postprocessAfterInitalization（）初始化后方法–bean可使用—容器关闭—dispostableBean接口的destroy（）销毁 sPRING IOC如何实现的？ 1.ioc控制反转：将对象创建的权力交给容器，通过容器创建对象。 2.在spring的工作方式中，所有的类都注册在spring容器中，告诉spring这是什么东西需要什么，然后spring会在系统运行到适当的时候把你要的东西主动给你。 3.依赖注入的思想通过反射机制实现的，在实例化一个类时，他通过反射调用类的set方法将事先保存在hashmap中的类的属性注入到类中。 注入的方式：构造器注入，set注入，接口注入 spring aop实现？ 1.aop面向切面编程技术。aop是基于ioc实现的，这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。本文会分别对AspectJ和Spring AOP的实现进行分析和介绍。 spring aop是动态代理，表示spring aop不会去修改字节码，而是在内存中临时生成一个aop对象，这个对象包含了目标对象的所有方法，并且在特定的切点做了增强处理，并回调原对象的方法。 2.spring aop的实现方法： 2.1。jdk动态代理：jdk动态代理类通过反射来来接收被代理的类，其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理，核心是invocationhandel和proxy 如果目标类没有实现接口，使用cglib代理 2.2. CGLIB代理：cglib是通过继承实现代理的，cglib是一个代码生成的类库，可以在运行时动态的生成某个类的子类。 spring 事务实现方式？ 一个数据库事务通常包含了一个序列的对数据库的读/写操作 编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦。 编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现 Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了 编程式事务管理：使用TransactionTemplate和直接使用PlatformTransactionManager。 声明式事务管理： 1）每个Bean都有一个代理 （2）所有Bean共享一个代理基类 3）使用拦截器 （4）使用tx标签配置的拦截器 （5）全注解 spring事务原理？ 本质是对数据库事务的封装支持。spring事务通过aop动态代理实现，使用上通常要先要在配置文件中开启事务，然后]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解教程及自定义注解]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F24%2FJava%E6%B3%A8%E8%A7%A3%E6%95%99%E7%A8%8B%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java注解教程及自定义注解创建Java自定义注解 创建自定义注解和创建一个接口相似，但是注解的interface关键字需要以@符号开头。我们可以为注解声明方法。我们先来看看注解的例子，然后我们将讨论他的一些特性。 注解方法不能带有参数； 注解方法返回值类型限定为：基本类型、String、Enums、Annotation或者是这些类型的数组； 注解方法可以有默认值； 注解本身能够包含元注解，元注解被用来注解其它注解。 这里有四种类型的元注解： @Documented —— 指明拥有这个注解的元素可以被javadoc此类的工具文档化。这种类型应该用于注解那些影响客户使用带注释的元素声明的类型。如果一种声明使用Documented进行注解，这种类型的注解被作为被标注的程序成员的公共API。 @Target——指明该类型的注解可以注解的程序元素的范围。该元注解的取值可以为TYPE,METHOD,CONSTRUCTOR,FIELD等。如果Target元注解没有出现，那么定义的注解可以应用于程序的任何元素。 @Inherited——指明该注解类型被自动继承。如果用户在当前类中查询这个元注解类型并且当前类的声明中不包含这个元注解类型，那么也将自动查询当前类的父类是否存在Inherited元注解，这个动作将被重复执行知道这个标注类型被找到，或者是查询到顶层的父类。 4.@Retention——指明了该Annotation被保留的时间长短。RetentionPolicy取值为SOURCE,CLASS,RUNTIME。 Java内建注解 Java提供了三种内建注解。 @Override——当我们想要复写父类中的方法时，我们需要使用该注解去告知编译器我们想要复写这个方法。这样一来当父类中的方法移除或者发生更改时编译器将提示错误信息。 @Deprecated——当我们希望编译器知道某一方法不建议使用时，我们应该使用这个注解。Java在javadoc 中推荐使用该注解，我们应该提供为什么该方法不推荐使用以及替代的方法。 @SuppressWarnings——这个仅仅是告诉编译器忽略特定的警告信息，例如在泛型中使用原生数据类型。它的保留策略是SOURCE（译者注：在源文件中有效）并且被编译器丢弃。 转载自并发编程网 – ifeve.com本文链接地址: Java注解教程及自定义注解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子序和]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F21%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解法1：动态规划 时间复杂度为n，推出公式sum【i】=max{sum[i-1],a[i]},使用maxn存储前面遍历过的最大的连续子数组的和。当sum&lt;0时要进行重置为0； 123456789101112131415public static int maxSubArray(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int maxn=nums[0]; int sum=0; for (int i:nums)&#123; sum+=i; maxn=Math.max(maxn,sum); if (sum&lt;0)&#123; sum=0; &#125; &#125; return maxn; &#125; 解法2：分治法 1.分别求左右两边的最大子序列的和。 2.判断左右两边和两个相加的和，求出最大子序列和。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int maxSubArray(int[] nums) &#123; return findMaxSubArray(nums,0,nums.length-1); &#125; private int findMaxSubArray(int[] nums, int low, int high) &#123; if(low==high)&#123; return nums[low]; &#125; int mid=(low+high)/2; int leftMax=findMaxSubArray(nums,low,mid); int rightMax=findMaxSubArray(nums,mid+1,high); int crossMax=findCrossingSubArray(nums,low,mid,high); int tempmax=Math.max(leftMax, rightMax); return Math.max(tempmax, crossMax); &#125; private int findCrossingSubArray(int[] nums, int low, int mid, int high) &#123; //从中间开始找左边最大序列和 int leftsum=Integer.MIN_VALUE; int sum=0; for(int i=mid;i&gt;=low;i--)&#123; sum=sum+nums[i]; if(sum&gt;leftsum)&#123; leftsum=sum; &#125; &#125; //从中间开始找右边最大序列和 int rightsum=Integer.MIN_VALUE; sum=0; for(int i=mid+1;i&lt;=high;i++)&#123; sum=sum+nums[i]; if(sum&gt;rightsum)&#123; rightsum=sum; &#125; &#125; return leftsum+rightsum; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程生命周期,线程安全问题]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F18%2F%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[线程生命周期结构图： 线程安全问题线程安全：http://www.jasongj.com/java/thread_safe/ Java并发编程：volatile关键字解析 ：https://www.cnblogs.com/dolphin0520/p/3920373.html]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的范式]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库的范式概述： 关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。 第一范式（1NF）： 确保每一列的原子性. 第一范式是为了要排除 重复组 的出现，所采用的方法是要求数据库的每个列的值域都是由原子值组成；每个字段的值都只能是单一值。1971年埃德加·科德提出了第一范式。 说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。 第二范式（2NF）： 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。 它的规则是要求数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系：每个非键属性必须独立于任意一个候选键的任意一部分属性。如果有哪些数据只和一个键的一部分有关的话，就得把它们独立出来变成另一个数据表。如果一个数据表的键只有单个字段的话，它就一定匹配第二范式。 非键字段必须依赖于主键字段。 第三范式（3NF）： 在1NF基础上，除了主键以外的其他列都不传递依赖于主键列。（任何非主属性不依赖于其他非主属性）]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F14%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解法：动态规划 因为只允许交易一次，要想获利最大需要在最小时候买入，最高卖出。 1234567891011121314public int maxProfit(int[] prices) &#123; if (prices==null||prices.length==0)&#123; return 0; &#125; int min=prices[0]; int re=0; for (int i=0;i&lt;prices.length;i++)&#123; //最小时买入 min=Math.min(min,prices[i]); //最大时卖出 re=Math.max(re,prices[i]-min); &#125; return re; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬楼梯]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F14%2F%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[爬楼梯假设你正在爬楼梯。需要 n 步你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 步 + 1 步2. 2 步 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 步 + 1 步 + 1 步2. 1 步 + 2 步3. 2 步 + 1 步 解法： 当爬一节台阶时有一种方法，爬两阶台阶时有两种方法，f（n）表示爬n阶台阶的方法。 f(1)=1 f(2)=2 f(3)=f(2)+f(1)=3 f(4)=f(3)+f(2) 找规律可得f（n）=f（n-1）+f（n-2） 方法一：动态规划 因为每次都要使用前面两个数的值，所以使用数组将前面的值保存起来，已备后用。 1234567891011121314class Solution &#123; public int climbStairs(int n) &#123; if (n==0||n==1||n==2)&#123; return n; &#125; int [] a=new int[n+1]; a[1]= 1; a[2]=2; for (int i=3;i&lt;=n;i++)&#123; a[i]=a[i-1]+a[i-2]; &#125; return a[n]; &#125;&#125; 方法二：递归 优点：代码简单 缺点：时间太长 123456789101112131415public int climbStairs1(int n) &#123; if (n==0)&#123; return 0; &#125; if (n==1)&#123; return 1; &#125; if (n==2)&#123; return 2; &#125; if (n&gt;=3)&#123; return climbStairs(n-1)+climbStairs(n-2); &#125; return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个错误的版本]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F14%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 1234567给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 解法： 二分查找 123456789101112131415public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int pre = 1, last = n; while(pre&lt;last)&#123; int mid = pre + (last - pre) / 2; if(isBadVersion(mid))&#123; last = mid; &#125;else&#123; pre = mid+1; &#125; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并两个有序数组]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F13%2F%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[合并两个有序数组给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 解法 归并排序差不多,题目将nums2合并到nums1中，从屁股插入数据移动的次数比较少。 123456789101112131415public static void merge(int[] nums1, int m, int[] nums2, int n) &#123; int end=m+n-1; n--; m--; while(n&gt;=0&amp;&amp;m&gt;=0)&#123; if (nums1[m]&lt;nums2[n])&#123; nums1[end--]=nums2[n--]; &#125;else &#123; nums1[end--]=nums1[m--]; &#125; &#125; while(n&gt;=0)&#123; nums1[end--]=nums2[n--]; &#125; &#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将有序数组转换为二叉搜索树]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F13%2F%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[将有序数组转换为二叉搜索树将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解法 使用递归，因为题目所给的数组是有序的，则根节点的值是nums[nums.length/2], 然后使用递归分别求他的左子树，右子树。 12345678910111213141516171819class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if(nums==null||nums.length&lt;=0)&#123; return null; &#125; int len=nums.length; return creatBST(nums,0,len-1); &#125; public TreeNode creatBST(int[] nums,int star,int end)&#123; TreeNode root=null; if (star&lt;=end) &#123; int in = (star + end + 1) / 2; root = new TreeNode(nums[in]); root.left = creatBST(nums, star, in - 1); root.right = creatBST(nums, in + 1, end); &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称二叉树]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F12%2F%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[对称二叉树给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \2 2 \ \ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 解法一： 递归实现,只要判断左子树的左节点和右子树的右节点，左子树的右节点和右子树的左节点相同。 123456789101112131415public boolean isSymmetric(TreeNode root) &#123; if (root==null)&#123; return true; &#125; return zhongxu(root.left,root.right); &#125; public boolean zhongxu(TreeNode p,TreeNode q)&#123; if (p==null&amp;&amp;q==null)&#123; return true; &#125; if (p==null||q==null)&#123; return false; &#125; return p.val==q.val&amp;&amp;zhongxu(p.left,q.right)&amp;&amp;zhongxu(p.right,q.left); &#125; 解法二： 迭代实现，使用一个栈，将左节点和右节点压入，最重要的是空节点也要压入。 12345678910111213141516171819202122232425262728293031public boolean isSymmetric1(TreeNode root) &#123; if (root==null)&#123; return true; &#125; TreeNode l=root.left,r=root.right; Stack&lt;TreeNode&gt; s=new Stack&lt;&gt;(); //空节点也压入栈中 s.push(l); s.push(r); while(!s.empty())&#123; l=s.peek(); s.pop(); r=s.peek(); s.pop(); //循环结束条件 if (l==null&amp;&amp;r==null)&#123; continue; &#125; if (l==null||r==null)&#123; return false; &#125; if (l.val!=r.val)&#123; return false; &#125; s.push(l.left); s.push(r.right); s.push(l.right); s.push(r.left); &#125; return true; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最大深度]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F11%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 解法： 使用递归，和递归遍历差不多。先遍历左子树，再遍历右子树，最后返回最大数加一。 12345678public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left, right) + 1; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排他锁（写锁），共享锁（读锁）死锁 和 活锁]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F11%2F%E6%AD%BB%E9%94%81%20%E5%92%8C%20%E6%B4%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[排他锁（写锁），共享锁（读锁）死锁 和 活锁排他锁（写锁，X锁）： 事务t对数据a加上X锁，则只允许事务t对a进行读取，和修改，其他事务都不能对a加任何类型的锁，直到t释放a上的锁为止。就保证了其他事务在t事务在对a释放之前，不能对a进行修改和读取。 共享锁（读锁，S锁）： 若事务t对数据a加上s锁，则事务t可以读a但不能修改a，其他事务可以对a加s锁，而在t没有释放a的锁时不能加x锁，表示其他事务可以读取a的数据，但在t释放a 的s锁之前不能对a进行修改。 分所类型的相容矩阵 概述： 在数据库系统中，封锁的方法可能引起活锁和死锁 活锁：如果事务t1封锁了数据r，事务t2又请求封锁r，于是t2等待；T3也请求封锁r，当t1释放r上的锁之后系统首先批准t3的请求，t2接着等，t4也请求封锁r，t3释放r系统又批准t4，就不给r2，r2一直等啊等，永远的等下去，这就是活锁的情景。 避免活锁： 系统采用先来先服务的策略。（先到先得） 死锁：如果事务t1封锁r1，t2封锁了r2，然后r1又请求封锁r2，因为t2已经封锁r2，于是t1等待t2释放r2上的锁；接着t2又申请封锁r1，又因为t1已经封锁了r1，所以t2等待t1释放r1的锁，就这样t1等t2放锁，t2等t1放锁，所以这两个事务将永远不能结束。就形成了死锁。 死锁的预防（不适用）： 1.一次封锁法 一次封锁法要求每个事务必须一次将所有使用的数据全部加锁，否则就不能继续执行。如上面的例子中，如果t1将r1和r2都加锁，当t1释放锁后t2在加锁，这样就不会发生死锁。 2.顺序封锁法 顺序封锁法是加锁前先对数据对象指定一个封锁顺序，所有事务都按照这个顺序执行。 缺点：太复杂，成本高， 死锁的诊断与解除 超时法：当一个事务的等待时间超过了规定的时间，就认为发生了死锁。 缺点：时间设置太短，发生误判，时间太长，不能及时发现 等待图法：事务等待图是一个有向图G=(T,U)，t为节点的集合，每个节点表示一个事务；u为边的集合，每个边表示事务等待的情况；t1等待t2，t1指向t2一条线。 同常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有所有的锁，使其他事务得以继续运行下去。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排他锁（写锁），共享锁（读锁）死锁 和 活锁]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F11%2F%E6%8E%92%E4%BB%96%E9%94%81%EF%BC%88%E5%86%99%E9%94%81%EF%BC%89%EF%BC%8C%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%88%E8%AF%BB%E9%94%81%EF%BC%89%E6%AD%BB%E9%94%81%20%E5%92%8C%20%E6%B4%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[排他锁（写锁），共享锁（读锁）死锁 和 活锁排他锁（写锁，X锁）： 事务t对数据a加上X锁，则只允许事务t对a进行读取，和修改，其他事务都不能对a加任何类型的锁，直到t释放a上的锁为止。就保证了其他事务在t事务在对a释放之前，不能对a进行修改和读取。 共享锁（读锁，S锁）： 若事务t对数据a加上s锁，则事务t可以读a但不能修改a，其他事务可以对a加s锁，而在t没有释放a的锁时不能加x锁，表示其他事务可以读取a的数据，但在t释放a 的s锁之前不能对a进行修改。 分所类型的相容矩阵 概述： 在数据库系统中，封锁的方法可能引起活锁和死锁 活锁：如果事务t1封锁了数据r，事务t2又请求封锁r，于是t2等待；T3也请求封锁r，当t1释放r上的锁之后系统首先批准t3的请求，t2接着等，t4也请求封锁r，t3释放r系统又批准t4，就不给r2，r2一直等啊等，永远的等下去，这就是活锁的情景。 避免活锁： 系统采用先来先服务的策略。（先到先得） 死锁：如果事务t1封锁r1，t2封锁了r2，然后t1又请求封锁r2，因为t2已经封锁r2，于是t1等待t2释放r2上的锁；接着t2又申请封锁r1，又因为t1已经封锁了r1，所以t2等待t1释放r1的锁，就这样t1等t2放锁，t2等t1放锁，所以这两个事务将永远不能结束。就形成了死锁。 死锁的预防（不适用）： 1.一次封锁法 一次封锁法要求每个事务必须一次将所有使用的数据全部加锁，否则就不能继续执行。如上面的例子中，如果t1将r1和r2都加锁，当t1释放锁后t2在加锁，这样就不会发生死锁。 2.顺序封锁法 顺序封锁法是加锁前先对数据对象指定一个封锁顺序，所有事务都按照这个顺序执行。 缺点：太复杂，成本高， 死锁的诊断与解除 超时法：当一个事务的等待时间超过了规定的时间，就认为发生了死锁。 缺点：时间设置太短，发生误判，时间太长，不能及时发现 等待图法：事务等待图是一个有向图G=(T,U)，t为节点的集合，每个节点表示一个事务；u为边的集合，每个边表示事务等待的情况；t1等待t2，t1指向t2一条线。 同常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有所有的锁，使其他事务得以继续运行下去。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环形链表]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F11%2F%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[环形链表给定一个链表，判断链表中是否有环。 进阶：你能否不使用额外空间解决此题？ 解法： 使用快慢指针，慢指针一次走一步，快指针一次两步，如果快指针和慢指针相遇则链表有环。 1234567891011121314151617public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if (head==null)&#123; return false; &#125; ListNode fast=head; ListNode slow=head; while (fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if (fast==slow)&#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文链表]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F11%2F%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[回文链表请判断一个链表是否为回文链表。 示例 1: 12输入: 1-&gt;2输出: false 示例 2: 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 方法一： 先遍历一遍链表，使用Arraylist存储各个节点的值，然后反转链表，在遍历反转后的链表，比较节点的值和Arraylist中的值。 1234567891011121314151617181920212223242526272829303132//反转链表 public static ListNode fz(ListNode head)&#123; if (head==null||head.next==null)&#123; return head; &#125; ListNode p=fz(head.next); head.next.next=head; head.next=null; return p; &#125; public boolean isPalindrome1(ListNode head) &#123; if(head==null||head.next==null)&#123; return true; &#125; ListNode h=head; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); while(head!=null)&#123; list.add(head.val); head=head.next; &#125; ListNode p=fz(h); int i=0; while(p!=null&amp;&amp;i&lt;list.size())&#123; if (list.get(i)!=p.val)&#123; return false; &#125; p=p.next; i++; &#125; return p==null; &#125; 方法二： 先通过快慢指针，找到链表的中点，然后反转中点后面的链表，遍历前面的链表和反转后的链表比较它们的值。 1234567891011121314151617181920212223242526272829303132333435363738public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null)&#123; return true; &#125; ListNode p= findin(head); p.next= fz(p.next); ListNode re=p.next; while(head!=null&amp;&amp;re!=null&amp;&amp;re.val==head.val)&#123; head=head.next; re=re.next; &#125; return re==null; &#125; //找链表的中点 public static ListNode findin(ListNode head)&#123; if(head == null || head.next == null) &#123; return head; &#125; ListNode p=head; ListNode q=head; //判断指针q的下一个是否为空，q的后两步是否为空 while(q.next!=null&amp;&amp;q.next.next!=null)&#123; p=p.next; q=q.next.next; &#125; return p; &#125; //反转链表 public static ListNode fz(ListNode head)&#123; if (head==null||head.next==null)&#123; return head; &#125; ListNode p=fz(head.next); head.next.next=head; head.next=null; return p; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有效的字母异位词]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F10%2F2018-06-28-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[回文链表请判断一个链表是否为回文链表。 示例 1: 12输入: 1-&gt;2输出: false 示例 2: 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 解法一： 找到链表的中点，反转后面的链表，然后再遍历两个链表判断是否相等。 1234567891011121314151617181920212223242526272829303132333435363738public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null)&#123; return true; &#125; ListNode p= findin(head); p.next= fz(p.next); ListNode re=p.next; while(head!=null&amp;&amp;re!=null&amp;&amp;re.val==head.val)&#123; head=head.next; re=re.next; &#125; return re==null; &#125; //找链表的中点 public static ListNode findin(ListNode head)&#123; if(head == null || head.next == null) &#123; return head; &#125; ListNode p=head; ListNode q=head; //判断指针q的下一个是否为空，q的后两步是否为空 while(q.next!=null&amp;&amp;q.next.next!=null)&#123; p=p.next; q=q.next.next; &#125; return p; &#125; //反转链表 public static ListNode fz(ListNode head)&#123; if (head==null||head.next==null)&#123; return head; &#125; ListNode p=fz(head.next); head.next.next=head; head.next=null; return p; &#125; 解法二：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库隔离级别]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F10%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[数据库隔离级别原文 事务数据库事务（Transaction）是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。一方面，当多个应用程序并发访问数据库时，事务可以在应用程序间提供一个隔离方法，防止互相干扰。另一方面，事务为数据库操作序列提供了一个从失败恢复正常的方法。 事务的四个特性事务具有四个特性：原子性（Atomicity）、一致性（Consistency）、隔离型（Isolation）、持久性（Durability），简称ACID。 原子性（Atomicity） 事务的原子性是指事务中的操作不可拆分，只允许全部执行或者全部不执行。 一致性（Consistency） 事务的一致性是指事务的执行不能破坏数据库的一致性，一致性也称为完整性。一个事务在执行后，数据库必须从一个一致性状态转变为另一个一致性状态。 隔离型（Isolation） 事务的隔离型是指并发的事务相互隔离，不能互相干扰。 持久性（Durability） 事务的持久性是指事务一旦提交，对数据的状态变更应该被永久保存。 数据库隔离级别对于同时运行的多个事务,当这些事务访问数据库中相同的数据时,如果没有采取必要的隔离机制,就会导致各种并发问题: 脏读：对于两个事务T1，T2，T1读取了已经被T2更新但还没有提交的字段，之后，若T2回滚，T1读取到的内容就是临时无效的内容。 不可重复读：对于事务T1，T2，T1需要读取一个字段两次，在第一次和第二次读取之间，T2更新了该字段，导致T1第二次读取到的内容值不同。 幻读： 事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。 幻读与不可重复读之间的区别是幻读强调的是新增或删除,而不可重复读强调的是修改。比如Mary两次查工资，中间有人改过工资，则两次结果不一样，这就是不可重复读。Mary要查工资一千的人数，第一次查到了10个，中间有人增加了一条工资为一千的人，下次查的时候就变成了11个，好像第一次查询的是幻觉一样。 事务的四个隔离级别 实际工作中事务几乎都是并发的，完全做到互相之间不干扰会严重牺牲性能，为了平衡隔离型和性能，SQL92规范定义了四个事务隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）、串行化（Serializable）。四个级别逐渐增强，每个级别解决上个级别的一个问题。 读未提交（Read Uncommitted） 另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）。 脏读是指另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据。 读已提交（Read Committed） 本事务读取到的是最新的数据（其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不可重复读）。 不可重复读是指同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。 可重复读（Repeatable Read） 在同一个事务里，SELECT的结果是事务开始时间点的状态，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象。 可重复读保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会发现了这些新数据，貌似之前读到的数据是幻觉，这就是幻读。 串行化（Serializable） 所有事务只能一个接一个串行执行，不能并发。 隔离级别的选择 事务隔离级别越高，越能保证数据的一致性，但对并发性能影响越大，一致性和高性能必须有所取舍或折中。 一般情况下，多数应用程序可以选择将数据库的隔离级别设置为读已提交，这样可以避免脏读，也可以得到不错的并发性能。尽管这个隔离级别会导致不可重复度、幻读，但这种个别场合应用程序可以通过主动加锁进行并发控制。 Oracle支持两种隔离级别，READ COMMITED和SERIALIZABLE默认的事务隔离级别是READ COMMITED MYSQL支持4中隔离界别，默认的是REPEATED READ]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共前缀]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F09%2F%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解法： 由于只是最长公共前缀，先将字符数组排序，只比较最小和最大的字符串。 1234567891011121314151617public static String longestCommonPrefix1(String[] strs) &#123; StringBuilder builder = new StringBuilder(); if (strs != null &amp;&amp; strs.length &gt; 0) &#123; Arrays.sort(strs); char[] a = strs[0].toCharArray(); char[] b = strs[strs.length - 1].toCharArray(); for (int i = 0; i &lt; a.length; i++) &#123; if (b.length &gt; i &amp;&amp; a[i] == b[i]) &#123; builder.append(a[i]); &#125; else &#123; return builder.toString(); &#125; &#125; &#125; return builder.toString(); &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证二叉搜索树]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F08%2F%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。 一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \ 1 3输出: true 示例 2: 123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解法： 1.根据定义判断，使用递归，设置一个min和max，当节点的值大于max时false，节点值小与min时false，遍历完返回true。 2.先中序遍历，然后判断得到的链表是否是递增的。 12345678910111213141516public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return dfs(root,Long.MIN_VALUE,Long.MAX_VALUE); &#125; public boolean dfs(TreeNode root,long min,long max)&#123; if (root==null)&#123; return true; &#125; if (root.val&lt;=min||root.val&gt;=max)&#123; return false; &#125; return dfs(root.left,min,root.val)&amp;&amp;dfs(root.right,root.val,max); &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql语法随笔]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F08%2Fmysql%E8%AF%AD%E6%B3%95%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[mysql语法随笔创建数据库 1CREATE DATABASE 数据库名; drop 命令删除数据库drop 命令格式： 1drop database &lt;数据库名&gt;; mysql创建表 以下为创建MySQL数据表的SQL通用语法： 1CREATE TABLE table_name (column_name column_type); 以下例子中我们将在 RUNOOB 数据库中创建数据表runoob_tbl： 1234567CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8; 实例解析： 如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 删除表 1DROP TABLE TABLE_NAME; 插入数据 1INSERT INTO TABLE_NAME(f1,f2,f3) VALUES (v1,v2,v3); 查询数据 1234SELECT COLUM_NAME,COLUM_NAMEFROM TABLE_NAME[WHERE Clause][LIMIT N][OFFSET M] 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件。 你可以使用 LIMIT 属性来设定返回的记录数。 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 where子句 12SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2..... 查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用WHERE语句来设定查询条件。 你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。 WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。 UPDATE查询 12UPDATE TABLE_NAME SET f1=new-value,f2=new-value[WHERE Clause] DELETE语句 1DELETE FROM table_name [WHERE Clause] LIKE语句 12SELECT f1,f2,f3 FROM table_nameWHERE f1 LIKE condition1[AND[OR]] f2=&apos;somevalue&apos; 你可以在 WHERE 子句中指定任何条件。 你可以在 WHERE 子句中使用LIKE子句。 你可以使用LIKE子句代替等号 =。 LIKE 通常与 % 一同使用，类似于一个元字符的搜索。 你可以使用 AND 或者 OR 指定一个或多个条件。 你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。 UNION操作符 Union可以将两个select语句的结果组合 1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据。 排序 1SELECT F1,F2 FROM TABLE_NAME ORDER BY F1[ASC[DECS]] 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 WHERE…LIKE 子句来设置条件。 GROUP BY分组 GROUP BY 语句根据一个或多个列对结果集进行分组。 在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 1234SELECT column_name,function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY cOLUMN_NAME; 12345678910111213mysql&gt; set names utf8;mysql&gt; SELECT * FROM employee_tbl;+----+--------+---------------------+--------+| id | name | date | singin |+----+--------+---------------------+--------+| 1 | 小明 | 2016-04-22 15:25:33 | 1 || 2 | 小王 | 2016-04-20 15:25:47 | 3 || 3 | 小丽 | 2016-04-19 15:26:02 | 2 || 4 | 小王 | 2016-04-07 15:26:14 | 4 || 5 | 小明 | 2016-04-11 15:26:40 | 4 || 6 | 小明 | 2016-04-04 15:26:54 | 2 |+----+--------+---------------------+--------+6 rows in set (0.00 sec) 接下来我们使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录： 123456789mysql&gt; SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;+--------+----------+| name | COUNT(*) |+--------+----------+| 小丽 | 1 || 小明 | 3 || 小王 | 2 |+--------+----------+3 rows in set (0.01 sec) 使用 WITH ROLLUPWITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。 例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数： 12345678910mysql&gt; SELECT name, SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------+--------------+| name | singin_count |+--------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || NULL | 16 |+--------+--------------+4 rows in set (0.00 sec) LIMIT m,n : 表示从第m+1条开始，取n条数据； LIMIT n ： 表示从第0条开始，取n条数据，是limit(0,n)的缩写。 SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。 最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行 INNER JOIN：如果表中有至少一个匹配，则返回行 SELECT column_name(s)FROM table1INNER JOIN table2ON table1.column_name=table2.column_name; 或： SELECT column_name(s)FROM table1JOIN table2ON table1.column_name=table2.column_name; LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name=table2.column_name; RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 SELECT column_name(s) FROM table1 RIGHT JOIN table2 ON table1.column_name=table2.column_name; FULL JOIN：只要其中一个表中存在匹配，则返回行 IN 操作符IN 操作符允许您在 WHERE 子句中规定多个值。 SQL IN 语法SELECT column_name(s)FROM table_nameWHERE column_name IN (value1,value2,…); SQL BETWEEN 操作符BETWEEN 操作符选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。 SQL BETWEEN 语法SELECT column_name(s)FROM table_nameWHERE column_name BETWEEN value1 AND value2; SQL 别名通过使用 SQL，可以为表名称或列名称指定别名。 基本上，创建别名是为了让列名称的可读性更强。 列的 SQL 别名语法SELECT column_name AS alias_nameFROM table_name; 表的 SQL 别名语法SELECT column_name(s)FROM table_name AS alias_name; SQL UNION 操作符 SQL UNION 操作符合并两个或多个 SELECT 语句的结果。 SQL UNION 操作符UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法SELECT column_name(s) FROM table1UNIONSELECT column_name(s) FROM table2; 注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 SQL UNION ALL 语法SELECT column_name(s) FROM table1UNION ALLSELECT column_name(s) FROM table2; 注释：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 MySQL 数据库不支持 SELECT … INTO 语句，但支持 INSERT INTO … SELECT 。 当然你可以使用以下语句来拷贝表结构及数据： 1CREATE TABLE 新表 SELECT * FROM 旧表]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InnoDB存储引擎索引]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F08%2FInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[InnoDB存储引擎索引InnoDB存储引擎支持以下几种索引 b+树索引 b+树索引是目前关系型数据库系统中查找最为常用和最为有效的索引。b+树索引不能找到给定的键值的具体行。只能找到被查找数据所在的页。然后数据库将这页读取到内存中，再在内存中进行查找，最后得到要查找的数据。 哈希索引 自适应哈希索引经哈希函数映射到一个哈希表中，因此对于字典类型的查找非常快速。但是对于范围查找就无能为力。通过命令SHOW ENGINE INNODB STZTUS可以看到当前自适应哈希索引的使用情况 全文索引 全文索引是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。它可以根据需要获得全文中有关章，节，段，句，词等信息，也可以进行各种统计和分析。 B+树索引聚集索引聚集索引是根据每张表的主键构造一棵b+树，同时叶子节点中存放的即为表中的行记录数据，也将聚集索引的叶子节点称为数据页。即索引组织表中数据也是索引的一部分。每数据页之间通过一个双向链表进行链接。按照主键排序，页中的数据也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。 优点：对于主键的排序查找和范围查找非常快。 辅助索引（非聚集索引）辅助索引（非聚集索引）叶子节点不包括行记录的所有数据。 叶子节点除了键值外还有一个书签，书签可以告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，所以InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。 每个表上可以有多个辅助索引。 聚集索引和辅助索引的不同 1.聚集索引叶子节点存整个表的行记录数据，而辅助索引没有存具体的数据而是存键值和一个指向具体数据的书签。 2.一个表中只有一个聚集索引，而有多个辅助索引。 索引的创建，删除 普通索引创建索引这是最基本的索引，它没有任何限制。它有以下几种创建方式： 1CREATE INDEX indexName ON mytable(username(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 修改表结构(添加索引)1ALTER table tableName ADD INDEX indexName(columnName) 创建表的时候直接指定123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引的语法1DROP INDEX [indexName] ON mytable; 唯一索引它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式： 创建索引1CREATE UNIQUE INDEX indexName ON mytable(username(length)) 修改表结构1ALTER table mytable ADD UNIQUE [indexName] (username(length)) 创建表的时候直接指定123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 使用ALTER 命令添加和删除索引有四种方式来添加数据表的索引： ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。 使用 ALTER 命令添加和删除主键主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下： 12mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i); 你也可以使用 ALTER 命令删除主键： 1mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY; 删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。 显示索引信息你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。 尝试以下实例: 1mysql&gt; SHOW INDEX FROM table_name; \G 全文索引倒排索引全文索引通常使用倒排索引实现的。 倒排索引在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。通常使用关联数组实现： 1.inverted file index，其表现形式为{单词，单词所在文档的ID} 2.full inverted index，其表现形式为{单词，（单词所在的文档ID，在具体文档中的位置）}]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 存储引擎MyISAM和InnoDB的区别]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F08%2Fmysql%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[mysql 存储引擎概述：数据库存储引擎是数据库底层软件组件，数据库管理系统（DBMS）使用数据引擎进行创建，查询，更新和删除数据操作。不同的存储引擎提供不同的存储机制，索引技巧，锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。 mysql提供了不同的存储引擎，mysql中不需要整个服务器用一个引擎，针对具体的要求，一个表可以用多个存储引擎。 InnoDB存储引擎 InnoDB事物型数据库首选的存储引擎，InnoDB主要特征： 1.InnoDB给mysql提供了具有提交，回滚，崩溃恢复能力的事物安全（ACID兼容）存储引擎。 2.InnoDB为了处理巨大数据量的最大性能设计。他的cpu效率相比与其他存储引擎是最好的。 3.InnoDB存储引擎完全与mysql服务器整合，InnoDB将索引和表放在一个逻辑表空间中，表空间可以包含数个文件。而MyISAM表中每个表被存在在分离的文件中。 4.InnoDB支持外键完整性约束。当表没有指定主键时，InnoDB会为每一行生成一个6字节的ROWID，并以此为主键。 5.InnoDB应用在众多需要高性能的大型数据库站点上。 InnoDB不创建目录，使用InnoDB时，MySQL在mysql数据目录下创建一个名为ibdata1的10mb大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5mb大小的日志文件。 MyISAM存储引擎 MyISAM基于ISAM，他是在web，数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入，查询速度，但不支持事务。每张MyISAM表存放在三个文件中：frm 文件存放表格定义；数据文件是MYD (MYData)；索引文件是MYI (MYIndex)。 MyISAM和InnoDB的区别： 一、InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。 二、MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用 三、InnoDB支持外键，MyISAM不支持 四、MyISAM是默认引擎，InnoDB需要指定 五、InnoDB不支持FULLTEXT类型的索引 六、InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表 七、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引 八、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表 九、InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’ 应用场景： MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。 InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。 常用命令： （1）查看表的存储类型（三种）： show create table tablename show table status from dbname where name=tablename mysqlshow -u user -p password –status dbname tablename （2）修改表的存储引擎： alter table tablename type=InnoDB （3）启动mysql数据库的命令行中添加以下参数使新发布的表都默认使用事务： –default-table-type=InnoDB （4）临时改变默认表类型： set table_type=InnoDB show variables like ‘table_type’ 参考：1.http://www.cnblogs.com/panfeng412/archive/2011/08/16/2140364.html 2.https://my.oschina.net/junn/blog/183341]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二高的薪水]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F07%2F176.%20%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[176. 第二高的薪水题目描述提示帮助提交记录社区讨论阅读解答 SQL架构随机一题 编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。 12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ 先排序再改名 1select (select distinct Salary from Employee order by Salary desc limit 1,1) as SecondHighestSalary; 使用 DISTINCT 关键词去重，否则报错]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合两个表]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F07%2F175.%20%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[175. 组合两个表题目描述提示帮助提交记录社区讨论阅读解答 SQL架构随机一题 表1: Person 12345678+-------------+---------+| 列名 | 类型 |+-------------+---------+| PersonId | int || FirstName | varchar || LastName | varchar |+-------------+---------+PersonId 是上表主键 表2: Address 123456789+-------------+---------+| 列名 | 类型 |+-------------+---------+| AddressId | int || PersonId | int || City | varchar || State | varchar |+-------------+---------+AddressId 是上表主键 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息： 1FirstName, LastName, City, State 使用left join连接两个表 123select p.FirstName, p.LastName, a.City, a.Statefrom Person p left join Address aon p.PersonId=a.PersonId; SQL LEFT JOIN 关键字LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json格式]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F07%2Fjson%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[json格式JSON 语法是 JavaScript 语法的子集。 JSON 语法规则JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 名称/值对JSON 数据的书写格式是：名称/值对。 名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值： 1&quot;firstName&quot; : &quot;John&quot; 这很容易理解，等价于这条 JavaScript 语句： 1firstName = &quot;John&quot; JSON 值JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null JSON 对象JSON 对象在花括号中书写： 对象可以包含多个名称/值对： 1&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125; 这一点也容易理解，与这条 JavaScript 语句等价： 12firstName = &quot;John&quot;lastName = &quot;Doe&quot; JSON 数组JSON 数组在方括号中书写： 数组可包含多个对象： 1234567&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;]&#125; 在上面的例子中，对象 “employees” 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。 JSON 使用 JavaScript 语法因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。 通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值： 例子12345var employees = [&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;: &quot;Carter&quot; &#125;]; 可以像这样访问 JavaScript 对象数组中的第一项： 1employees[0].lastName; 返回的内容是： 1Gates]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的层次遍历 II]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F06%2F107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II%2F</url>
    <content type="text"><![CDATA[107. 二叉树的层次遍历 II 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其自底向上的层次遍历为： 12345[ [15,7], [9,20], [3]] 解法： 使用队列来实现二叉树的层遍历。 1234567891011121314151617181920212223242526272829303132333435/** * 自下而上的层遍历 * 从叶子节点所在层到根节点所在的层，逐层从左向右遍历 * @param root * @return */public List&lt;List&lt;Integer&gt;&gt; cen1(TreeNode root)&#123; List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;(); if (root==null)&#123; return lists; &#125; LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;(); treeNodes.add(root); while(!treeNodes.isEmpty())&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); int size=treeNodes.size(); for (int i=0;i&lt;size;i++)&#123; TreeNode n=treeNodes.pop(); list.add(n.val); if (n.l!=null)&#123; treeNodes.add(n.l); &#125; if (n.r!=null)&#123; treeNodes.add(n.r); &#125; &#125; lists.add(list); &#125; List&lt;List&lt;Integer&gt;&gt; lists1=new ArrayList&lt;&gt;(); for(int i=lists.size()-1;i&gt;=0;i--)&#123; lists1.add(lists.get(i)); &#125; return lists1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的层次遍历1]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F06%2F102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[102. 二叉树的层次遍历给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 解法： 二叉树的层遍历使用队列，将节点放入队列中，当节点出队时判断该节点的左，右子树是否为空，如果不为空将其放入队列中，本题因为题目要求每次创建一个新的list将每一层的节点添加到list中，size为队列的大小，用来判断队列中的节点是否全部出来。 1234567891011121314151617181920212223242526272829/** * 自上而下层遍历 * @param root */public List&lt;List&lt;Integer&gt;&gt; cen2(TreeNode root)&#123; List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;(); if (root==null)&#123; return lists; &#125;//使用队列 LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;(); treeNodes.add(root); while(!treeNodes.isEmpty())&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); int size=treeNodes.size(); for (int i=0;i&lt;size;i++)&#123; TreeNode n=treeNodes.pop(); list.add(n.val); if (n.l!=null)&#123; treeNodes.add(n.l); &#125; if (n.r!=null)&#123; treeNodes.add(n.r); &#125; &#125; lists.add(list); &#125; return lists;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的创建，前序，中序，后序，层遍历]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F06%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%EF%BC%8C%E5%90%8E%E5%BA%8F%EF%BC%8C%E5%B1%82%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的创建，前序，中序，后序，层遍历深度优先搜素用栈，广度优先用队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256package T74;import sun.awt.image.ImageWatched;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Stack;public class BinTree &#123; private int size; /** * root为二叉树的头节点 */ private TreeNode root; private int [] date; BinTree(int [] date)&#123; this.date=date; this.size=date.length; this.root=CreatTree(0); &#125; class TreeNode&#123; TreeNode l; TreeNode r; int val; TreeNode(int val)&#123; this.val=val; &#125; &#125; /** *创建二叉树 * index为date数组的下标 * @param index */ public TreeNode CreatTree(int index)&#123; if (index&gt;=size)&#123; return null; &#125; TreeNode treeNode=new TreeNode(date[index]); treeNode.l=CreatTree(2*index+1); treeNode.r=CreatTree(2*(index+1)); return treeNode; &#125; /** * 递归实现前序遍历 * @param root */ public void qx(TreeNode root)&#123; if (root==null)&#123; return ; &#125; System.out.print(root.val+&quot; &quot;); qx(root.l); qx(root.r); &#125; /** * 用栈实现 * @param root */ public void qx1(TreeNode root)&#123; if (root==null)&#123; return ; &#125; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); while(root!=null||!stack.empty())&#123; while(root!=null)&#123; System.out.print(root.val+&quot; &quot;); stack.push(root); root=root.l; &#125; if (!stack.empty())&#123; root=stack.pop(); root=root.r; &#125; &#125; &#125; /** * 中序 递归 * @param root */ public void zx(TreeNode root)&#123; if (root!=null)&#123; zx(root.l); System.out.print(root.val+&quot; &quot;); zx(root.r); &#125; &#125; /** * 栈实现 中序 * @param root */ public void zx1(TreeNode root)&#123; if (root==null)&#123; return ; &#125; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); while (root!=null||!stack.empty())&#123; while(root!=null)&#123; stack.push(root); root=root.l; &#125; if (!stack.empty())&#123; root=stack.pop(); System.out.print(root.val+&quot; &quot;); root=root.r; &#125; &#125; &#125; /** * 递归 后序 * @param root */ public void hx(TreeNode root)&#123; if (root!=null)&#123; hx(root.l); hx(root.r); System.out.print(root.val+&quot; &quot;); &#125; &#125; /** * 栈实现 后序 * @param root */ public void hx1(TreeNode root)&#123; if (root==null)&#123; return ; &#125; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); //游标list指向节点的右子树，遍历完指向节点 TreeNode list=null; while(root!=null||!stack.empty())&#123; while(root!=null)&#123; stack.push(root); root=root.l; &#125; root=stack.peek(); //如果节点的右子树为空或者已经遍历完 if (root.r==null||root.r==list)&#123; System.out.print(root.val+&quot; &quot;); root=stack.pop(); list=root; root=null; &#125;else &#123; root=root.r; &#125; &#125; &#125; /** * 层遍历 * @param root */ public void cen(TreeNode root)&#123; if (root==null)&#123; return ; &#125; LinkedList&lt;TreeNode&gt; q=new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty())&#123; root=q.poll(); System.out.print(root.val+&quot; &quot;); if (root.l!=null)&#123; q.add(root.l); &#125; if (root.r!=null)&#123; q.add(root.r); &#125; &#125; &#125; /** * 自下而上的层遍历 * 从叶子节点所在层到根节点所在的层，逐层从左向右遍历 * @param root * @return */ public List&lt;List&lt;Integer&gt;&gt; cen1(TreeNode root)&#123; List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;(); if (root==null)&#123; return lists; &#125; LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;(); treeNodes.add(root); while(!treeNodes.isEmpty())&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); int size=treeNodes.size(); for (int i=0;i&lt;size;i++)&#123; TreeNode n=treeNodes.pop(); list.add(n.val); if (n.l!=null)&#123; treeNodes.add(n.l); &#125; if (n.r!=null)&#123; treeNodes.add(n.r); &#125; &#125; lists.add(list); &#125; List&lt;List&lt;Integer&gt;&gt; lists1=new ArrayList&lt;&gt;(); for(int i=lists.size()-1;i&gt;=0;i--)&#123; lists1.add(lists.get(i)); &#125; return lists1; &#125; /** * 自上而下层遍历 * @param root */ public List&lt;List&lt;Integer&gt;&gt; cen2(TreeNode root)&#123; List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;(); if (root==null)&#123; return lists; &#125; LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;(); treeNodes.add(root); while(!treeNodes.isEmpty())&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); int size=treeNodes.size(); for (int i=0;i&lt;size;i++)&#123; TreeNode n=treeNodes.pop(); list.add(n.val); if (n.l!=null)&#123; treeNodes.add(n.l); &#125; if (n.r!=null)&#123; treeNodes.add(n.r); &#125; &#125; lists.add(list); &#125; return lists; &#125; public static void main(String[] args) &#123; int [] date=new int[]&#123;1,2,3,4,5,6,7&#125;; BinTree tree=new BinTree(date); tree.hx(tree.root); System.out.println(); tree.hx1(tree.root); System.out.println(); tree.cen(tree.root); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的层次遍历]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F04%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的层次遍历给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 解法： 广度优先用队列 深度优先用栈 层次遍历是广度优先，所以用队列 使用队列实现树的分层遍历，先将树的头节点加入队列，然后将节点弹出队列，再判断这个节点的左子节点是否存在，如果存在加入队列，再判断这个节点的右子节点是否存在，如果存在加入队列。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; lists=new LinkedList&lt;&gt;(); if(root==null)&#123; return lists; &#125; //使用LinkedList实现队列 LinkedList&lt;TreeNode&gt; q=new LinkedList&lt;&gt;(); //将root加入队列 q.add(root); //遍历队列 while(!q.isEmpty())&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); //因为要分层输出，size为每层节点数 int size=q.size(); for (int i=0;i&lt;size;i++)&#123; TreeNode n=q.poll(); list.add(n.val); if (n.left!=null)&#123; q.add(n.left); &#125; if (n.right!=null)&#123; q.add(n.right); &#125; &#125; lists.add(list); &#125; return lists; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反转链表]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F07%2F04%2F%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转链表反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 递归实现：从后往前反转 12345678910111213public ListNode reverseList(ListNode head)&#123; //找到最后一个节点HEAD.NEXT if (head==null||head.next==null)&#123; return head; &#125; ListNode p=reverseList(head.next); //反转链表 head.next.next=head; //将head指向后一个节点的关系去掉 head.next=null; return p; &#125; 非递归：前往后 12345678910111213141516public ListNode sw(ListNode head)&#123; if (head==null)&#123; return head; &#125; //指向下一个节点 ListNode next=null; //反转后的头节点 ListNode pre=null; while(head!=null)&#123; next=head.next; head.next=pre; pre=head; head=next; &#125; return pre; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exchanger的使用]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FExchanger%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Exchanger的使用概述：Exchanger可以让两个线程之间进行数据交换。 使用：使用：1234567891011121314151617181920212223242526272829303132333435363738package T616;import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class exchangerTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); Exchanger exchanger = new Exchanger(); service.execute(new Runnable() &#123; @Override public void run() &#123; dow(exchanger, &quot;date1&quot;); &#125; &#125;); service.execute(new Runnable() &#123; @Override public void run() &#123; dow(exchanger, &quot;date2&quot;); &#125; &#125;); service.shutdown(); &#125; public static void dow(Exchanger exchanger, String date) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;-----&quot; + date); Thread.sleep((long) (Math.random() * 1000)); String date1 = (String) exchanger.exchange(date); System.out.println(Thread.currentThread().getName() + &quot;-----&quot; + date1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果： pool-1-thread-1—–date1pool-1-thread-2—–date2pool-1-thread-1—–date2pool-1-thread-2—–date1 分析： 线程1执行exchange方法后线程阻塞，等线程2当线程2执行exchange方法时，线程数据交换。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之Runnable、Callable、Future、FutureTask]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FJava%E5%B9%B6%E5%8F%91%E4%B9%8BRunnable%E3%80%81Callable%E3%80%81Future%E3%80%81FutureTask%2F</url>
    <content type="text"><![CDATA[Java并发之Runnable、Callable、Future、FutureTask原文：https://www.jianshu.com/p/cf12d4244171 Runnable123public interface Runnable &#123; public abstract void run();&#125; Runnable的代码非常简单，它是一个接口且只有一个run()，创建一个类实现它，把一些费时操作写在其中，然后使用某个线程去执行该Runnable实现类即可实现多线程。 Callable123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; Callable的代码也非常简单，不同的是它是一个泛型接口，call()函数返回的类型就是创建Callable传进来的V类型。 学习Callable对比着Runnable，这样就很快能理解它。Callable与Runnable的功能大致相似，Callable功能强大一些，就是被线程执行后，可以返回值，并且能抛出异常。 FutureFuture实现代码12345678910111213public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; Future是一个接口，定义了Future对于具体的Runnable或者Callable任务的执行结果进行取消、查询任务是否被取消，查询是否完成、获取结果。 Future基本用法：123456789101112131415161718192021class MyCallable implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; System.out.println(&quot;做一些耗时的任务...&quot;); Thread.sleep(5000); return &quot;OK&quot;; &#125;&#125;public class FutureSimpleDemo &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable()); System.out.println(&quot;dosomething...&quot;); System.out.println(&quot;得到异步任务返回结果：&quot; + future.get()); System.out.println(&quot;Completed!&quot;); &#125;&#125; 上面是Future基本用法的代码以及并运行，我们可以知道： 线程是属于异步计算模型，所以你不可能直接从别的线程中得到方法返回值。 这时候，Future就出场了。 Futrue可以监视目标线程调用call的情况，当你调用Future的get()方法以获得结果时，当前线程就开始阻塞，直接call方法结束返回结果。 Future引用对象指向的实际是FutureTask。 也就是说，总结一句话，Future可以得到别的线程任务方法的返回值。 FutureTaskFutureTask继承结构FutureTask的父类是RunnableFuture，而RunnableFuture继承了Runnbale和Futrue这两个接口 1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; 1public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; FutureTask构造方法123456public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; 1234public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125; 在这里我们可以了解到： FutureTask最终都是执行Callable类型的任务。 如果构造函数参数是Runnable，会被Executors.callable方法转换为Callable类型。 接下来我们看看Executors.callable方法代码 12345public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);&#125; 代码很简单，直接返回一个RunnableAdapter实例。 接下来我们看看RunnableAdapter方法代码 123456789101112131415/** * A callable that runs given task and returns given result */static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125;&#125; 可以了解到： RunnableAdapter是FutureTask的一个静态内部类并且实现了Callable，也就是说RunnableAdapter是Callable子类。 call方法实现代码是，执行Runnable的run方法，并返回构造FutureTask传入result参数。 FutureTask基本用法12345678910111213141516171819public class CallableAndFuture &#123; public static void main(String[] args) &#123; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123; public Integer call() throws Exception &#123; return new Random().nextInt(100); &#125; &#125;; FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable); new Thread(future).start(); try &#123; Thread.sleep(3000);// 可能做一些事情 System.out.println(future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; FutureTask总结FutureTask实现了两个接口，Runnable和Future，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值，那么这个组合的使用有什么好处呢？假设有一个很费时逻辑需要计算并且返回这个值，同时这个值不是马上需要，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到！ 注意：通过Executor执行线程任务都是以Callable形式，如果传入Runnable都会转化为Callable。 通过new Thread(runnable)，只能是Runnable子类形式。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock源码]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FReentrantLock%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ReentrantLock源码概述：重入锁,和与使用 synchronized方法差不多，但具有扩展功能的可重入互斥锁。 java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为 Java 类，而不是作为语言的特性来实现。这就为 Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。 ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM 可以花更少的时候来调度线程，把更多时间用在执行线程上。） ReentrantLock和synchronized比较比较 公平锁和非公平锁：公平锁使线程按照请求锁的顺序依次获得锁；而不公平锁则允许讨价还价，在这种情况下，线程有时可以比先请求锁的其他线程先得到锁。 源码：ReentrantLock构造 1234567public ReentrantLock() &#123; sync = new NonfairSync();&#125;//选择创建是否是公平锁public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 非公平锁 1234567891011121314151617181920//NonfairSync继承sync类static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** *执行锁步骤 */ final void lock() &#123; //使用cas操作将值从0变为1 if (compareAndSetState(0, 1)) //设置当前线程为锁的持有者 setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125;//尝试获取 protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 公平锁 123456789101112131415161718192021222324252627282930313233static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don&apos;t grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //判断队列中是否有其他的等待线程，如果没有则获取锁 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //判断当前线程是否是锁的持有者 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125;&#125; ReentrantLock类实现了Lock和java.io.Serializable接口 1234public class ReentrantLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync; 抽象Sync类继承了aqs，实同步现了锁的同步控制基础。分为公平和非公平版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; /** * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * 不公平尝试获取 */ final boolean nonfairTryAcquire(int acquires) &#123; //获取当前线程 final Thread current = Thread.currentThread(); //获得状态数值 int c = getState(); //如果为0 if (c == 0) &#123; //acqutres此时为1 if (compareAndSetState(0, acquires)) &#123; //设定当前线程拥有独占访问权限 setExclusiveOwnerThread(current); return true; &#125; &#125; //当前线程是否是由setExclusiveOwnerThread方法最后设定的线程 else if (current == getExclusiveOwnerThread()) &#123; //此时c为1，表示有锁，nextc为2 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125;//尝试释放 protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; protected final boolean isHeldExclusively() &#123; // While we must in general read state before owner, // we don&apos;t need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); &#125; final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; // Methods relayed from outer class final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; final boolean isLocked() &#123; return getState() != 0; &#125; /** * Reconstitutes the instance from a stream (that is, deserializes it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125;&#125;/** * 非公平锁 */static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * 锁实现 */ final void lock() &#123; //状态数值由0变为1 if (compareAndSetState(0, 1)) //设置当前线程是锁的持有者 setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 加锁和释放锁12345678//加锁public void lock() &#123; sync.lock();&#125;public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; 123public void unlock() &#123; sync.release(1);&#125; 总结：ReentrantLock是lock框架的一个抽象实现,是一个可重入的互斥锁，ReentranLock是通过sync实现的，sync又是继承aqs的，其内部又有公平锁和非公平锁类它们继承sync，它们实现了锁的公平获取和非公平获取的实现。 ​ 一个可重入的互斥锁定 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义，但功能更强大。ReentrantLock 将由最近成功获得锁定，并且还没有释放该锁定的线程所拥有。当锁定没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁定并返回。如果当前线程已经拥有该锁定，此方法将立即返回。可以使用 isHeldByCurrentThread() 和 getHoldCount() 方法来检查此情况是否发生。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore源码分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FSemaphore%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Semaphore源码分析semaphore（信号量）用来控制同时访问特定资源的线程数，在获得物品之前，每个线程必须从信号量获得许可证，以确保物品可供使用。 当线程完成该项目时，它将返回到池，并且许可证返回到信号量，允许另一个线程获取该项目。请注意，在调用acquire时不会同步锁定，因为这会阻止将项目返回到池中。 信号量封装了用于限制对池的访问所需的同步，与为保持池自身一致性所需的任何同步分开。 源码： 12345public class Semaphore implements java.io.Serializable &#123; private static final long serialVersionUID = -3222578661600680210L; //所有机制都通过AbstractQueuedSynchronizer子类 private final Sync sync; &#125; semaphore的内部类sync Sync类继承AQS，实现信号量的同步，使用AQS表示信号量，分为公平版本和非公平。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 1192457210091910933L; Sync(int permits) &#123; setState(permits); &#125; final int getPermits() &#123; return getState(); &#125; final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error(&quot;Maximum permit count exceeded&quot;); if (compareAndSetState(current, next)) return true; &#125; &#125; final void reducePermits(int reductions) &#123; for (;;) &#123; int current = getState(); int next = current - reductions; if (next &gt; current) // underflow throw new Error(&quot;Permit count underflow&quot;); if (compareAndSetState(current, next)) return; &#125; &#125; final int drainPermits() &#123; for (;;) &#123; int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; &#125; &#125;&#125; 12345678910111213141516/** * 非公平版本 *NonfairSync继承Sync类 */static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L;//设置许可证的数量 NonfairSync(int permits) &#123; //使用sync的构造器 super(permits); &#125;//尝试获取共享 protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125;&#125; FairSync和NonfairSync都继承sync，唯一不同的是再获取时FairSync类加了一个hasQueuedPredecessors判断，判断是否有线程在 AQS 的 Sync Queue 里面进行等待获取 。 1234567891011121314151617181920212223/** * 共平版本 *继承sync类 */static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125;&#125; 获取信号量 123456789101112//Semaphore的构造方法public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;//可响应中断的获取信号量 public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; //不可响应中断的获取信号量 public void acquireUninterruptibly() &#123; sync.acquireShared(1); &#125; 尝试获取信号量 12345678910111213141516171819public boolean tryAcquire() &#123; return sync.nonfairTryAcquireShared(1) &gt;= 0;&#125;//有时间限制的尝试获取信号量 public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125; //尝试获取一定的数量的信号量 public boolean tryAcquire(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); return sync.nonfairTryAcquireShared(permits) &gt;= 0; &#125; //在一定时间尝试获取一定数量的信号量 public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException &#123; if (permits &lt; 0) throw new IllegalArgumentException(); return sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout)); &#125; 释放信号量 12345678910111213//释放一定数量的信号量public void release(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.releaseShared(permits);&#125;//返回此信号量中当前可用的许可证数量 public int availablePermits() &#123; return sync.getPermits(); &#125;//获取并返回所有立即可用的许可证。public int drainPermits() &#123; return sync.drainPermits(); &#125; 获取等待的线程数量 1234//返回等待获取的线程数的估计值public final int getQueueLength() &#123; return sync.getQueueLength();&#125; 使用semaphore（信号量）通过控制对资源同步的访问的线程的数量，比如模拟一个停车场停车信号，假设停车场只有两个车位，一开始两个车位都是空的。这时如果同时来了两辆车，看门人允许它们进入停车场，然后放下车拦。以后来的车必须在入口等待，直到停车场中有车辆离开。这时，如果有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开一辆，则又可以放入一辆，如此往复。[参考]（https://www.jianshu.com/p/d1bfa69f864d） 12345678910111213141516171819202122232425262728293031323334353637package T616;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class ThreadTest &#123; public static void main(String[] args) &#123; ExecutorService service=Executors.newFixedThreadPool(5); Semaphore semaphore=new Semaphore(2); for (int i=0;i&lt;5;i++)&#123; Runnable runnable=new Runnable() &#123; @Override public void run() &#123; try &#123; semaphore.acquire(); System.out.println(&quot;进入&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; semaphore.release(); System.out.println(&quot;释放&quot;); &#125; &#125;; service.execute(runnable); &#125; service.shutdown(); &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal源码分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ThreadLocal源码分析概述早在 JDK 1.2 的版本中就提供 java.lang.ThreadLocal，ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 ThreadLocal类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。ThreadLoacl类中使用map存储数据，key为线程而value为变量副本。ThreadLocal类中有一个ThreadLocalMap内部类，用来存储副本key为线程，而value为变量的副本。 使用：1234567891011121314151617181920package T616;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;public class threadlocalTest &#123; public static void main(String[] args) &#123; ExecutorService service=Executors.newCachedThreadPool(); ThreadLocal&lt;String&gt; local=new ThreadLocal&lt;&gt;(); service.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;------&quot;+local.get()); local.set(&quot;dasa&quot;); System.out.println(Thread.currentThread().getName()+&quot;------&quot;+local.get()); &#125; &#125;); &#125;&#125; 结果：pool-1-thread-1——null pool-1-thread-1——dasa 结构图一个ThreadLocal存储多个线程 的副本 一个线程存在多个ThreadLocal 参考 源码：get方法 123456789101112131415public T get() &#123;//获得当前线程 Thread t = Thread.currentThread(); //使用ThreadLocalMap进行存储变量 ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; ThreadLocalMap类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415static class ThreadLocalMap &#123;//Entry类扩展了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;//weakReference弱参考对象，不妨碍他们的参照物被定型，定型，然后回收。 大多数弱引用常用于实现规范化映射 static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** 线程的副本**/ Object value;//使用线程做主键 Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; /** * Entry[]数组的默认大小，必须是2的倍数. */ private static final int INITIAL_CAPACITY = 16; /** * Entry数组. */ private Entry[] table; /** *表格大小 */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 /** * Set the resize threshold to maintain at worst a 2/3 load factor. */ private void setThreshold(int len) &#123; threshold = len * 2 / 3; &#125; /** * Increment i modulo len. */ private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; /** * Decrement i modulo len. */ private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1); &#125; /** * ThreadLocalMap的构造函数 */ ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; //创建一个容量为16的Entry数组 table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; /** * Construct a new map including all Inheritable ThreadLocals * from given parent map. Called only by createInheritedMap. * * @param parentMap the map associated with parent thread. */ private ThreadLocalMap(ThreadLocalMap parentMap) &#123; Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j &lt; len; j++) &#123; Entry e = parentTable[j]; if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); if (key != null) &#123; Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode &amp; (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; &#125; &#125; &#125; &#125; /** * Get the entry associated with key. This method * itself handles only the fast path: a direct hit of existing * key. It otherwise relays to getEntryAfterMiss. This is * designed to maximize performance for direct hits, in part * by making this method readily inlinable. * * @param key the thread local object * @return the entry associated with key, or null if no such */ private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; /** * Version of getEntry method for use when key is not found in * its direct hash slot. * * @param key the thread local object * @param i the table index for key&apos;s hash code * @param e the entry at table[i] * @return the entry associated with key, or null if no such */ private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null; &#125; /** * Set the value associated with key. * * @param key the thread local object * @param value the value to be set */ private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don&apos;t use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; /** * Remove the entry for key. */ private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125; &#125; /** * Replace a stale entry encountered during a set operation * with an entry for the specified key. The value passed in * the value parameter is stored in the entry, whether or not * an entry already exists for the specified key. * * As a side effect, this method expunges all stale entries in the * &quot;run&quot; containing the stale entry. (A run is a sequence of entries * between two null slots.) * * @param key the key * @param value the value to be associated with key * @param staleSlot index of the first stale entry encountered while * searching for key. */ private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn&apos;t find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125; /** * Expunge a stale entry by rehashing any possibly colliding entries * lying between staleSlot and the next null slot. This also expunges * any other stale entries encountered before the trailing null. See * Knuth, Section 6.4 * * @param staleSlot index of slot known to have null key * @return the index of the next null slot after staleSlot * (all between staleSlot and this slot will have been checked * for expunging). */ private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i; &#125; /** * Heuristically scan some cells looking for stale entries. * This is invoked when either a new element is added, or * another stale one has been expunged. It performs a * logarithmic number of scans, as a balance between no * scanning (fast but retains garbage) and a number of scans * proportional to number of elements, that would find all * garbage but would cause some insertions to take O(n) time. * * @param i a position known NOT to hold a stale entry. The * scan starts at the element after i. * * @param n scan control: &#123;@code log2(n)&#125; cells are scanned, * unless a stale entry is found, in which case * &#123;@code log2(table.length)-1&#125; additional cells are scanned. * When called from insertions, this parameter is the number * of elements, but when from replaceStaleEntry, it is the * table length. (Note: all this could be changed to be either * more or less aggressive by weighting n instead of just * using straight log n. But this version is simple, fast, and * seems to work well.) * * @return true if any stale entries have been removed. */ private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed; &#125; /** * Re-pack and/or re-size the table. First scan the entire * table removing stale entries. If this doesn&apos;t sufficiently * shrink the size of the table, double the table size. */ private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize(); &#125; /** * Double the capacity of the table. */ private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab; &#125; /** * Expunge all stale entries in the table. */ private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j); &#125; &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池线程池：一种线程使用模式。线程过多会带来调度的开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。 结构图 Executors1.固定数量大小的线程池创建一个固定数量大小的线程池，nThreads为创建线程池最大的线程数。如果在所有线程处于活动状态时提交其他任务，他们将在队列中等待，直到线程可用。 , 如果任何线程在执行期间由于失败而终止在关闭之前，如果需要执行后续任务，则新的线程将取代它。, 池中的线程将存在*，直到它明确地shutdown。 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 创建一个固定大小的线程池 123456789101112131415public static void main(String[] args) &#123; ExecutorService executor= Executors.newCachedThreadPool(); int i=0; while(i&lt;4)&#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("线程:"+"-----"+Thread.currentThread().getName()); &#125; &#125;); i++; &#125; executor.shutdown(); &#125; 线程可复用 123456789101112131415161718192021public static void main(String[] args) &#123; ExecutorService executor= Executors.newCachedThreadPool(); int i=0; while(i&lt;4)&#123; //线程休眠 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; executor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;线程:&quot;+&quot;-----&quot;+Thread.currentThread().getName()); &#125; &#125;); i++; &#125; executor.shutdown(); &#125; 2.单线程化线程池创建一个单线程化线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 实现： 123456789101112131415public static void main(String[] args) &#123; ExecutorService executor = Executors.newSingleThreadExecutor(); int i = 0; while (i &lt; 4) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("线程：--------"+Thread.currentThread().getName()); &#125; &#125;); i++; &#125; executor.shutdown();&#125; 结果： 线程：——–pool-1-thread-1线程：——–pool-1-thread-1线程：——–pool-1-thread-1线程：——–pool-1-thread-1 3.可缓存线程池需要多少线程就创建多少，线程可以重用，如果有未使用60秒的线程将终止并从缓存中删除，如果没有可用线程则创建新的。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 创建一个可缓存线程池 1234567891011121314151617181920public static void main(String[] args) &#123; ExecutorService executor = Executors.newCachedThreadPool(); int i = 0; while (i &lt; 4) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("线程:" + "-----" + Thread.currentThread().getName()); &#125; &#125;); try &#123; Thread.sleep(60 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; i++; &#125; executor.shutdown(); &#125; 因为sleep的时间超过60秒，所以不会创建新的线程没有sleep时创建的线程 4.可延时执行的线程池创建一个单线程执行程序，可以调度命令在给定的延迟后运行，或定期执行。 1234public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1)); &#125; 实现： 创建固定大小线程池，延迟10执行，每3秒执行一次。 123456789101112131415public static void main(String[] args) &#123; ExecutorService executor = Executors.newScheduledThreadPool(4); int i = 0; while (i &lt; 4) &#123; ((ScheduledExecutorService) executor).scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println("线程:" + "-----" + Thread.currentThread().getName()); &#125; &#125;,10,3,TimeUnit.SECONDS); i++; &#125; executor.shutdown(); &#125; 线程:—–pool-1-thread-1线程:—–pool-1-thread-1线程:—–pool-1-thread-1线程:—–pool-1-thread-1线程:—–pool-1-thread-2线程:—–pool-1-thread-1线程:—–pool-1-thread-4线程:—–pool-1-thread-3 延时执行 12345678910111213141516public static void main(String[] args) &#123; ExecutorService executor = Executors.newScheduledThreadPool(4); int i = 0; while (i &lt; 4) &#123; ((ScheduledExecutorService) executor).schedule(new Runnable() &#123; @Override public void run() &#123; System.out.println("线程:" + "-----" + Thread.currentThread().getName()); &#125; //延时3秒执行 &#125;,3,TimeUnit.SECONDS); i++; &#125; executor.shutdown();&#125; ThreadPoolExecutor类实现： 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 构造方法 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中； maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程； keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0； unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性： 1234567TimeUnit.DAYS; //天TimeUnit.HOURS; //小时TimeUnit.MINUTES; //分钟TimeUnit.SECONDS; //秒TimeUnit.MILLISECONDS; //毫秒TimeUnit.MICROSECONDS; //微妙TimeUnit.NANOSECONDS; //纳秒 workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择： 123ArrayBlockingQueue;LinkedBlockingQueue;SynchronousQueue; ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。 threadFactory：线程工厂，主要用来创建线程； handler：表示当拒绝处理任务时的策略，有以下四种取值： 1234ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 实现：线程池执行流程图 1，首先线程池判断基本线程池是否已满（&lt; corePoolSize ？）？没满，创建一个工作线程来执行任务。满了，则进入下个流程。 2，其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。 3，最后线程池判断整个线程池是否已满（&lt; maximumPoolSize ？）？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。 总结：线程池优先要创建出基本线程池大小（corePoolSize）的线程数量，没有达到这个数量时，每次提交新任务都会直接创建一个新线程，当达到了基本线程数量后，又有新任务到达，优先放入等待队列，如果队列满了，才去创建新的线程（不能超过线程池的最大数maxmumPoolSize） 线程池提交任务的两种方法： 1.execute（）方法 execute()方法没有返回值，也不能确定任务是否被线程池执行成功。 2.submit（）方法 submit方法具有返回值，会返回一个Future对象，再通过Future的get方法获得结果，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。 线程的关闭： 1.shutdown() shutdown方法不是直接就关闭线程池，再也不接受新任务，而是等任务队列里面的执行完，再关闭线程池。 2.shutdownNow()：立即终止线程池，再也不会接受新的任务，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务 。 线程池状态： 12345private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 1，当创建线程池后，初始时，线程池处于RUNNING状态； 2，如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕，最后终止； 3，如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务，返回没有执行的任务列表； 4，当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。 手动创建线程池：1234567891011121314public static void main(String[] args) &#123; ExecutorService executor = new ThreadPoolExecutor(3, 5, 10L, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;()); for (int i = 0; i &lt; 5; i++) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("----" + Thread.currentThread().getName()); &#125; &#125;); &#125;&#125; 使用Future和FutureTask&lt;&gt;与callable获得执行结果 12345678910111213141516171819202122232425 public static void main(String[] args) &#123; ExecutorService executor = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 3; i++) &#123;// Future future=executor.submit(new play1()); FutureTask&lt;String&gt; task=new FutureTask&lt;String&gt;(new play1()); executor.submit(task); try &#123;// System.out.println(future.get()); System.out.println(task.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class play1 implements Callable&lt;String&gt;&#123; @Override public String call() &#123; return "线程：-----"+Thread.currentThread().getName(); &#125; &#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CyclicBarrier源码分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FCyclicBarrier%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CyclicBarrier源码分析概述：cyclicbarrier同步屏障，它是一种同步协助，它允许一组线程等待彼此以达到共同的障碍点。CyclicBarriers 在涉及固定大小的线程的程序中非常有用，它必须偶尔等待对方，该屏障称为循环，因为它可以在等待线程释放后重新使用。 CyclicBarrier 好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。 构造函数parties爆发量，barrierAction当屏障被触发时执行的命令，如果没有任何操作，则执行{null} 12345678910public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;public CyclicBarrier(int parties) &#123; this(parties, null); &#125; 类的方法123456789101112131415161718public class CyclicBarrier &#123;private static class Generation &#123; boolean broken = false;&#125;//可重入锁private final ReentrantLock lock = new ReentrantLock();//条件队列private final Condition trip = lock.newCondition();//参与的线程数private final int parties;//屏障打开时运行的操作private final Runnable barrierCommand;//当前代private Generation generation = new Generation();//在屏障里等待的线程数量private int count;&#125; await方法1234567public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125; dowait方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; //使用了ReentrantLock（重入锁） final ReentrantLock lock = this.lock; lock.lock(); try &#123; //代 final Generation g = generation; if (g.broken) throw new BrokenBarrierException();//如果线程中断 if (Thread.interrupted()) &#123; //将当前的屏障生成设置为中断并唤醒每个人 breakBarrier(); throw new InterruptedException(); &#125;//到达屏障临界点的剩余线程数 int index = --count; if (index == 0) &#123; // tripped跳闸 boolean ranAction = false; try &#123; final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; //更新屏障状态，并且唤醒所有等待线程 nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) //将当前的屏障生成设置为中断，并唤醒每一个人 breakBarrier(); &#125; &#125; // loop until tripped, broken, interrupted, or timed out循环直到跳闸，断开，中断或超时 for (;;) &#123; try &#123; if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; // We&apos;re about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // &quot;belong&quot; to subsequent execution. Thread.currentThread().interrupt(); &#125; &#125; if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 可见CyclicBarrier是基于ReentrantLock(重入锁)实现的。 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package T616;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class cyclicBarrier &#123; public static void main(String[] args) &#123; CyclicBarrier barrier=new CyclicBarrier(3,new main1());/* * 等待开门的线程 */ new Thread(new play(1,barrier)).start(); new Thread(new play(2,barrier)).start(); new Thread(new play(3,barrier)).start(); &#125; static class main1 implements Runnable&#123; main1()&#123; &#125; @Override public void run() &#123; System.out.println(&quot;main&quot;); &#125; &#125; static class play implements Runnable&#123; CyclicBarrier barrier; int id; play(int id,CyclicBarrier barrier)&#123; this.barrier=barrier; this.id=id; &#125; @Override public void run() &#123; try &#123; System.out.println(id+&quot;------&quot;+Thread.currentThread().getName()+&quot;完成&quot;); barrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AbstractQueuedSynchronizer(AQS)]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FAbstractQueuedSynchronizer(AQS)%2F</url>
    <content type="text"><![CDATA[AbstractQueuedSynchronizer(AQS)什么是AQS提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器。是用来构建锁或者其他同步组件的基础框架。 synchronized 同步和AQSsynchronized 同步，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码需要关联到一个监视对象，当线程执行 monitorenter 指令时，需要首先获得获得监视对象的锁，这里监视对象锁就是进入同步块的凭证，只有获得了凭证才可以进入同步块，当线程离开同步块时，会执行 monitorexit 指令，释放对象锁。 在 AQS 同步中，使用一个 int 类型的变量 state 来表示当前同步块的状态。以独占式同步（一次只能有一个线程进入同步块）为例，state 的有效值有两个 0 和 1，其中 0 表示当前同步块中没有线程，1 表示同步块中已经有线程在执行。当线程要进入同步块时，需要首先判断 state 的值是否为 0，假设为 0，会尝试将 state 修改为 1，只有修改成功了之后，线程才可以进入同步块。注意上面提到的两个条件： state 为 0，证明当前同步块中没有线程在执行，所以当前线程可以尝试获得进入同步块的凭证，而这里的凭证就是是否成功将 state 修改为 1（在 synchronized 同步中，我们说的凭证是对象锁，但是对象锁的最终实现是否和这种方式类似，没有找到相关的资料） 成功将 state 修改为 1，通过使用 CAS 操作，我们可以确保即便有多个线程同时修改 state，也只有一个线程会修改成功。关于 CAS 的具体解释会在后面提到。 当线程离开同步块时，会修改 state 的值，将其设为 0，并唤醒等待的线程。所以在 AQS 同步中，我们说线程获得了锁，实际上是指线程成功修改了状态变量 state，而线程释放了锁，是指线程将状态变量置为了可修改的状态（在独占式同步中就是置为了 0），让其他线程可以再次尝试修改状态变量。在下面的表述中，我们说线程获得和释放了锁，就是上述含义， 这与 synchronized 同步中说的获得和释放锁的含义不同，需要区别理解 原文 AQS原理AQS的实现是依赖内部的同步队列（FIFO双向队列） ，如果当前线程获取同步状态失败，AQS会将线程以及等待状态等信息构成一个node，将其加到队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。 123 +------+ prev +-----+ +-----+* head | | &lt;---- | | &lt;---- | | tail* +------+ +-----+ +-----+ AQS结构图 源码node内部类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889static final class Node &#123; /** 标记以指示节点正在以共享模式等待 */ static final AbstractQueuedSynchronizer.Node SHARED = new AbstractQueuedSynchronizer.Node(); /** 标记以指示节点正在以独占模式等待 */ static final AbstractQueuedSynchronizer.Node EXCLUSIVE = null; // 结点状态 // CANCELLED，值为1，表示当前的线程被取消 // SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark // CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中 // PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行 // 值为0，表示当前节点在sync队列中，等待着获取锁 static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; /** * 状态字段只取下面的值： * SIGNAL: 该节点的后继者（或将很快）被阻塞（通过park），因此当前节点必须在释放或取消后取消其继任者。 * 为了避免竞争，获取方法必须首先表明他们需要一个信号，然后重试原子捕获，然后在失败时阻止阻塞 * CANCELLED: 由于超时或中断，此节点被取消。 * 节点永远不会离开这个状态。, 尤其是，具有取消节点的线程不会再次阻塞。 * CONDITION: 该节点当前处于条件队列中。 * PROPAGATE: releaseShared应该传播到其他*节点。 * 在doReleaseShared中设置这个（仅用于头节点）以确保传播继续，即使其他操作自干预以来也有*。 * 0: None of the above */ volatile int waitStatus; /** * 链接到当前节点/线程依赖*的前驱节点来检查waitStatus。 */ volatile AbstractQueuedSynchronizer.Node prev; /** * 链接到当前节点/线程*在释放后停止的后继节点。 */ volatile AbstractQueuedSynchronizer.Node next; /** * 排入此节点的线程。初始化施工并在使用后清空 */ volatile Thread thread; /** * 链接到下一个节点等待条件，或者特殊*值SHARED。 * 因为条件队列只有在独占模式下才被访问，所以我们只需要一个简单的*链接队列来等待*条件下的节点。 * 然后他们被转移到队列重新获得。 由于条件只能是排他性的，我们通过使用特殊值来保存字段以指示共享模式。 */ AbstractQueuedSynchronizer.Node nextWaiter; /** * 如果节点在共享模式下等待，则返回true。 */ final boolean isShared() &#123; return nextWaiter == SHARED; &#125; /** * 返回前一个节点，如果为null则抛出NullPointerException。 * 前驱不能为空时使用。, 空检查可能会被忽略，但是可以帮助虚拟机。 * * @return the predecessor of this node */ final AbstractQueuedSynchronizer.Node predecessor() throws NullPointerException &#123; AbstractQueuedSynchronizer.Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, AbstractQueuedSynchronizer.Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; AbstractQueuedSynchronizerAbstractQueuedSynchronizer类继承AbstractOwnableSynchronizer类，AbstractOwnableSynchronizer类同步器可能由线程专有。 这个类提供了创建锁和相关同步器的基础，这可能需要拥有所有权。 , AbstractOwnableSynchronizer类本身不管理或使用这些信息。 但是，子类和工具可以使用适当维护的值来帮助控制和监视访问并提供诊断。 1234567891011121314151617181920212223242526272829303132333435363738//队列头节点private transient volatile Node head;//尾节点private transient volatile Node tail;//同步状态 private volatile int state; //获得同步状态 protected final int getState() &#123; return state; &#125; //设置同步状态protected final void setState(int newState) &#123; state = newState; &#125;/**变更同步状态，基于cas操作，比较expect的值与存储位置的值是否相等*相等就将值变为update*/protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); &#125;//将节点插入队列 private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; AbstractOwnableSynchronizer类 12345678910111213/** *设置当前拥有独占访问权限的线程。 */protected final void setExclusiveOwnerThread(Thread thread) &#123; exclusiveOwnerThread = thread;&#125;/** * 返回最后由setExclusiveOwnerThread设置的线程，如果从未设置，则返回null。此方法不会以其他方式强制执行任何同步或字段访问。返回所有者线程 */protected final Thread getExclusiveOwnerThread() &#123; return exclusiveOwnerThread;&#125; 123public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; CountDownLatch源码概述：一个同步协助，允许一个或多个线程等待，直到完成其他线程中正在执行的一组操作。 源码：1234567891011121314151617181920212223242526272829303132private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125;/** * 重写 AQS 中的 tryAcquireShared * 尝试获取共享锁，如果当前 state 等于 0 返回 1 表示获取成功，否 则返回 -1 表示失败 */ protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; /** * 重写 AQS 中的 tryReleaseShared */ protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CountDownLatch分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F28%2FCountDownLatch%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CountDownLatch分析什么是CountDownLatchCountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。 CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。 使用AQS状态来表示计数，AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架 。 实现内部类 Sync继承AQS 123456789101112131415161718192021222324252627private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125; protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125;&#125; 1234public class CountDownLatch &#123; // 同步队列 private final Sync sync;&#125; 有参构造 1234567public CountDownLatch(int count) &#123;//如果count小于0时则返回IllegalArgumentException if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;); //初始化状态数 this.sync = new Sync(count);&#125; 无参构造 减少锁存器计数，如果计数为零，释放所有的等待的线程 123public void countDown() &#123; sync.releaseShared(1); &#125; await方法 等待锁存器计数为零时，再释放当前线程 123456public void await() throws InterruptedException &#123;//使用了aqs的方法//在共享模式下获取，如果中断则中止 sync.acquireSharedInterruptibly(1);&#125; 123456789//在共享模式下获取，如果中断则中止public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) //设置中断 doAcquireSharedInterruptibly(arg); &#125; doAcquireSharedInterruptibly方法 12345678910111213141516171819202122232425262728293031private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 添加节点至等待队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // 无限循环 // 获取node的前驱节点 final Node p = node.predecessor(); if (p == head) &#123; // 前驱节点为头结点 // 试图在共享模式下获取对象状态 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // 获取成功 // 设置头结点并进行繁殖 setHeadAndPropagate(node, r); // 设置节点next域 p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // 在获取失败后是否需要禁止线程并且进行中断检查 // 抛出异常 throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; await（long timeout, TimeUnit unit）方法 导致当前线程等待，直到锁存器计数到为零，除非线程中断，或经过了指定的等待时间 12345//尝试以共享模式获取，如果中断则中止，如果超时，则失败。public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));&#125; 使用： 1234567891011121314151617181920212223242526272829303132333435363738394041package T616;import java.util.concurrent.CountDownLatch;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class threadTst &#123; public static void main(String[] args) &#123; CountDownLatch end=new CountDownLatch(3); new Thread(new play1(1,end)).start(); new Thread(new play1(2,end)).start(); new Thread(new play1(3,end)).start(); try &#123; end.await(); System.out.println(&quot;main&quot;+&quot;****&quot;+Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class play1 implements Runnable&#123; int id; CountDownLatch end; public play1(int id,CountDownLatch end)&#123; this.id=id; this.end=end; &#125; @Override public void run() &#123; try &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+&quot;----&quot;+id); end.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 1234Thread-1----2Thread-0----1Thread-2----3main****main]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现strStr()]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F27%2F%E5%AE%9E%E7%8E%B0strStr()%2F</url>
    <content type="text"><![CDATA[实现strStr()实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2: 12输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf()) 定义相符。 解法： 子字符串为空直接返回0，母字符串为空没有，返回-1，只要遍历母字符串-子字符串次数既可以，当haystack和needle的字符不同时，break，当j遍历到子字符串屁股时，返回i就是第一个出现的位置。 123456789101112131415161718192021222324class Solution &#123; public int strStr(String haystack, String needle) &#123; if (needle.isEmpty())&#123; return 0; &#125; if (haystack.isEmpty())&#123; return -1; &#125; int m=haystack.length(); int n=needle.length(); for (int i=0;i&lt;=m-n;i++)&#123; int j=0; for (;j&lt;n;j++)&#123; if (haystack.charAt(i+j)!=needle.charAt(j))&#123; break; &#125; &#125; if (j==n)&#123; return i; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F27%2Fjava%E7%9A%84%E5%BC%BA%EF%BC%8C%E8%BD%AF%EF%BC%8C%E5%BC%B1%EF%BC%8C%E8%99%9A%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[java的强，软，弱，虚引用借鉴]]></content>
  </entry>
  <entry>
    <title><![CDATA[字符串转整数（atoi）]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F25%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%EF%BC%88atoi%EF%BC%89%2F</url>
    <content type="text"><![CDATA[字符串转整数（atoi）实现 atoi，将字符串转为整数。 在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。 当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。 若函数不能执行有效的转换，返回 0。 说明： 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。如果数值超过可表示的范围，则返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 12输入: &quot;42&quot;输出: 42 示例 2: 1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4: 1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解法： 我的解法 1.使用String类的trim方法去掉空格。 2.判断字符串，如果是+，-，和0到9的数则添加到StringBuilder中，否则返回0。 3.直接用Integer中的parseInt方法将String转化成int类型，这一步如果大于或小于Integer边界会报错，在这用了try，catch。 4.根据第一个是正负号判断返回MIN_VALUE还是MAX_VALUE。 本地好使，但是leetcode跑不过 123456789101112131415161718192021222324252627public static int myAtoi(String str) &#123; if (str == null||str.length()==0) &#123; return 0; &#125; String str1 = str.trim(); StringBuilder st1 = new StringBuilder(str1.length()); int i = 0; while (i &lt; str1.length()) &#123; if (!(str1.charAt(i) &gt;= &apos;0&apos; &amp;&amp; str1.charAt(i) &lt;= &apos;9&apos; || str1.charAt(i) == &apos;-&apos;)) &#123; return 0; &#125; st1.append(str1.charAt(i)); i++; &#125; int re = 0; try &#123; re=Integer.parseInt(st1.toString()); &#125; catch (Exception e) &#123; if (st1.toString().charAt(0) == &apos;-&apos;) &#123; return Integer.MIN_VALUE; &#125; return Integer.MAX_VALUE; &#125; return re; &#125; 其他解法: 123456789101112131415161718192021public int myAtoi(String str) &#123; str = str.trim(); int result = 0; boolean isPos = true; for(int i = 0; i &lt; str.length(); i++)&#123; char c = str.charAt(i); if(i==0 &amp;&amp; (c==&apos;-&apos;||c==&apos;+&apos;))&#123; isPos = c==&apos;+&apos;?true:false; &#125; else if (c&gt;=&apos;0&apos; &amp;&amp; c&lt;=&apos;9&apos;)&#123; // 检查溢出情况 if(result&gt;(Integer.MAX_VALUE - (c - &apos;0&apos;))/10)&#123; return isPos? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; result *= 10; result += c - &apos;0&apos;; &#125; else &#123; return isPos?result:-result; &#125; &#125; return isPos?result:-result; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证回文字符串]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F23%2F%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[验证回文字符串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 解法： 用两个指针一个放在头，一个放在屁股，比较就行。这题比较麻烦的是只考虑字母和数字字符，可以忽略字母的大小写。 1234567891011121314151617181920212223242526public static boolean isPalindrome(String s) &#123; if (s == null) &#123; return false; &#125; StringBuilder s1 = new StringBuilder(); int i = 0;//大写转化为小写 String str=s.toLowerCase(); //去除除去字母和数字字符 while (i&lt;str.length()) &#123; if (str.charAt(i)&gt;=&apos;a&apos;&amp;&amp;str.charAt(i)&lt;=&apos;z&apos;||(str.charAt(i)&lt;=&apos;9&apos;&amp;&amp;str.charAt(i)&gt;=&apos;0&apos;))&#123; s1.append(str.charAt(i)); &#125; i++; &#125; int j = s1.length() - 1; int m=0; while (m &lt; j) &#123; if (s1.charAt(j) != s1.charAt(m)) &#123; return false; &#125; m++; j--; &#125; return true;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有效的字母异位词]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F19%2F%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[有效的字母异位词给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 解法：使用长度为26的两个数组分别存储字符串s和字符串t，然后将两个数组进行比较。 123456789101112131415161718192021class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s==null||t==null||s.length()!=t.length())&#123; return false; &#125; int [] z=new int[26]; int [] z2=new int[26]; for (int i=0;i&lt;s.length();i++)&#123; z[s.charAt(i)-'a']++; &#125; for (int i=0;i&lt;t.length();i++)&#123; z2[t.charAt(i)-'a']++; &#125; for (int i=0;i&lt;26;i++)&#123; if (z[i]!=z2[i])&#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串中的第一个唯一字符]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F18%2F2018-06-18-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[字符串中的第一个唯一字符 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例: 12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 注意事项：您可以假定该字符串只包含小写字母。 解法：因为字母有26个所以用一个长度为26的int数组来存储字符串转化的char数组 123456789101112131415public static int firstUniqChar(String s) &#123; if (s==null)&#123; return -1; &#125; int [] a=new int[26]; for (int i=0;i&lt;s.length();i++)&#123; a[s.charAt(i)-&apos;a&apos;]++; &#125; for (int i=0;i&lt;s.length();i++)&#123; if (a[s.charAt(i)-&apos;a&apos;]==1)&#123; return i; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单件模式]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F18%2F%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单件模式概述用来创建一个独一无二的，只有一个实例的对象的入场券。有些对象其实我们只需要一个就行，比如：线程池，缓存，对话框等。可以利用一个私有的构造器，和一个静态方法，一个静态变量实现单例模式。 实现延迟实例化： 12345678910111213//在单线程下可用public class danli &#123; private static danli mydanli; private danli()&#123; &#125; public static danli getMydanli()&#123; if (mydanli==null)&#123; mydanli=new danli(); &#125; return mydanli; &#125;&#125; 单件模式：确保一个类只有一个实例，并提供一个全局访问点。 利用延迟实例化的方式创建单件，这种做法对资源敏感的对象特别重要。 多线程情况多线程情况下使用上面的代码，会创建不止一个对象。 解决方法1.使用synchronized关键字将getMydanli（）变成同步，但对性能可能有影响。123456789101112public class danli &#123; private static danli mydanli; private danli()&#123; &#125; public static synchronized danli getMydanli()&#123; if (mydanli==null)&#123; mydanli=new danli(); &#125; return mydanli; &#125;&#125; 2.使用“急切”创建实例，而不用延迟实例化的做法。 12345678910public class danli &#123; //在静态初始化器中创建单件，确保线程安全 private static danli mydanli=new danli(); private danli()&#123; &#125; public static danli getMydanli()&#123; return mydanli; &#125;&#125; 3.用“双重检查加锁”，在 getMydanli（）中减少使用同步 这个做法可以大大的减少getMydanli()的时间消耗 1234567891011121314151617181920212223242526public class danli &#123; /** * volatile关键词确保，当mydanli变量被初始化成danli的实例时 * 多个线程正确的处理mydanli变量 */ private volatile static danli mydanli; private danli() &#123; &#125; public static danli getMydanli() &#123; /** * 只有第一次才彻底执行这里的代码。 */ if (mydanli == null) &#123; synchronized (danli.class) &#123; if (mydanli == null) &#123; mydanli = new danli(); &#125; &#125; &#125; return mydanli; &#125;&#125; 要点 单件模型确保程序中一个类最多只有一个实例。 单件模型也提供访问这个实例的全局点。 在java中实现单件模式需要一个私有的构造器，一个静态方法，一个静态变量。 确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，已解决多线程问题 使用多个类加载器可能导致单件失效而产生多个实例]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颠倒整数]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2F2018-06-17-%E9%A2%A0%E5%80%92%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个 32 位有符号整数，将整数中的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 解法 将int转化为String再转化为char数组,然后使用两个指针将char数组的值进行翻转， 再使用Integer.parseInt（）方法将String转化成int类型。 123456789101112131415161718192021222324252627class Solution &#123; public int reverse(int x) &#123; if (x&gt;Integer.MAX_VALUE||x&lt;Integer.MIN_VALUE)&#123; return 0; &#125; String a = Integer.toString(x); char[] chars = a.toCharArray(); int i = 0; int j = chars.length - 1; if (x&lt;0)&#123; i++; &#125; while (i &lt; j) &#123; char tmp = chars[i]; chars[i] = chars[j]; chars[j] = tmp; i++; j--; &#125; String str = new String(chars); try &#123; return Integer.parseInt(str); &#125;catch (Exception e)&#123; return 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 和 Vector比较]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayList 和 Vector比较ArrayListArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。 123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ArrayList类继承了AbstractList类实现了List这个*接口的用户可以精确控制列表中每个元素插入的位置。, 用户可以通过其整数索引（列表中的位置）访问元素，并在列表中搜索元素, RandomAccess支持快速的随机法访问, Cloneable允许clone, java.io.Serializable可序列化接口. 实现ArrayList的元素存储在其中的数组缓冲区，底层使用的是一个Object[]数组。 1transient Object[] elementData; // non-private to simplify nested class access 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 构造初始容量为10的空列表。 contains方法123public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; indexof方法123456789101112131415//如果数组中有o则返回第一个下标，否则返回-1public int indexOf(Object o) &#123;//因为ArrayList中可以为null if (o == null) &#123; //遍历查找 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; lastIndexOf方法12345678910111213//数组中有o返回最后一个下标public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; get方法12345678//返回列表指定位置的元素public E get(int index) &#123;//检查给定索引是否在范围内。, 如果不是，则抛出一个适当的运行时异常。//索引为负的化会抛出ArrayIndexOutOfBoundsException rangeCheck(index);//elementData数组获取 return elementData(index);&#125; set方法12345678//使用element更换列表指定位置的元素public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 扩容123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //扩容为原来的1.5倍大小 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; Fail-Fast 机制ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。 关于 Fail-Fast 的更详细的介绍，我在之前将 HashMap 中已经提到。 VectorVector类实现了一个动态数组。和ArrayList和相似，但是两者是不同的： Vector是同步访问的。 Vector包含了许多传统的方法，这些方法不属于集合框架。 Vector主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 1234public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; Vector类继承AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable接口和ArrayList相同。 123456789101112131415//构造一个空向量，使其内部数据数组的大小为10码，其标准容量增量为零。public Vector() &#123; this(10);&#125; public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); // initialCapacity初始容量 this.elementData = new Object[initialCapacity]; //capacityIncrement当矢量溢出时，容量增加的量 this.capacityIncrement = capacityIncrement; &#125; 底层实现12//Object[]数组protected Object[] elementData; setsize方法123456789101112//因为方法被synchronized修饰，所以是线程安全的public synchronized void setSize(int newSize) &#123; modCount++; if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize;&#125; trimToSize12345678//修剪此向量的容量为向量的当前大小public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, elementCount); &#125;&#125; elementAt方法12345678910111213141516171819202122//获取指定索引位置的元素public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; return elementData(index);&#125;//返回第一个索引位置的元素public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(0); &#125; //返回最后一个索引位置的元素public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(elementCount - 1); &#125; setElementAt方法12345678//将此矢量的指定 index中的组件设置为指定的对象。 该位置的前一个组件被丢弃。public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; elementData[index] = obj;&#125; addElement方法123456//将指定的组件添加到此向量的末尾public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 扩容123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //capacityIncrement当矢量的容量大于容量时，矢量的容量自动增加的量。, 如果*容量增量小于或等于零，则每次需要增加时，矢量的容量就会增加一倍。 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; 区别1.线程安全，vector是同步的所以是线程安全的，而arraylist不是线程安全的。 2.性能，因为vector是同步的所以在单线程情况下arraylist的性能比vector高。 3.扩容大小不同，arraylist扩容后的大小是原来的1.5倍，而vector根据capacityIncrement当矢量的容量大于容量时，矢量的容量自动增加的量。, 如果*容量增量小于或等于零，则每次需要增加时，矢量的容量就会增加一倍。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 和 Vector比较]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2FArrayList%20%20%E5%92%8C%20%20Vector%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[ArrayList 和 Vector比较ArrayListArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。 123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ArrayList类继承了AbstractList类实现了List这个*接口的用户可以精确控制列表中每个元素插入的位置。, 用户可以通过其整数索引（列表中的位置）访问元素，并在列表中搜索元素, RandomAccess支持快速的随机法访问, Cloneable允许clone, java.io.Serializable可序列化接口. 实现ArrayList的元素存储在其中的数组缓冲区，底层使用的是一个Object[]数组。 1transient Object[] elementData; // non-private to simplify nested class access 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 构造初始容量为10的空列表。 contains方法123public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; indexof方法123456789101112131415//如果数组中有o则返回第一个下标，否则返回-1public int indexOf(Object o) &#123;//因为ArrayList中可以为null if (o == null) &#123; //遍历查找 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; lastIndexOf方法12345678910111213//数组中有o返回最后一个下标public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; get方法12345678//返回列表指定位置的元素public E get(int index) &#123;//检查给定索引是否在范围内。, 如果不是，则抛出一个适当的运行时异常。//索引为负的化会抛出ArrayIndexOutOfBoundsException rangeCheck(index);//elementData数组获取 return elementData(index);&#125; set方法12345678//使用element更换列表指定位置的元素public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 扩容123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //扩容为原来的1.5倍大小 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; Fail-Fast 机制ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。 关于 Fail-Fast 的更详细的介绍，我在之前将 HashMap 中已经提到。 VectorVector类实现了一个动态数组。和ArrayList和相似，但是两者是不同的： Vector是同步访问的。 Vector包含了许多传统的方法，这些方法不属于集合框架。 Vector主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 1234public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; Vector类继承AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable接口和ArrayList相同。 123456789101112131415//构造一个空向量，使其内部数据数组的大小为10码，其标准容量增量为零。public Vector() &#123; this(10);&#125; public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); // initialCapacity初始容量 this.elementData = new Object[initialCapacity]; //capacityIncrement当矢量溢出时，容量增加的量 this.capacityIncrement = capacityIncrement; &#125; 底层实现12//Object[]数组protected Object[] elementData; setsize方法123456789101112//因为方法被synchronized修饰，所以是线程安全的public synchronized void setSize(int newSize) &#123; modCount++; if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize;&#125; trimToSize12345678//修剪此向量的容量为向量的当前大小public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, elementCount); &#125;&#125; elementAt方法12345678910111213141516171819202122//获取指定索引位置的元素public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; return elementData(index);&#125;//返回第一个索引位置的元素public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(0); &#125; //返回最后一个索引位置的元素public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(elementCount - 1); &#125; setElementAt方法12345678//将此矢量的指定 index中的组件设置为指定的对象。 该位置的前一个组件被丢弃。public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; elementData[index] = obj;&#125; addElement方法123456//将指定的组件添加到此向量的末尾public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 扩容123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //capacityIncrement当矢量的容量大于容量时，矢量的容量自动增加的量。, 如果*容量增量小于或等于零，则每次需要增加时，矢量的容量就会增加一倍。 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; 区别1.线程安全，vector是同步的所以是线程安全的，而arraylist不是线程安全的。 2.性能，因为vector是同步的所以在单线程情况下arraylist的性能比vector高。 3.扩容大小不同，arraylist扩容后的大小是原来的1.5倍，而vector根据capacityIncrement当矢量的容量大于容量时，矢量的容量自动增加的量。, 如果*容量增量小于或等于零，则每次需要增加时，矢量的容量就会增加一倍。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有效的数独]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2F%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 1: 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2: 123456789101112131415输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 给定数独永远是 9x9 形式的。123456789101112131415161718192021222324252627public class isValidSudoku &#123; public boolean isValidSudoku(char[][] board) &#123; if (board==null)&#123; return false; &#125; //row[0][8] 表示在第一行是否有8 boolean [][] row=new boolean[9][9]; //col[0][8] 表示在第9列是否有0 boolean [][] col=new boolean[9][9]; //cell[3*(i/3)+j/3][a]表示在3*3的矩阵中是否有a，i为行数j为列数 boolean [][] cell=new boolean[9][9]; for (int i=0;i&lt;9;i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] &gt;= '0' &amp;&amp; board[i][j] &lt;= '9') &#123; int a = board[i][j] - '1'; if (row[i][a] || col[a][j] || cell[3 * (i / 3) + j / 3][a]) &#123; return false; &#125; row[i][a] = true; col[a][j] = true; cell[3 * (i / 3) + j / 3][a] = true; &#125; &#125; &#125; return true; &#125;&#125; 1234567891011121314151617181920212223func isValidSudoku(board [][]byte) bool &#123; if board == nil &#123; return false &#125; var row [9][9] bool var col[9][9] bool var cell[9][9] bool for i:=0;i&lt;9 ;i++ &#123; for j:=0;j&lt;9 ;j++ &#123; if board[i][j]&gt;='1'&amp;&amp;board[i][j]&lt;='9' &#123; a:=board[i][j]-'1' if row[i][a]||col[a][j]||cell[3*(i/3)+j/3][a] &#123; return false &#125; row[i][a]=true col[a][j]=true cell[3*(i/3)+j/3][a]=true &#125; &#125; &#125; return true&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键字]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2F%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[关键字transientJava中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化，这一看好像很好理解，就是不被序列化，那么什么情况下，一个对象的某些字段不需要被序列化呢？如果有如下情况，可以考虑使用关键字transient修饰： 1、类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了； 2、其它，看具体业务需求吧，哪些字段不想被序列化； PS，记得之前看HashMap源码的时候，发现有个字段是用transient修饰的，我觉得还是有道理的，确实没必要对这个modCount字段进行序列化，因为没有意义，modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增），对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。 序列化 Java中对象的序列化指的是将对象转换成以字节序列的形式来表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。 当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。]]></content>
      <categories>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>java关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hashtable]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2FHashtable%2F</url>
    <content type="text"><![CDATA[HashtableHashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。 然而，Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。 像HashMap一样，Hashtable在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。 然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。 Hashtable和HashMap的区别HashMap 和 Hashtable 都实现了 Map 接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步 (synchronization)，以及速度。 最主要的区别，线程安全，因为Hashtable的每个方法都被synchronized所修饰，所以他是线程安全的。 Hashmap和Hashtable的默认初始容量和扩容不同，hashtable初始容量为11，而hashmap为16，扩容的话hashtable为2*old+1，而hashmap为默认容量16，扩容后一定是2的指数。 hashmap允许有1个key为null和多个value为空，而hashtable不允许有null否则会报错。 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 Hashtable继承Dictionary而Hashmap继承AbstractMap都实现了map接口 源码构造函数默认Hashtable的初始容量为11，负载因子是0.75 123public Hashtable() &#123; this(11, 0.75f);&#125; 同步的实现Hashtable中每个方法都被synchronized修饰来实现线程安全的。 1234567891011public synchronized int size() &#123; return count;&#125;public synchronized boolean isEmpty() &#123; return count == 0; &#125; public synchronized Enumeration&lt;K&gt; keys() &#123; return this.&lt;K&gt;getEnumeration(KEYS); &#125; Hashtable中使用的是Entry数组 get方法1234567891011121314//方法被synchronized修饰所以是线程安全的public synchronized V get(Object key) &#123; Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); //key的哈希值与上int的最大值在和tab数组的长度取余 int index = (hash &amp; 0x7FFFFFFF) % tab.length; //遍历链表 for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return (V)e.value; &#125; &#125; return null;&#125; put方法1234567891011121314151617181920212223242526//同步public synchronized V put(K key, V value) &#123; // value不能为空 if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; //遍历 for(; entry != null ; entry = entry.next) &#123; //如果链表中存在相同的key则进行覆盖 if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125; addEntry(）方法12345678910111213141516171819private void addEntry(int hash, K key, V value, int index) &#123; modCount++; Entry&lt;?,?&gt; tab[] = table; if (count &gt;= threshold) &#123; //如果超出阈值，则重新筛查表格 rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; //创建一个新的Entry @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; &#125; rehash（）方法扩容，当散列表中的键数超过散列表容量*和加载因子时，将自动调用此方法 1234567891011121314151617181920212223242526272829protected void rehash() &#123; int oldCapacity = table.length; Entry&lt;?,?&gt;[] oldMap = table; // overflow-conscious code int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; &#125; Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F14%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[位运算 操作符 描述 例子 ＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 \ 如果相对应位都是0，则结果为0，否则为1 （A \ B）得到61，即 0011 1101 ^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F14%2FConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap源码分析ConcurrentHashMap 是 J.U.C(java.util.concurrent 包) 的重要成员，它是 HashMap 的一个线程安全的、支持高效并发的版本。 在默认理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作及任意数量线程的读操作。 HashMap是非线程安全的，当HashMap在线程中使用时在进行扩容是Entry链可能会产生环，一旦Entry链中有环在HashMap增删查时可能陷入死循环。 ####结构图 ####ConcurrentHashMap源码 ConcurrentHashMap继承了AbstractMap实现了提供线程安全性和原子性保证的ConcurrentMap接口和序列化Serializable接口。 1234public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable &#123; .... &#125; 12345678910111213141516171819202122232425262728293031private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * 默认的初始表格容量 */private static final int DEFAULT_CAPACITY = 16;/** * 最大可能（两个非功率）阵列大小。 */static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * 此表的默认并发级别。 */private static final int DEFAULT_CONCURRENCY_LEVEL = 16;/** * 负载因子 */private static final float LOAD_FACTOR = 0.75f;/** *bin使用树而不是列表的bin数阈值。 */static final int TREEIFY_THRESHOLD = 8;/** * 用于在调整大小操作期间对（拆分）箱进行非订货的箱数阈值。 */static final int UNTREEIFY_THRESHOLD = 6; #####寻址方式 Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。同样为了避免不太好的Key的hashCode设计，它通过如下方法计算得到Key的最终哈希值。不同的是，Java 8的ConcurrentHashMap作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将Key的hashCode值与其高16位作异或并保证最高位为0（从而保证最终结果为正整数）。 123static final int spread(int h) &#123; return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125; #####put方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 public V put(K key, V value) &#123; return putVal(key, value, false); &#125; /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); //通过spread方法获得哈希值 int hash = spread(key.hashCode()); //用于记录相应链的长度 int binCount = 0; for (ConcurrentHashMap.Node&lt;K,V&gt;[] tab = table;;) &#123; ConcurrentHashMap.Node&lt;K,V&gt; f; int n, i, fh; //如果数组为空，则使用sizeCtl中记录的大小初始化表 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 找该 hash 值对应的数组下标，得到第一个节点 f else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 如果数组该位置为空， // 用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了 // 如果 CAS 失败，那就是有并发操作，进到下一个循环就好了 if (casTabAt(tab, i, null, new ConcurrentHashMap.Node&lt;K,V&gt;(hash, key, value, null))) break; // 添加到空箱时不锁 &#125; else if ((fh = f.hash) == MOVED) //帮助数据转移 tab = helpTransfer(tab, f); else &#123; // 到这里就是说，f 是该位置的头结点，而且不为空 V oldVal = null; // 获取数组该位置的头结点的监视器锁 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; //正常节点散列可用位 if (fh &gt;= 0) &#123; //用于记录相应链表的长度 binCount = 1; //遍历链表 for (ConcurrentHashMap.Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; //如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; ConcurrentHashMap.Node&lt;K,V&gt; pred = e; //如果到链表的尾部，则在后面加一个新的node if ((e = e.next) == null) &#123; pred.next = new ConcurrentHashMap.Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; //红黑树 else if (f instanceof ConcurrentHashMap.TreeBin) &#123; ConcurrentHashMap.Node&lt;K,V&gt; p; binCount = 2; //插入红黑树 if ((p = ((ConcurrentHashMap.TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; // if (binCount != 0) &#123; //如果超过8就使用红黑树而不是链表 if (binCount &gt;= TREEIFY_THRESHOLD) // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换， // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null; &#125;&#125; #####initTable方法扩容12345678910111213141516171819202122232425262728293031private final ConcurrentHashMap.Node&lt;K,V&gt;[] initTable() &#123; ConcurrentHashMap.Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; //sizeCtl为负数时表示正在初始化 if ((sc = sizeCtl) &lt; 0) //线程 Thread.yield(); // lost initialization race; just spin // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; // DEFAULT_CAPACITY 默认初始容量是 16 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(&quot;unchecked&quot;) //新建一个大小为n的node数组 ConcurrentHashMap.Node&lt;K,V&gt;[] nt = (ConcurrentHashMap.Node&lt;K,V&gt;[])new ConcurrentHashMap.Node&lt;?,?&gt;[n]; // 将这个数组赋值给 table，table 是 volatile 的 table = tab = nt; // 如果 n 为 16 的话，那么这里 sc = 12 // 其实就是 0.75 * n sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; // 设置 sizeCtl 为 sc，我们就当是 12 吧 sizeCtl = sc; &#125; break; &#125; &#125; return tab; &#125; 引用：ConcurrentHashMap 并发容器之ConcurrentHashMap(JDK 1.8版本) Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashSet源码]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F13%2FHashSet%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[HashSet源码HashSet类继承AbstractSet类，实现Set接口，Cloneable接口，java.io.Serializable序列化接口。 12345678910public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123;static final long serialVersionUID = -5024744406713321676L; private transient HashMap&lt;E,Object&gt; map; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); 无参构造函数123public HashSet() &#123; map = new HashMap&lt;&gt;();&#125; 可见HashSet是基于HashMap，所以初始容量为16，负载因子为0.75 构造一个包含指定集合中元素的新集合 1234public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125; 123public boolean contains(Object o) &#123; return map.containsKey(o); &#125; add方法 add方法也是调用的hashmap的put的方法，只是value值给的是虚拟值。 1234//PRESENTpublic boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; contains方法 判断key是否在set中 123public boolean contains(Object o) &#123; return map.containsKey(o); &#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F12%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final关键字修饰类 被final关键字修饰的类，不能被继承，如：string类就是final修饰，所以string类不能被继承 修饰方法 被final关键字修饰的方法，把方法锁定，以防任何继承类修改它的含义 修饰变量 1.如果是基本数据类型变量，则其数值一旦在初次初始化后就不能改变。 2.如果是引用类型的变量，则在对其初次初始化之后便不能再让其指向另一个对象。]]></content>
      <categories>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>java关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jvm]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F11%2FJvm%2F</url>
    <content type="text"><![CDATA[##jvm ###类加载机制概念类的加载机制是指将.class文件中的二进制数据通过类加载器加载到内存中，并在堆区间上创建一个java.lang.class对象，用来封装方法区内的数据结构。类加载最后的产品就是堆区间生成class对象，Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。生命周期类加载包括，加载，连接，初始化，使用，卸载，前三步为加载过程。加载：将.class文件中的二进数据读到内存中，将其放在运行时数据区的方法区内，并在堆区间java.lang.class对象。连接： 包括1.验证：验证数据是否正确 2.准备：为静态变量分配内存，并初始为默认值 3.解析：把类中的符号引用转化为直接引用初始化：伪静态变量赋值使用：new出对象在程序中使用卸载：垃圾回收类加载器 类加载器是将Java类加载到内存中，一般步骤是java源文件（.java文件）经过编译生成（.class文件），类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。 java.long.ClassLoader类 数组类的Class 对象不是由class 加载器创建的，而是根据Java运行时的需要自动创建的。 由getClassLoader（）返回的数组类的类加载器与其元素类的类加载器相同;, 如果元素类型是基本类型，那么数组类没有类加载器。 12345getParent() 返回委托的父类加载器findClass(String name) 使用指定的二进制查找类findLoadedClass(String name) 查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。defineClass(String name, byte[] b, int off, int len) 把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。 resolveClass(Class&lt;?&gt; c) 链接指定的类。, 这个（具有误导性的命名）方法可以被类加载器用来链接一个类。, 如果类 c已经被链接了，那么这个方法简单地返回。 类加载器类型 Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个： 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 我们可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。 除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。 类加载器关系，箭头指向的是父类。 双亲委派模型 ClassLoader 类使用委托模型来搜索类和资源。 , 关联的父类加载器。, 当请求查找类或资源时，ClassLoader实例会在尝试查找类或资源本身之前，将对类或资源的搜索委托给其父类加载器。, 虚拟机的内置类加载器称为“引导类加载器”，它本身不具有父类，但可以作为ClassLoader实例的父类。 类加载器代理模式 类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。 代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。 不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。 参考https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html 加载类的过程 因为代理机制所以类的加载首先代理给其他类进行加载尝试，这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。 定义加载器：完成类的加载工作，通过调用defineClass来实现的，在java虚拟机判断类是否相同使用。 初始加载器：启动类的加载过程是通过loadClass来实现的。 关系：一个类的定义加载器是它引用的其他类的初始加载器。 类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。 线程上下文类加载器线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 ###jvm内存结构 jvm java虚拟机，.java文件经过编译生成.class文件，jvm执行.class文件。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。因此实现java平台无关性。它是 Java 程序能在多平台间进行无缝移植的可靠保证 。 jvm是编译后java程序（.class文件）和硬件系统之间的接口 jvm=类加载器classloader+执行引擎execution engine+运行时数据区域runtime date area 类加载器将.class文件加载到jvm中的运行时数据区，执行引擎负责类文件是否执行 运行时数据区在所有线程间共享（方法区，堆） 运行时数据区线程私有（虚拟机栈，本地方法栈，程序计数器） 方法区各个线程共享的内存区域，它用于存储类的二进制文件，被虚拟机加载的类信息，常量，静态变量。 堆运行时数据区在所有线程间共享，用于存储类加载生成的java.lang,Class对象实例，几乎所有的对象实例都在这里分配内存。java堆被所有的线程共享的一块内存区域，在虚拟机启动时创建。 虚拟机栈虚拟机栈对所有线程是私有的，生命周期和线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用来存储局部变量，操作栈，动态链接，方法出口等信息。每个方法被调用到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈它也是线程私有的，本地方法栈和虚拟机栈差不多，不同就是虚拟机栈是为java方法服务，而本地方法栈是为Native方法服务。 程序计数器程序计数器是线程私有的，它的作用可以看做是当前线程所执行的字节码的行号指示器。参考：jvm ###GC垃圾回收 垃圾收集（Garbage Collection，GC），用于内存的动态分配和内存回收。 GC基本的算法标记清除法步骤：先将要回收的对象标记出来，在标记完成后统一回收所有标记的对象。 不足：1.效率不高 ​ 2.空间问题，回收标记的对象后产生许多琐碎的内存碎片，空间碎片太多可能导致以后在程序运行 时要获得一个大的对象存储空间时，空间不够因而触发另一次垃圾回收。 复制法步骤：将内存分为两块，每次只使用一个，当一个使用完后就将还存活的对象复制到另一个区域，并清除前一个区域。 缺点：内存缩小 目前商业的虚拟机都是这种算法回收新生代，将内存分为较大空间的Eden空间和两个较小的Survivor空间，每次使用Eden和一个Survivor空间，当回收时，将Eden和Survivor空间还存活的对象复制到另一个Survivor空间中，清除原来的Eden和Survivor空间。HotSpot虚拟机默认的Eden和Survivor空间大小是8:1 每次新生代内存空间为整个新生代容量的90%。 标记整理法复制法在对象存活率高时会复制多次，效率将会变低，而且不想浪费空间。 老年代使用标记整理法 步骤：和标记清除法一样，但后面不是清除，而是让所有存活的对象向一端移动，然后清除端边界以外的内存。 分代收集法当前商业虚拟机的垃圾回收都使用分代手机法。 根据对象的生命周期将内存划分成几块。一般将java堆分成新生代和老年代，这样根据不同代的特点使用不同的算法 ，新生代中，每次垃圾回收时会发现大量的对象挂了，只有少量存活，所以一般使用复制算法。 而老年代中因为对象的存活率高，没有额外空间对他进行分配担保，就使用“标记消除”或“标记整理”来进行垃圾回收。 ###GC调优 Java GC分析参考：jvm系列(五)Java GC 分析 调优命令 Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 jmap，JVM Memory Map命令用于生成heap dump文件 jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 jstack，用于生成java虚拟机当前时刻的线程快照。 jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。 详细的命令使用参考这里：jvm系列(四):jvm调优-命令篇 调优工具 常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。 jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控 jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。 MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 GChisto，一款专业分析gc日志的工具]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F10%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式工厂模式将对象的创建和实现分开工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。依赖倒置原则指的是和一般oo设计的思考方式完全相反。一般的oo设计思想是自上而下的依赖，而依赖倒置是指底层的组件依赖着高层的抽象，同样高层组件现在也依赖相同的抽象。要遵循依赖倒置原则，工厂方法不是唯一的技巧，但却是最有威力的技巧之一。 设计原则：要依赖抽象，不要依赖具体类。避免违反OO设计中违反依赖倒置原则：1.变量不可以持有具体类的引用（如果使用new就会持有具体类的引用）2.不要让类派生自具体类。（如果派生自具体类，就会依赖具体类，应该派生自一个抽象）3.不要覆盖基类中已经实现的方法（如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享） 要点所有的工厂都是用来封装对象的创建 简单工厂：简单的工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦。 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。 工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 所有的工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。 工厂方法允许类将实例化延迟到子类进行。 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。 依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象。 工厂是很有威力的技巧，帮助我们针对抽象编程，而不是针对具体类编程。 工厂模式图 抽象工厂模式图]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stomp面向简单文本的消息传递协议]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2FStomp%E9%9D%A2%E5%90%91%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Stomp面向简单文本的消息传递协议是什么：STOMP是简单（或流式）文本定向消息协议。 STOMP提供可互操作的线路格式，以便STOMP客户端可以与任何STOMP消息代理进行通信，以便在多种语言，平台和代理之间提供简单和广泛的消息互操作性。 设计： STOMP是一个非常简单易用的协议，来自HTTP设计学院; 服务器端可能很难实现，但编写客户端以便连接起来非常容易。例如，您可以使用Telnet登录到任何STOMP代理并与其交互！ WebSocket是一种在单个Tcp连接上进行全双工通讯的协议在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 背景：WebSocket协议是由HTML5定义的，它能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 Websocket使用ws或wss的统一资源标志符，类似于HTTPS，其中wss表示在TLS之上的Websocket。 Websocket使用和 HTTP 相同的 TCP 端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。 优点：1.较少的控制开销。 在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。2.更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。3.保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。4.更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。5.可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。6.更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。 握手协议：WebSocket 是独立的、创建在 TCP 上的协议。Websocket 通过 HTTP/1.1 协议的101状态码进行握手。为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。 例子:一个典型的Websocket握手请求如下：客户端请求1234567GET / HTTP/1.1Upgrade: websocket //表示希望升级到Websocket协议。Connection: Upgrade //表示客户端希望连接升级Host: example.com Origin: http://example.comSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ== //Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。Sec-WebSocket-Version: 13 //表示支持的Websocket版本。 服务器回应12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=Sec-WebSocket-Location: ws://example.com/ HTTPS超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过电脑网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。 主要思想HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。 HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构（如Symantec、Comodo、GoDaddy和GlobalSign等）（意即“我信任证书颁发机构告诉我应该信任的”）。因此，一个到某网站的HTTPS连接可被信任，当且仅当： 用户相信他们的浏览器正确实现了HTTPS且安装了正确的证书颁发机构；用户相信证书颁发机构仅信任合法的网站；被访问的网站提供了一个有效的证书，意即，它是由一个被信任的证书颁发机构签发的（大部分浏览器会对无效的证书发出警告）；该证书正确地验证了被访问的网站（如，访问https://example.com时收到了给example.com而不是其它组织的证书）；或者互联网上相关的节点是值得信任的，或者用户相信本协议的加密层（TLS或SSL）不能被窃听者破坏。HTTPS不应与在 RFC 2660 中定义的安全超文本传输协议（S-HTTP）相混淆。 与HTTP差别与HTTP的URL由“http://”起始且默认使用端口80不同，HTTPS的URL由“https://”起始且默认使用端口443。 HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，并在正确配置时被认为是安全的。 HTTP超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 协议概述HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMap ：带符号右移。正数右移高位补0，负数右移高位补1。比如： 4 &gt;&gt; 1，结果是2；-4 &gt;&gt; 1，结果是-2。-2 &gt;&gt; 1，结果是-1。 ：无符号右移。无论是正数还是负数，高位通通补0。 对于正数而言，&gt;&gt;和&gt;&gt;&gt;没区别。 简介1.HashMap基于哈希的map接口实现。2.HashMap 类大致相当于 Hashtable ，只是它是非同步的并且允许为空值。3.HashMap根据键的hashCode值存储数据，一般直接可以定位到它的值，但他遍历顺序是不确定的。HashMap只允许key中只有一个null，而value可以是多个，HashMap是非线程安全的。如果要满足线程安全，可以用Collection的synchronizedMap方法使的HashMap具有线程安全的能力，或使用ConcurrentHashMap。 内部实现从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。 1.HashMap中有Node&lt;K,V&gt;[] table 即哈希桶数组。HashMap的内部类123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 2.HashMap构造方法。12345678910111213141516/**使用指定的初始容量和指定加载因子构造一个空的HashMap*/public HashMap(int initialCapacity, float loadFactor)&#123;...&#125;/**使用指定的初始容量和默认加载因子（0.75）构造一个空的HashMap*/ public HashMap(int initialCapacity)&#123;...&#125; /* *使用默认的初始容量（16）和默认加载因子（0.75）构造一个空的HashMap */ public HashMap() &#123;...&#125; /* *使用与指定的&lt;tt&gt; Map &lt;/ tt&gt;相同的映射构造一个新的HashMapHashMap用默认加载因子 *（0.75）和一个初始容量来创建，该容量足以将映射保存在指定的Map */ public HashMap(Map&lt;? extends K, ? extends V&gt; m)&#123;...&#125; 3.jdk1.8 HashMap的put方法源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i;// 判断table是否为空，创建默认大小 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length;// 计算index，并对null做处理 （有点懵） if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; HashMap.Node&lt;K,V&gt; e; K k; //节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //判断是否是红黑树 else if (p instanceof HashMap.TreeNode) e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //该链为链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //key存在就覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //超过阈值就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 4.HashMap 扩容扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。 （1）.jdk1.7的扩容是当容量大于阈值时，使用大的数组代替小的数组 12345678910111213141516171819202122232425262728293031 void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 &#125; //用于将原来的数组中的数据拷贝到新的数组 void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null);&#125;&#125; &#125; jdk1.7扩容后会重新计算每个元素在数组中的位置，当put时数据会放在链表的前面，所以最先插入的数据应该在链表的末尾。（2）.jdk1.8123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final HashMap.Node&lt;K,V&gt;[] resize() &#123; HashMap.Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //判断是否大于最大容量 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //当小于最大容量时，扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) HashMap.Node&lt;K,V&gt;[] newTab = (HashMap.Node&lt;K,V&gt;[])new HashMap.Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; HashMap.Node&lt;K,V&gt; e; //遍历老数组，并释放它 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) //e的哈希和新的容量-1做与运算 得出在新数组的位置 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof HashMap.TreeNode)//判断它是红黑树 ((HashMap.TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 HashMap.Node&lt;K,V&gt; loHead = null, loTail = null; HashMap.Node&lt;K,V&gt; hiHead = null, hiTail = null; HashMap.Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; HashMap get操作 这个操作的原理就比较简单,只需要根据key的hashcode算出元素在数组中的下标,之后遍历Entry对象链表,直到找到元素为止。 12345678int hash = (key == null) ? 0 : hash(key);for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];e != null;e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e;&#125;123456789 这里有两个注意点:1、这里利用key的hashcode方法和equals方法,所以在使用HashMap的时候,如果使用对象作为key,最好覆写key的hashcode和equals方法不然可能出put到HashMap的时候,成功了,但是get的时候却没有找到数据2、如果key hash冲突太多,会造成链表过长,在链表中查找元素的时候,会比较慢 hash冲突后优化方案 如果出现了大量hash冲突,那么遍历链表的时候,会比较慢。JDK 1.8里面，当链表的长度大于阀值(默认为8)的时候,会使用红黑树来存储数据,以便加快key的查询速度。 线程安全性HashMap是非线程安全的，线程安全的ConcurrentHashMap。在多线程情况下HashMap会产生死循环]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[##两数之和 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 使用hashmap将数组中的值作为key，下标作为value值放入map中，查的时候只找map中是否有target-nums[i]，则返回的就是i和target-nums[i]的下标。1234567891011121314public static int[] twoSum1(int[] nums, int target) &#123; if (nums == null) &#123; return null; &#125; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(target-nums[i])) &#123; return new int[]&#123;map.get(target - nums[i]), i&#125;; &#125;else &#123; map.put(nums[i], i); &#125; &#125; return null; &#125; 返回两个数的值指针i指向数组的头，而j指向屁股，然后直到他俩相遇123456789101112131415161718192021222324252627282930public static int[] twoSum(int[] nums, int target) &#123; if (nums == null) &#123; return null; &#125; int i = 0; int j = nums.length - 1; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int x = 0; x &lt; nums.length; x++) &#123; while (i &lt; x &amp;&amp; j &gt; x) &#123; if (Math.abs(i - j) == 1) &#123; break; &#125; if (j &gt;= 0 &amp;&amp; target &lt; nums[j]) &#123; j--; &#125; if (i &lt; nums.length &amp;&amp; j &gt;= 0 &amp;&amp; nums[i] + nums[j] == target) &#123; list.add(nums[i]); i++; list.add(nums[j]); j--; &#125; &#125; &#125; int[] re = new int[list.size()]; for (int i1 = 0; i1 &lt; re.length; i1++) &#123; re[i1] = list.get(i1); &#125; return re; &#125; 123456789101112131415161718func twoSum(nums []int, target int) []int &#123; if nums==nil &#123; return nil &#125; m:=make(map[int]int) for i:=0;i&lt;len(nums) ;i++ &#123; captial,ok:=m[target-nums[i]] if ok&#123; s:=[] int&#123;captial,i&#125; return s &#125;else &#123; m[nums[i]]=i &#125; &#125;return nil&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组加一]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2F%E6%95%B0%E7%BB%84%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[加一 给定一个非负整数组成的非空数组，在该数的基础上加一，返回一个新的数组。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 #####Java：1234567891011121314151617public static int[] plusOne(int[] digits) &#123; int creay=1; for (int i=digits.length-1;i&gt;=0;i--)&#123; if (creay==0)&#123; return digits; &#125; int tmp=digits[i]+creay; creay=tmp/10; digits[i]=tmp%10; &#125; if (creay!=0) &#123; int [] re=new int[digits.length+1]; re[0]=1; return re; &#125; return digits;&#125; #####go:1234567891011121314151617func plusOne(a [] int) [] int&#123; crray:=1 for i:=len(a)-1;i&gt;=0 ; i-- &#123; if crray==0 &#123; return a &#125; tmp:=a[i]+crray crray=tmp/10 a[i]=tmp%10 &#125; if crray!=0 &#123; var newa [] int=make([]int,len(a)+1) newa[0]=1 return newa &#125; return a&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 并发编程实战 读书笔记]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2Fjava-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[对象的共享简述：已知同步方法和同步代码块，可以以原子性的方式执行。同步还可以通过内存可见性实现。当多个线程对一个公共的数据进行set和get ，如果set和get方法不用synchronized修饰是非线程安全的。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 失效数据多个线程调用一个数据时，一个线程获取的数据不是最新的，而是一个过期的数据。失效问题：一个线程set后另一个线程get的数据可能不是最新的获知可能获取不到。 非原子的64位操作非volatile类型double，long变量，jvm在对64位的double或long变量的读操作或写操作是分为高位32和低位32位进行操作的，在进行操作时可能是取一个数的高32位而取另一个数的低32位。所以在多线程情况下要使用volatile关键字对double，long变量进行修饰。 volatile变量volatile变量是一种稍微的同步机制。volatile变量不会存在寄存器或者对其他处理器不可见的地方，因此每次读取的数据都是最新的。volatile是一种比synchronization稍微弱的同步机制。访问volatile变量时不需要加锁操作，因此也就不会使执行线程阻塞的。正确使用方法：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如，初始化或关闭）局限性：volatile变量通常用做某个操作完成，发生中断或者状态的标志。 ####### 加锁机制能可以确保原子性和可见性，而volatile只能确保可见性。使用volatile前提：1.对变量的写入操作不依赖变量的当前值；2.该变量不会与其他状态变量一起纳入不变性条件中。3.在访问时不需要加锁。 线程封闭一种避免使用同步的方法就是不共享数据。线程封闭是实现线程安全性的最简单的方式之一。Ad-hoc线程封闭Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担，它是非常脆弱的，因为没有任何一种语言特性，能将对象封闭到目标线程上。一般不使用。栈封闭在栈封闭中，只能通过局部变量才能访问对象。局部变量封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭也被称为线程内部使用或线程局部使用。比Ad-hoc更加易于维护，更加健壮。ThreadLocal类ThreadLocal类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。ThreadLoacl类中使用map存储数据，key为线程而value为变量副本。ThreadLocal类中有一个ThreadLocalMap内部类，用来存储副本key为线程，而value为变量的副本。 不变性什么是不变性不变性指对象的状态不改变。不变性对象一定是线程安全的。满足条件1.对象创建后其状态不再改变2.对象的所有域都是final类型的3.对象是正确创建的（在对象创建之间，this引用没有逸出） Final域final域能确保初始化过程中的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象的时无须同步。 除非需要更高的可见性，否则应将所有的域都声明为私有域除非需要某个域是可变的，否则应将其声明为final域####使用volatile类型来发布不可变对象在某些情况下，不可变对象能提供一种弱形式的原子性，对于在访问和更新多个相关变量的竞争问题，可以将这些变量存储在一个不变对象中来消除。如果是一个可变对象，只能用锁来确保原子性。如果是一个不可变对象，当一个线程获得他的值后，另一个线程不能改变对象的状态。更新这些变量时，创建一个新的容器对象，但其他使用原有对象的线程仍然会看到对象处于一致状态。使用不可变对象容器的volatile类型引用以缓存最新的结果。volatile在修饰不可变对象容器时是线程安全的。 ##安全发布为什么要安全发布要在足够同步的情况下发布对象，不安全的发布会导致其他线程看见尚未完成的对象。对象在不完全发布时会出现两个问题：1.当一个对象未安全发布时除了发布对象的线程外其他线程看见的对象要么是旧值，要么是空引用。2.某一个线程在第一次读取时得到失效值，而再一次读取这个域时会得到一个更新值。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机2]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路：因为要获取最大利润，所以只要后面比前面的大就获利123456789101112131415161718192021222324252627282930313233343536java版本:class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices==null || prices.length==0)&#123; return 0; &#125; int min=prices[0]; int sum=0; for (int i=1;i&lt;prices.length;i++)&#123; if (prices[i]&gt;min)&#123; sum+=prices[i]-min; min=prices[i]; &#125;else &#123; min=prices[i]; &#125; &#125; return sum; &#125;&#125; 1234567891011121314151617go版本:func max(a []int) int &#123; if len(a)==0 &#123; return 0 &#125; min := a[0] sum :=0 for i:=0;i&lt;len(a) ;i++ &#123; if min&lt;a[i] &#123; sum+=(a[i]-min) min=a[i] &#125;else &#123; min=a[i] &#125; &#125; return sum&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F29%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[旋转数组给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明:123- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。- 要求使用空间复杂度为 O(1) 的原地算法。 方法一：123456789101112-利用length-k将数组分为两部分-分别调换两段数组-再转化整个数组例如： 1 2 3 4 5 6 7 如果k = 3 的话， 会变成 5 6 7 1 2 3 4 1 2 3 4 5 6 7 middle = 7 - 3 = 4，分为左边 4个数字，右边 3个数字 4 3 2 1 7 6 5 分别把左右swap 一下 5 6 7 1 2 3 4 把总数组swap 一下就会得到答案​` java:​123456789101112131415161718192021class Solution &#123; public void rotate(int[] nums, int k) &#123; if (nums.length==0||nums==null||k%nums.length==0)&#123; return ; &#125; int t=k%nums.length; int sta=nums.length-t; swap(nums,0,sta-1); swap(nums,sta,nums.length-1); swap(nums,0,nums.length-1); &#125; public static void swap(int[] a, int i, int j) &#123; while(i&lt;j) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; &#125;&#125; go:12345678910111213141516171819func rotate(nums []int,k int) &#123; if len(nums)==0 || nums==nil ||k%len(nums)==0 &#123; return &#125; t:=k%len(nums) sta:=len(nums)-t swap(nums,0,sta-1) swap(nums,sta,len(nums)-1) swap(nums,0,len(nums)-1)&#125;func swap(a [] int,i int,j int) &#123; for i&lt;j&#123; tmp:=a[i] a[i]=a[j] a[j]=tmp i++ j-- &#125;&#125; 方法二：12-创建一个大小相同的数组-然后将原数组中的值写到新数组中，关键点（a[(i + k) % nums.length] = nums[i];） 12345678public static int[] rotate1(int[] nums, int k) &#123; int[] a = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; //关键点 a[(i + k) % nums.length] = nums[i]; &#125; return a; &#125; go:12345678func rotate1(nums [] int,k int) []int&#123; //go中切片 相当于动态数组 切片的长度不是固定的，在追加时可能使的容量增大 var a [] int=make([]int,len(nums)) for i:=0;i&lt;len(nums) ;i++ &#123; a[(i+k)%len(nums)]=nums[i] &#125; return a&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql配置]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fmysql%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[踩过的坑 防止再掉 1.mysql文件和文件夹(linux 配置文件文件后缀为cnf) bin 放可执行性文件 include 存放头文件 lib 存放库文件 share 存放字符集，语言等信息 my.ini mysql软件正在使用的配置文件 my-huge.ini 当mysql软件为超大型数据库时使用的配置文件 my-small.ini 当mysql软件为小型数据库时使用的配置文件 my-template.ini 配置文件模板 2.my.ini配置文件中的内容可实现修改数据库实例的参数（linux中为my.cnf） 客户端 [mysql] 客户端的端口号 prot=3306 客户端默认字符集 default-character-set=utf8 [mysqld] 服务端 prot=3306 数据库服务器的安装目录 basedir=？？？？ mysql数据库数据文件的目录 datadir=？？？ mysql软件端的字符集 character-set-server=utf8 mysql软件的存储引擎 default-storage-engine=INNODB mysql最大连接数 max-connections=100 mysql软件缓存 query_cache_size=0 mysql中可以打开表的总数 table_cache=256 mysql软件内存中可以存储临时表的最大值 tem_table_size=9m mysql软件可以保留的客户端链接线程数 thread_cache_size=8 mysql软件重建索引时允许的最大临时文件的大小 myisam_max_sort_file_size=10G mysql软件重建索引时允许的最大缓存的大小 myisam_sort_buffer_size=17m mysql软件中最大关键字缓存的大小 key_buffer_size=10m mysql软件全扫描myisam表时的缓存大小 read_buffer_size=6k mysql软件可以插入排序好的数据的缓存的小 read_rnd_buffer_size=256k mysql软件用户排序时缓存的大小 sort_buffer_size=256k 关于INNODB存储引擎参数设置附加内存池大小 innodb_additional_mem_pool_size=2m 关于提交日志的时机 innodb_flush_log_at_trx_commit=1 存储日志数据的缓存区的大小 innodb_log_buffer_size=1m 缓存池中缓存区的大小 innodb_buffer_pool_size=17m 日记文件的大小 innodb_log_file_size=10m 允许线程的最大数 innodb_thread_concurrency=8]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 和 StringBuffer 和 StringBuilder]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2FString%20%E5%92%8C%20StringBuffer%20%E5%92%8C%20StringBuilder%2F</url>
    <content type="text"><![CDATA[三者不同点 1，string 类是不可变的，一旦创建了String对象，那她就无法改变2，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 线程安全StringBuffer是线程安全的，而StringBuilder是非线程安全的。 运行速度1.StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 2.StringBuffer 和 StringBuilder 长度可变 StringBuffer &amp;&amp; StringBuilder &amp;&amp; String StringBuffer：一个线程安全的，可变的字符序列。字符串缓冲区就像一个String，但可以修改。在任何时候它都包含一些特定的字符序列，但是序列的长度和内容可以通过某些方法调用来改变。字符串缓冲区对于多线程来说是安全的。这些方法在必要时进行同步，以便任何特定实例上的所有操作的行为就好像它们以某种连续顺序发生，这与每个涉及的单个线程所进行的方法调用的顺序一致。 上的主要操作StringBuffer是 append和insert方法，其被重载，以便接受任何类型的数据。每个函数都有效地将给定的数据转换为字符串，然后将该字符串的字符附加或插入到字符串缓冲区中。该 append方法总是将这些字符添加到缓冲区的末尾; 该insert方法在指定的点添加字符。 如果sb指的是a的一个实例StringBuffer，那么sb.append(x)效果与之相同 sb.insert(sb.length(), x)。 每个字符串缓冲区都有一个容量 只要包含在字符串缓冲区中的字符序列的长度不超过容量，就不需要分配新的内部缓冲区数组。如果内部缓冲区溢出，它会自动变大。从版本JDK 5开始，这个类已经补充了一个为单个线程设计的等价类StringBuilder。由于StringBuilder类支持所有相同的操作，所以通常会优先使用StringBuilder类，但速度更快，因为它不执行同步操作。 StringBuilder：一个可变的字符序列。这个类提供了一个兼容的API StringBuffer，但不保证同步。这个类被设计成在StringBuffer单个线程正在使用字符串缓冲区的地方（如通常情况下）用作嵌入式替换 。在可能的情况下，建议优先使用此类， StringBuffer因为在大多数实现中它会更快。 上的主要操作StringBuilder是 append和insert方法，其被重载，以便接受任何类型的数据。每个有效地将给定的数据转换为一个字符串，然后将该字符串的字符追加或插入到字符串生成器。该 append方法总是在构建器的最后添加这些字符; 该insert方法在指定的点添加字符。 StringBuilder多线程使用的实例不安全。如果需要这种同步，则建议StringBuffer使用。 String：String类代表字符串。Java程序中的所有字符串文字，例如”abc”，都被实现为这个类的实例。字符串是不变的; 他们的价值创造后不能改变。字符串缓冲区支持可变字符串。因为String对象是不可变的，所以它们可以共享。 StringBuffer源码1.StringBuffer一个线程安全的，可变的字符序列。2.StringBuffer就像一个String，但可以修改。在任何时间点，它都包含一些特定的字符列，但是序列的长度和内容可以通过某些方法调用来改变3.字符串缓冲区对于多线程使用是安全的。 方法在必要时进行同步，以便任何特定实例上的所有操作的行为就好像它们以某种连续顺序发生一样，这与每个涉及的各个线程所进行的方法调用的顺序一致。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123; /** * 构造一个没有字符的字符串缓冲区，并且字符的初始容量为16个字符。 */ public StringBuffer() &#123; super(16); &#125; /* *构造一个没有字符的字符串缓冲区，并且指定的初始容量 */ public StringBuffer(int capacity) &#123; super(capacity); &#125; /* *构造一个字符串缓冲区，初始化为*指定字符串的内容。, 字符串缓冲区的初始容量是16加上字符串参数 *的长度。 */ public StringBuffer(String str) &#123; super(str.length() + 16); append(str); &#125; /** * 构造一个字符串缓冲区，其中包含与指定CharSequence相同的字符字符串缓冲区的初始 *容量是 16加上CharSequence参数的长度。 * @param seq */ public StringBuffer(CharSequence seq) &#123; this(seq.length() + 16); append(seq); &#125; //最常用的append 将sb加到该序列 synchronized修饰线程安全的 public synchronized StringBuffer append(StringBuffer sb) &#123; toStringCache = null; super.append(sb); return this; &#125; @Override public synchronized StringBuffer append(CharSequence s) &#123; toStringCache = null; super.append(s); return this; &#125; @Override synchronized StringBuffer append(AbstractStringBuilder asb) &#123; toStringCache = null; super.append(asb); return this; &#125; &#125; ####StringBufer类final修饰说明这个类是“终态的”,不能被继承。类中的方法默认是final所以不能被覆盖。final方法 方法将不能被覆盖 #####StringBuilder 一个可变的字符序列，该类提供一个api与stringCuffer兼容，但不是同步的。这个类被设计在单个线程使用字符串缓存的地方用作（StringBuffer）的嵌入替代品，在大多数实现中它更快。 1234567891011121314151617181920/**StringBuilder和stringBuffer 继承和实现的接口相同*/public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123;/**构造方法和StringBuffer相同*/ public StringBuilder() &#123; super(16); &#125; /* *不同就是append方法 StringBuffer的append方法被synchronized修饰所以是线程安 *全的 */ public StringBuilder append(StringBuffer sb) &#123; super.append(sb); return this; &#125; #####String是不可变的，他们的值创建后无法改变]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[java反射一 概念1.JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。通过class类调用自身的方法属性等二 class对象获得Class对象的由来是将class文件读入内存，并为之创建一个Class对象。通过这个对象可以获取类的相关信息 获取Class对象的三种方式1.1 Object ——&gt; getClass();1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性1.3 通过Class类的静态方法：forName（String ?className）(常用) public static void main(String[] args) { T515 t515=new T515(); /** * 1.返回此的运行时类 */ Class aClass=t515.getClass(); /** * 2.获取class对象 */ Class aClass1=T515.class; try { /** * 3.用给定的字符串名返回与类或接口关联的Class对象 */ Class aClass2 = Class.forName(&quot;T515.T515&quot;); System.out.println(aClass2==aClass); }catch (Exception e){ e.printStackTrace(); } System.out.println(aClass==aClass1); } 结果为 两个true 三 可以通过class对象获取类的相关类信息]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis 一对一级联 一对多]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fmybats%E7%BA%A7%E8%81%94%2F</url>
    <content type="text"><![CDATA[一：一对一 用association 一 建表 course 课程与score 课程成绩表是一对一关系 course课程表 score课程成绩表 连接数据库dbconf.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN” “http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 写一个db.properties文件jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybajdbc.username=rootjdbc.password=××× 二 使用mybatis插件自动生成相对应表的配置文件 CourseMapper.xml &lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; SELECT myba.course.* from myba.course WHERE coid=#{coid} CourseMapper接口*CourseMapper.xml是对接口的实现 所以 select 的id与接口中方法名相同package com.ygy.mapper; import com.ygy.model.Course;import com.ygy.model.CourseExample;import java.util.List;import org.apache.ibatis.annotations.Param; public interface CourseMapper { public Course selectcou(int id);} ScoreMapper.xml&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; select myba.score. from myba.score WHERE myba.score.scsid=#{id} ScoreMapper接口package com.ygy.mapper;import com.ygy.model.Score;import com.ygy.model.ScoreExample;import java.util.List;import org.apache.ibatis.annotations.Param;public interface ScoreMapper { public Score selectscore(int id);}在score的model中加上private Course course;//get set方法三 测试@Test public void main(){ SqlSessionFactory sqlSessionFactory; InputStream inputStream; try { inputStream= Resources.getResourceAsStream(“dbconf.xml”); sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); sqlSession=sqlSessionFactory.openSession()； //SCORC和course一对一 ScoreMapper scoreMapper=sqlSession.getMapper(ScoreMapper.class); Score score=scoreMapper.selectscore(1); System.out.println(score.getCourse().getConame()); } catch (IOException e) { e.printStackTrace(); }finally { sqlSession.close(); }二：一对多 collection加入学生表stud插件生成对应的接口什么的&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; SELECT myba.stud. FROM myba.stud WHERE myba.stud.sid=#{id} 接口package com.ygy.mapper; import com.ygy.model.Stud;import com.ygy.model.StudExample;import java.util.List;import org.apache.ibatis.annotations.Param; public interface StudMapper { public Stud selectsud(int id);} 测试@Test public void main(){ SqlSessionFactory sqlSessionFactory; InputStream inputStream; try { inputStream= Resources.getResourceAsStream(&quot;dbconf.xml&quot;); sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); sqlSession=sqlSessionFactory.openSession(); StudMapper studMapper=sqlSession.getMapper(StudMapper.class); Stud stud=studMapper.selectsud(1); System.out.println(stud.getScoreList().get(1).getMark()); } catch (IOException e) { e.printStackTrace(); }finally { sqlSession.close(); } 结果：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F23%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[mybatis自动生成代码插件]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F23%2Fmybatis%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一.generatorconfig.xml文件12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;mysqlgenerator&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ygy&quot; userId=&quot;root&quot; password=&quot;***&quot; /&gt; 1&lt;!--targetProject 后面跟的是model放的位置 targetPackage放的包名--&gt; 123456789101112 &lt;javaModelGenerator targetPackage=&quot;com.nomico271.model&quot; targetProject=&quot;src&quot; /&gt; &lt;sqlMapGenerator targetPackage=&quot;com.nomico271.mapper&quot; targetProject=&quot;src&quot; /&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.nomico271.mapper&quot; targetProject=&quot;src&quot; /&gt; &lt;table tableName=&quot;ygy1&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; ##二.pox.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;generator&lt;/groupId&gt; &lt;artifactId&gt;generator&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;generator Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt;//××引包 &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;generator&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 12 12完成上面的配置 然后打开maven--&gt;plugins---&gt;mybatis-generator---&gt;mybatis-generator:generate运行mybatis-generator:generate完成自动生成所需要的文件 123456789101112131415161718192021222324252627282930313233## 三.添加数据到数据库中import com.nomico271.model.Ygy1;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;public class main &#123; static Reader reader; static SqlSession session; public static void main(String[] args) &#123; try &#123; reader= Resources.getResourceAsReader(&quot;ygy.xml&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader); session=sqlSessionFactory.openSession(); Ygy1 ygy1=new Ygy1(); ygy1.setId(3); ygy1.setName(&quot;sdhuaik&quot;); session.insert(&quot;insert&quot;,ygy1); session.commit(); session.close(); &#125; &#125;&#125;运行程序显示 说明添加成功（其他删，改，查相似）]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
