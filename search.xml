<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hashtable]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F17%2FHashtable%2F</url>
    <content type="text"><![CDATA[HashtableHashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。 然而，Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。 像HashMap一样，Hashtable在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。 然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。 Hashtable和HashMap的区别HashMap 和 Hashtable 都实现了 Map 接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步 (synchronization)，以及速度。 HashMap 几乎可以等价于 Hashtable，除了 HashMap 是非 synchronized 的，并可以接受 null(HashMap 可以接受为 null 的键值 (key) 和值(value)，而 Hashtable 则不行)。 HashMap 是非 synchronized，而 Hashtable 是 synchronized，这意味着 Hashtable 是线程安全的，多个线程可以共享一个 Hashtable；而如果没有正确的同步的话，多个线程是不能共享 HashMap 的。Java 5 提供了 ConcurrentHashMap，它是 HashTable 的替代，比 HashTable 的扩展性更好。 另一个区别是 HashMap 的迭代器 (Iterator) 是 fail-fast 迭代器，而 Hashtable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），将会抛出 ConcurrentModificationException，但迭代器本身的 remove()方法移除元素则不会抛出 ConcurrentModificationException 异常。但这并不是一个一定发生的行为，要看 JVM。这条同样也是 Enumeration 和 Iterator 的区别。 由于 Hashtable 是线程安全的也是 synchronized，所以在单线程环境下它比 HashMap 要慢。如果你不需要同步，只需要单一线程，那么使用 HashMap 性能要好过 Hashtable。 HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 源码构造函数默认Hashtable的初始容量为11，负载因子是0.75 123public Hashtable() &#123; this(11, 0.75f);&#125; 同步的实现Hashtable中每个方法都被synchronized修饰来实现线程安全的。 1234567891011public synchronized int size() &#123; return count;&#125;public synchronized boolean isEmpty() &#123; return count == 0; &#125; public synchronized Enumeration&lt;K&gt; keys() &#123; return this.&lt;K&gt;getEnumeration(KEYS); &#125; Hashtable中使用的是Entry数组 get方法1234567891011121314//方法被synchronized修饰所以是线程安全的public synchronized V get(Object key) &#123; Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); //key的哈希值与上int的最大值在和tab数组的长度取余 int index = (hash &amp; 0x7FFFFFFF) % tab.length; //遍历链表 for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return (V)e.value; &#125; &#125; return null;&#125; put方法1234567891011121314151617181920212223242526//同步public synchronized V put(K key, V value) &#123; // value不能为空 if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; //遍历 for(; entry != null ; entry = entry.next) &#123; //如果链表中存在相同的key则进行覆盖 if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125; addEntry(）方法12345678910111213141516171819private void addEntry(int hash, K key, V value, int index) &#123; modCount++; Entry&lt;?,?&gt; tab[] = table; if (count &gt;= threshold) &#123; //如果超出阈值，则重新筛查表格 rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; //创建一个新的Entry @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; &#125; rehash（）方法扩容，当散列表中的键数超过散列表容量*和加载因子时，将自动调用此方法 1234567891011121314151617181920212223242526272829protected void rehash() &#123; int oldCapacity = table.length; Entry&lt;?,?&gt;[] oldMap = table; // overflow-conscious code int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; &#125; Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码分析]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F14%2FConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap源码分析ConcurrentHashMap 是 J.U.C(java.util.concurrent 包) 的重要成员，它是 HashMap 的一个线程安全的、支持高效并发的版本。 在默认理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作及任意数量线程的读操作。 HashMap是非线程安全的，当HashMap在线程中使用时在进行扩容是Entry链可能会产生环，一旦Entry链中有环在HashMap增删查时可能陷入死循环。 ####结构图 ####ConcurrentHashMap源码 ConcurrentHashMap继承了AbstractMap实现了提供线程安全性和原子性保证的ConcurrentMap接口和序列化Serializable接口。 1234public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable &#123; .... &#125; 12345678910111213141516171819202122232425262728293031private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * 默认的初始表格容量 */private static final int DEFAULT_CAPACITY = 16;/** * 最大可能（两个非功率）阵列大小。 */static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * 此表的默认并发级别。 */private static final int DEFAULT_CONCURRENCY_LEVEL = 16;/** * 负载因子 */private static final float LOAD_FACTOR = 0.75f;/** *bin使用树而不是列表的bin数阈值。 */static final int TREEIFY_THRESHOLD = 8;/** * 用于在调整大小操作期间对（拆分）箱进行非订货的箱数阈值。 */static final int UNTREEIFY_THRESHOLD = 6; #####寻址方式 Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。同样为了避免不太好的Key的hashCode设计，它通过如下方法计算得到Key的最终哈希值。不同的是，Java 8的ConcurrentHashMap作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将Key的hashCode值与其高16位作异或并保证最高位为0（从而保证最终结果为正整数）。 123static final int spread(int h) &#123; return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125; #####put方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 public V put(K key, V value) &#123; return putVal(key, value, false); &#125; /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); //通过spread方法获得哈希值 int hash = spread(key.hashCode()); //用于记录相应链的长度 int binCount = 0; for (ConcurrentHashMap.Node&lt;K,V&gt;[] tab = table;;) &#123; ConcurrentHashMap.Node&lt;K,V&gt; f; int n, i, fh; //如果数组为空，则使用sizeCtl中记录的大小初始化表 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 找该 hash 值对应的数组下标，得到第一个节点 f else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 如果数组该位置为空， // 用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了 // 如果 CAS 失败，那就是有并发操作，进到下一个循环就好了 if (casTabAt(tab, i, null, new ConcurrentHashMap.Node&lt;K,V&gt;(hash, key, value, null))) break; // 添加到空箱时不锁 &#125; else if ((fh = f.hash) == MOVED) //帮助数据转移 tab = helpTransfer(tab, f); else &#123; // 到这里就是说，f 是该位置的头结点，而且不为空 V oldVal = null; // 获取数组该位置的头结点的监视器锁 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; //正常节点散列可用位 if (fh &gt;= 0) &#123; //用于记录相应链表的长度 binCount = 1; //遍历链表 for (ConcurrentHashMap.Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; //如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; ConcurrentHashMap.Node&lt;K,V&gt; pred = e; //如果到链表的尾部，则在后面加一个新的node if ((e = e.next) == null) &#123; pred.next = new ConcurrentHashMap.Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; //红黑树 else if (f instanceof ConcurrentHashMap.TreeBin) &#123; ConcurrentHashMap.Node&lt;K,V&gt; p; binCount = 2; //插入红黑树 if ((p = ((ConcurrentHashMap.TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; // if (binCount != 0) &#123; //如果超过8就使用红黑树而不是链表 if (binCount &gt;= TREEIFY_THRESHOLD) // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换， // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null; &#125;&#125; #####initTable方法扩容12345678910111213141516171819202122232425262728293031private final ConcurrentHashMap.Node&lt;K,V&gt;[] initTable() &#123; ConcurrentHashMap.Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; //sizeCtl为负数时表示正在初始化 if ((sc = sizeCtl) &lt; 0) //线程 Thread.yield(); // lost initialization race; just spin // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; // DEFAULT_CAPACITY 默认初始容量是 16 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(&quot;unchecked&quot;) //新建一个大小为n的node数组 ConcurrentHashMap.Node&lt;K,V&gt;[] nt = (ConcurrentHashMap.Node&lt;K,V&gt;[])new ConcurrentHashMap.Node&lt;?,?&gt;[n]; // 将这个数组赋值给 table，table 是 volatile 的 table = tab = nt; // 如果 n 为 16 的话，那么这里 sc = 12 // 其实就是 0.75 * n sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; // 设置 sizeCtl 为 sc，我们就当是 12 吧 sizeCtl = sc; &#125; break; &#125; &#125; return tab; &#125; 引用：ConcurrentHashMap 并发容器之ConcurrentHashMap(JDK 1.8版本) Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F12%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final关键字修饰类 被final关键字修饰的类，不能被继承，如：string类就是final修饰，所以string类不能被继承 修饰方法 被final关键字修饰的方法，把方法锁定，以防任何继承类修改它的含义 修饰变量 1.如果是基本数据类型变量，则其数值一旦在初次初始化后就不能改变。 2.如果是引用类型的变量，则在对其初次初始化之后便不能再让其指向另一个对象。]]></content>
      <categories>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>java关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jvm]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F11%2FJvm%2F</url>
    <content type="text"><![CDATA[##jvm ###类加载机制概念类的加载机制是指将.class文件中的二进制数据通过类加载器加载到内存中，并在堆区间上创建一个java.lang.class对象，用来封装方法区内的数据结构。类加载最后的产品就是堆区间生成class对象，Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。生命周期类加载包括，加载，连接，初始化，使用，卸载，前三步为加载过程。加载：将.class文件中的二进数据读到内存中，将其放在运行时数据区的方法区内，并在堆区间java.lang.class对象。连接： 包括1.验证：验证数据是否正确 2.准备：为静态变量分配内存，并初始为默认值 3.解析：把类中的符号引用转化为直接引用初始化：伪静态变量赋值使用：new出对象在程序中使用卸载：垃圾回收类加载器 类加载器是将Java类加载到内存中，一般步骤是java源文件（.java文件）经过编译生成（.class文件），类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。 java.long.ClassLoader类 数组类的Class 对象不是由class 加载器创建的，而是根据Java运行时的需要自动创建的。 由getClassLoader（）返回的数组类的类加载器与其元素类的类加载器相同;, 如果元素类型是基本类型，那么数组类没有类加载器。 12345getParent() 返回委托的父类加载器findClass(String name) 使用指定的二进制查找类findLoadedClass(String name) 查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。defineClass(String name, byte[] b, int off, int len) 把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。 resolveClass(Class&lt;?&gt; c) 链接指定的类。, 这个（具有误导性的命名）方法可以被类加载器用来链接一个类。, 如果类 c已经被链接了，那么这个方法简单地返回。 类加载器类型 Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个： 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 我们可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。 除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。 类加载器关系，箭头指向的是父类。 双亲委派模型 ClassLoader 类使用委托模型来搜索类和资源。 , 关联的父类加载器。, 当请求查找类或资源时，ClassLoader实例会在尝试查找类或资源本身之前，将对类或资源的搜索委托给其父类加载器。, 虚拟机的内置类加载器称为“引导类加载器”，它本身不具有父类，但可以作为ClassLoader实例的父类。 类加载器代理模式 类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。 代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。 不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。 参考https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html 加载类的过程 因为代理机制所以类的加载首先代理给其他类进行加载尝试，这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。 定义加载器：完成类的加载工作，通过调用defineClass来实现的，在java虚拟机判断类是否相同使用。 初始加载器：启动类的加载过程是通过loadClass来实现的。 关系：一个类的定义加载器是它引用的其他类的初始加载器。 类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。 线程上下文类加载器线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 ###jvm内存结构 jvm java虚拟机，.java文件经过编译生成.class文件，jvm执行.class文件。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。因此实现java平台无关性。它是 Java 程序能在多平台间进行无缝移植的可靠保证 。 jvm是编译后java程序（.class文件）和硬件系统之间的接口 jvm=类加载器classloader+执行引擎execution engine+运行时数据区域runtime date area 类加载器将.class文件加载到jvm中的运行时数据区，执行引擎负责类文件是否执行 运行时数据区在所有线程间共享（方法区，堆） 运行时数据区线程私有（虚拟机栈，本地方法栈，程序计数器） 方法区各个线程共享的内存区域，它用于存储类的二进制文件，被虚拟机加载的类信息，常量，静态变量。 堆运行时数据区在所有线程间共享，用于存储类加载生成的java.lang,Class对象实例，几乎所有的对象实例都在这里分配内存。java堆被所有的线程共享的一块内存区域，在虚拟机启动时创建。 虚拟机栈虚拟机栈对所有线程是私有的，生命周期和线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用来存储局部变量，操作栈，动态链接，方法出口等信息。每个方法被调用到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈它也是线程私有的，本地方法栈和虚拟机栈差不多，不同就是虚拟机栈是为java方法服务，而本地方法栈是为Native方法服务。 程序计数器程序计数器是线程私有的，它的作用可以看做是当前线程所执行的字节码的行号指示器。参考：jvm ###GC垃圾回收 垃圾收集（Garbage Collection，GC），用于内存的动态分配和内存回收。 GC基本的算法标记清除法步骤：先将要回收的对象标记出来，在标记完成后统一回收所有标记的对象。 不足：1.效率不高 ​ 2.空间问题，回收标记的对象后产生许多琐碎的内存碎片，空间碎片太多可能导致以后在程序运行 时要获得一个大的对象存储空间时，空间不够因而触发另一次垃圾回收。 复制法步骤：将内存分为两块，每次只使用一个，当一个使用完后就将还存活的对象复制到另一个区域，并清除前一个区域。 缺点：内存缩小 目前商业的虚拟机都是这种算法回收新生代，将内存分为较大空间的Eden空间和两个较小的Survivor空间，每次使用Eden和一个Survivor空间，当回收时，将Eden和Survivor空间还存活的对象复制到另一个Survivor空间中，清除原来的Eden和Survivor空间。HotSpot虚拟机默认的Eden和Survivor空间大小是8:1 每次新生代内存空间为整个新生代容量的90%。 标记整理法复制法在对象存活率高时会复制多次，效率将会变低，而且不想浪费空间。 老年代使用标记整理法 步骤：和标记清除法一样，但后面不是清除，而是让所有存活的对象向一端移动，然后清除端边界以外的内存。 分代收集法当前商业虚拟机的垃圾回收都使用分代手机法。 根据对象的生命周期将内存划分成几块。一般将java堆分成新生代和老年代，这样根据不同代的特点使用不同的算法 ，新生代中，每次垃圾回收时会发现大量的对象挂了，只有少量存活，所以一般使用复制算法。 而老年代中因为对象的存活率高，没有额外空间对他进行分配担保，就使用“标记消除”或“标记整理”来进行垃圾回收。 ###GC调优 Java GC分析参考：jvm系列(五)Java GC 分析 调优命令 Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 jmap，JVM Memory Map命令用于生成heap dump文件 jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 jstack，用于生成java虚拟机当前时刻的线程快照。 jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。 详细的命令使用参考这里：jvm系列(四):jvm调优-命令篇 调优工具 常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。 jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控 jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。 MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 GChisto，一款专业分析gc日志的工具]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stomp面向简单文本的消息传递协议]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2FStomp%E9%9D%A2%E5%90%91%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Stomp面向简单文本的消息传递协议是什么：STOMP是简单（或流式）文本定向消息协议。 STOMP提供可互操作的线路格式，以便STOMP客户端可以与任何STOMP消息代理进行通信，以便在多种语言，平台和代理之间提供简单和广泛的消息互操作性。 设计： STOMP是一个非常简单易用的协议，来自HTTP设计学院; 服务器端可能很难实现，但编写客户端以便连接起来非常容易。例如，您可以使用Telnet登录到任何STOMP代理并与其交互！ WebSocket是一种在单个Tcp连接上进行全双工通讯的协议在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 背景：WebSocket协议是由HTML5定义的，它能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 Websocket使用ws或wss的统一资源标志符，类似于HTTPS，其中wss表示在TLS之上的Websocket。 Websocket使用和 HTTP 相同的 TCP 端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。 优点：1.较少的控制开销。 在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。2.更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。3.保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。4.更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。5.可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。6.更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。 握手协议：WebSocket 是独立的、创建在 TCP 上的协议。Websocket 通过 HTTP/1.1 协议的101状态码进行握手。为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。 例子:一个典型的Websocket握手请求如下：客户端请求1234567GET / HTTP/1.1Upgrade: websocket //表示希望升级到Websocket协议。Connection: Upgrade //表示客户端希望连接升级Host: example.com Origin: http://example.comSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ== //Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。Sec-WebSocket-Version: 13 //表示支持的Websocket版本。 服务器回应12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=Sec-WebSocket-Location: ws://example.com/ HTTPS超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过电脑网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。 主要思想HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。 HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构（如Symantec、Comodo、GoDaddy和GlobalSign等）（意即“我信任证书颁发机构告诉我应该信任的”）。因此，一个到某网站的HTTPS连接可被信任，当且仅当： 用户相信他们的浏览器正确实现了HTTPS且安装了正确的证书颁发机构；用户相信证书颁发机构仅信任合法的网站；被访问的网站提供了一个有效的证书，意即，它是由一个被信任的证书颁发机构签发的（大部分浏览器会对无效的证书发出警告）；该证书正确地验证了被访问的网站（如，访问https://example.com时收到了给example.com而不是其它组织的证书）；或者互联网上相关的节点是值得信任的，或者用户相信本协议的加密层（TLS或SSL）不能被窃听者破坏。HTTPS不应与在 RFC 2660 中定义的安全超文本传输协议（S-HTTP）相混淆。 与HTTP差别与HTTP的URL由“http://”起始且默认使用端口80不同，HTTPS的URL由“https://”起始且默认使用端口443。 HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，并在正确配置时被认为是安全的。 HTTP超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 协议概述HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMap ：带符号右移。正数右移高位补0，负数右移高位补1。比如： 4 &gt;&gt; 1，结果是2；-4 &gt;&gt; 1，结果是-2。-2 &gt;&gt; 1，结果是-1。 ：无符号右移。无论是正数还是负数，高位通通补0。 对于正数而言，&gt;&gt;和&gt;&gt;&gt;没区别。 简介1.HashMap基于哈希的map接口实现。2.HashMap 类大致相当于 Hashtable ，只是它是非同步的并且允许为空值。3.HashMap根据键的hashCode值存储数据，一般直接可以定位到它的值，但他遍历顺序是不确定的。HashMap只允许key中只有一个null，而value可以是多个，HashMap是非线程安全的。如果要满足线程安全，可以用Collection的synchronizedMap方法使的HashMap具有线程安全的能力，或使用ConcurrentHashMap。 内部实现从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。 1.HashMap中有Node&lt;K,V&gt;[] table 即哈希桶数组。HashMap的内部类123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 2.HashMap构造方法。12345678910111213141516/**使用指定的初始容量和指定加载因子构造一个空的HashMap*/public HashMap(int initialCapacity, float loadFactor)&#123;...&#125;/**使用指定的初始容量和默认加载因子（0.75）构造一个空的HashMap*/ public HashMap(int initialCapacity)&#123;...&#125; /* *使用默认的初始容量（16）和默认加载因子（0.75）构造一个空的HashMap */ public HashMap() &#123;...&#125; /* *使用与指定的&lt;tt&gt; Map &lt;/ tt&gt;相同的映射构造一个新的HashMapHashMap用默认加载因子 *（0.75）和一个初始容量来创建，该容量足以将映射保存在指定的Map */ public HashMap(Map&lt;? extends K, ? extends V&gt; m)&#123;...&#125; 3.jdk1.8 HashMap的put方法源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i;// 判断table是否为空，创建默认大小 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length;// 计算index，并对null做处理 （有点懵） if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; HashMap.Node&lt;K,V&gt; e; K k; //节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //判断是否是红黑树 else if (p instanceof HashMap.TreeNode) e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //该链为链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //key存在就覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //超过阈值就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 4.HashMap 扩容扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。 （1）.jdk1.7的扩容是当容量大于阈值时，使用大的数组代替小的数组 12345678910111213141516171819202122232425262728293031 void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 &#125; //用于将原来的数组中的数据拷贝到新的数组 void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null);&#125;&#125; &#125; jdk1.7扩容后会重新计算每个元素在数组中的位置，当put时数据会放在链表的前面，所以最先插入的数据应该在链表的末尾。（2）.jdk1.8123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final HashMap.Node&lt;K,V&gt;[] resize() &#123; HashMap.Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //判断是否大于最大容量 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //当小于最大容量时，扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) HashMap.Node&lt;K,V&gt;[] newTab = (HashMap.Node&lt;K,V&gt;[])new HashMap.Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; HashMap.Node&lt;K,V&gt; e; //遍历老数组，并释放它 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) //e的哈希和新的容量-1做与运算 得出在新数组的位置 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof HashMap.TreeNode)//判断它是红黑树 ((HashMap.TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 HashMap.Node&lt;K,V&gt; loHead = null, loTail = null; HashMap.Node&lt;K,V&gt; hiHead = null, hiTail = null; HashMap.Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 线程安全性HashMap是非线程安全的，线程安全的ConcurrentHashMap。在多线程情况下HashMap会产生死循环]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F09%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[##两数之和 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 使用hashmap将数组中的值作为key，下标作为value值放入map中，查的时候只找map中是否有target-nums[i]，则返回的就是i和target-nums[i]的下标。1234567891011121314public static int[] twoSum1(int[] nums, int target) &#123; if (nums == null) &#123; return null; &#125; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(target-nums[i])) &#123; return new int[]&#123;map.get(target - nums[i]), i&#125;; &#125;else &#123; map.put(nums[i], i); &#125; &#125; return null; &#125; 返回两个数的值指针i指向数组的头，而j指向屁股，然后直到他俩相遇123456789101112131415161718192021222324252627282930public static int[] twoSum(int[] nums, int target) &#123; if (nums == null) &#123; return null; &#125; int i = 0; int j = nums.length - 1; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int x = 0; x &lt; nums.length; x++) &#123; while (i &lt; x &amp;&amp; j &gt; x) &#123; if (Math.abs(i - j) == 1) &#123; break; &#125; if (j &gt;= 0 &amp;&amp; target &lt; nums[j]) &#123; j--; &#125; if (i &lt; nums.length &amp;&amp; j &gt;= 0 &amp;&amp; nums[i] + nums[j] == target) &#123; list.add(nums[i]); i++; list.add(nums[j]); j--; &#125; &#125; &#125; int[] re = new int[list.size()]; for (int i1 = 0; i1 &lt; re.length; i1++) &#123; re[i1] = list.get(i1); &#125; return re; &#125; 123456789101112131415161718func twoSum(nums []int, target int) []int &#123; if nums==nil &#123; return nil &#125; m:=make(map[int]int) for i:=0;i&lt;len(nums) ;i++ &#123; captial,ok:=m[target-nums[i]] if ok&#123; s:=[] int&#123;captial,i&#125; return s &#125;else &#123; m[nums[i]]=i &#125; &#125;return nil&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组加一]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2F%E6%95%B0%E7%BB%84%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[加一 给定一个非负整数组成的非空数组，在该数的基础上加一，返回一个新的数组。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 #####Java：1234567891011121314151617public static int[] plusOne(int[] digits) &#123; int creay=1; for (int i=digits.length-1;i&gt;=0;i--)&#123; if (creay==0)&#123; return digits; &#125; int tmp=digits[i]+creay; creay=tmp/10; digits[i]=tmp%10; &#125; if (creay!=0) &#123; int [] re=new int[digits.length+1]; re[0]=1; return re; &#125; return digits;&#125; #####go:1234567891011121314151617func plusOne(a [] int) [] int&#123; crray:=1 for i:=len(a)-1;i&gt;=0 ; i-- &#123; if crray==0 &#123; return a &#125; tmp:=a[i]+crray crray=tmp/10 a[i]=tmp%10 &#125; if crray!=0 &#123; var newa [] int=make([]int,len(a)+1) newa[0]=1 return newa &#125; return a&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 并发编程实战 读书笔记]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2Fjava-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[对象的共享简述：已知同步方法和同步代码块，可以以原子性的方式执行。同步还可以通过内存可见性实现。当多个线程对一个公共的数据进行set和get ，如果set和get方法不用synchronized修饰是非线程安全的。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 失效数据多个线程调用一个数据时，一个线程获取的数据不是最新的，而是一个过期的数据。失效问题：一个线程set后另一个线程get的数据可能不是最新的获知可能获取不到。 非原子的64位操作非volatile类型double，long变量，jvm在对64位的double或long变量的读操作或写操作是分为高位32和低位32位进行操作的，在进行操作时可能是取一个数的高32位而取另一个数的低32位。所以在多线程情况下要使用volatile关键字对double，long变量进行修饰。 volatile变量volatile变量是一种稍微的同步机制。volatile变量不会存在寄存器或者对其他处理器不可见的地方，因此每次读取的数据都是最新的。volatile是一种比synchronization稍微弱的同步机制。访问volatile变量时不需要加锁操作，因此也就不会使执行线程阻塞的。正确使用方法：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如，初始化或关闭）局限性：volatile变量通常用做某个操作完成，发生中断或者状态的标志。 ####### 加锁机制能可以确保原子性和可见性，而volatile只能确保可见性。使用volatile前提：1.对变量的写入操作不依赖变量的当前值；2.该变量不会与其他状态变量一起纳入不变性条件中。3.在访问时不需要加锁。 线程封闭一种避免使用同步的方法就是不共享数据。线程封闭是实现线程安全性的最简单的方式之一。Ad-hoc线程封闭Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担，它是非常脆弱的，因为没有任何一种语言特性，能将对象封闭到目标线程上。一般不使用。栈封闭在栈封闭中，只能通过局部变量才能访问对象。局部变量封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭也被称为线程内部使用或线程局部使用。比Ad-hoc更加易于维护，更加健壮。ThreadLocal类ThreadLocal类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。ThreadLoacl类中使用map存储数据，key为线程而value为变量副本。ThreadLocal类中有一个ThreadLocalMap内部类，用来存储副本key为线程，而value为变量的副本。 不变性什么是不变性不变性指对象的状态不改变。不变性对象一定是线程安全的。满足条件1.对象创建后其状态不再改变2.对象的所有域都是final类型的3.对象是正确创建的（在对象创建之间，this引用没有逸出） Final域final域能确保初始化过程中的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象的时无须同步。 除非需要更高的可见性，否则应将所有的域都声明为私有域除非需要某个域是可变的，否则应将其声明为final域####使用volatile类型来发布不可变对象在某些情况下，不可变对象能提供一种弱形式的原子性，对于在访问和更新多个相关变量的竞争问题，可以将这些变量存储在一个不变对象中来消除。如果是一个可变对象，只能用锁来确保原子性。如果是一个不可变对象，当一个线程获得他的值后，另一个线程不能改变对象的状态。更新这些变量时，创建一个新的容器对象，但其他使用原有对象的线程仍然会看到对象处于一致状态。使用不可变对象容器的volatile类型引用以缓存最新的结果。volatile在修饰不可变对象容器时是线程安全的。 ##安全发布为什么要安全发布要在足够同步的情况下发布对象，不安全的发布会导致其他线程看见尚未完成的对象。对象在不完全发布时会出现两个问题：1.当一个对象未安全发布时除了发布对象的线程外其他线程看见的对象要么是旧值，要么是空引用。2.某一个线程在第一次读取时得到失效值，而再一次读取这个域时会得到一个更新值。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机2]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F06%2F03%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路：因为要获取最大利润，所以只要后面比前面的大就获利123456789101112131415161718192021222324252627282930313233343536java版本:class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices==null || prices.length==0)&#123; return 0; &#125; int min=prices[0]; int sum=0; for (int i=1;i&lt;prices.length;i++)&#123; if (prices[i]&gt;min)&#123; sum+=prices[i]-min; min=prices[i]; &#125;else &#123; min=prices[i]; &#125; &#125; return sum; &#125;&#125; 1234567891011121314151617go版本:func max(a []int) int &#123; if len(a)==0 &#123; return 0 &#125; min := a[0] sum :=0 for i:=0;i&lt;len(a) ;i++ &#123; if min&lt;a[i] &#123; sum+=(a[i]-min) min=a[i] &#125;else &#123; min=a[i] &#125; &#125; return sum&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F29%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[旋转数组给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明:123- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。- 要求使用空间复杂度为 O(1) 的原地算法。 方法一：123456789101112-利用length-k将数组分为两部分-分别调换两段数组-再转化整个数组例如： 1 2 3 4 5 6 7 如果k = 3 的话， 会变成 5 6 7 1 2 3 4 1 2 3 4 5 6 7 middle = 7 - 3 = 4，分为左边 4个数字，右边 3个数字 4 3 2 1 7 6 5 分别把左右swap 一下 5 6 7 1 2 3 4 把总数组swap 一下就会得到答案​` java:​123456789101112131415161718192021class Solution &#123; public void rotate(int[] nums, int k) &#123; if (nums.length==0||nums==null||k%nums.length==0)&#123; return ; &#125; int t=k%nums.length; int sta=nums.length-t; swap(nums,0,sta-1); swap(nums,sta,nums.length-1); swap(nums,0,nums.length-1); &#125; public static void swap(int[] a, int i, int j) &#123; while(i&lt;j) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; &#125;&#125; go:12345678910111213141516171819func rotate(nums []int,k int) &#123; if len(nums)==0 || nums==nil ||k%len(nums)==0 &#123; return &#125; t:=k%len(nums) sta:=len(nums)-t swap(nums,0,sta-1) swap(nums,sta,len(nums)-1) swap(nums,0,len(nums)-1)&#125;func swap(a [] int,i int,j int) &#123; for i&lt;j&#123; tmp:=a[i] a[i]=a[j] a[j]=tmp i++ j-- &#125;&#125; 方法二：12-创建一个大小相同的数组-然后将原数组中的值写到新数组中，关键点（a[(i + k) % nums.length] = nums[i];） 12345678public static int[] rotate1(int[] nums, int k) &#123; int[] a = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; //关键点 a[(i + k) % nums.length] = nums[i]; &#125; return a; &#125; go:12345678func rotate1(nums [] int,k int) []int&#123; //go中切片 相当于动态数组 切片的长度不是固定的，在追加时可能使的容量增大 var a [] int=make([]int,len(nums)) for i:=0;i&lt;len(nums) ;i++ &#123; a[(i+k)%len(nums)]=nums[i] &#125; return a&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql配置]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fmysql%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[踩过的坑 防止再掉 1.mysql文件和文件夹(linux 配置文件文件后缀为cnf) bin 放可执行性文件 include 存放头文件 lib 存放库文件 share 存放字符集，语言等信息 my.ini mysql软件正在使用的配置文件 my-huge.ini 当mysql软件为超大型数据库时使用的配置文件 my-small.ini 当mysql软件为小型数据库时使用的配置文件 my-template.ini 配置文件模板 2.my.ini配置文件中的内容可实现修改数据库实例的参数（linux中为my.cnf） 客户端 [mysql] 客户端的端口号 prot=3306 客户端默认字符集 default-character-set=utf8 [mysqld] 服务端 prot=3306 数据库服务器的安装目录 basedir=？？？？ mysql数据库数据文件的目录 datadir=？？？ mysql软件端的字符集 character-set-server=utf8 mysql软件的存储引擎 default-storage-engine=INNODB mysql最大连接数 max-connections=100 mysql软件缓存 query_cache_size=0 mysql中可以打开表的总数 table_cache=256 mysql软件内存中可以存储临时表的最大值 tem_table_size=9m mysql软件可以保留的客户端链接线程数 thread_cache_size=8 mysql软件重建索引时允许的最大临时文件的大小 myisam_max_sort_file_size=10G mysql软件重建索引时允许的最大缓存的大小 myisam_sort_buffer_size=17m mysql软件中最大关键字缓存的大小 key_buffer_size=10m mysql软件全扫描myisam表时的缓存大小 read_buffer_size=6k mysql软件可以插入排序好的数据的缓存的小 read_rnd_buffer_size=256k mysql软件用户排序时缓存的大小 sort_buffer_size=256k 关于INNODB存储引擎参数设置附加内存池大小 innodb_additional_mem_pool_size=2m 关于提交日志的时机 innodb_flush_log_at_trx_commit=1 存储日志数据的缓存区的大小 innodb_log_buffer_size=1m 缓存池中缓存区的大小 innodb_buffer_pool_size=17m 日记文件的大小 innodb_log_file_size=10m 允许线程的最大数 innodb_thread_concurrency=8]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 和 StringBuffer 和 StringBuilder]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2FString%20%E5%92%8C%20StringBuffer%20%E5%92%8C%20StringBuilder%2F</url>
    <content type="text"><![CDATA[三者不同点 1，string 类是不可变的，一旦创建了String对象，那她就无法改变2，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 线程安全StringBuffer是线程安全的，而StringBuilder是非线程安全的。 运行速度1.StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 2.StringBuffer 和 StringBuilder 长度可变 StringBuffer &amp;&amp; StringBuilder &amp;&amp; String StringBuffer：一个线程安全的，可变的字符序列。字符串缓冲区就像一个String，但可以修改。在任何时候它都包含一些特定的字符序列，但是序列的长度和内容可以通过某些方法调用来改变。字符串缓冲区对于多线程来说是安全的。这些方法在必要时进行同步，以便任何特定实例上的所有操作的行为就好像它们以某种连续顺序发生，这与每个涉及的单个线程所进行的方法调用的顺序一致。 上的主要操作StringBuffer是 append和insert方法，其被重载，以便接受任何类型的数据。每个函数都有效地将给定的数据转换为字符串，然后将该字符串的字符附加或插入到字符串缓冲区中。该 append方法总是将这些字符添加到缓冲区的末尾; 该insert方法在指定的点添加字符。 如果sb指的是a的一个实例StringBuffer，那么sb.append(x)效果与之相同 sb.insert(sb.length(), x)。 每个字符串缓冲区都有一个容量 只要包含在字符串缓冲区中的字符序列的长度不超过容量，就不需要分配新的内部缓冲区数组。如果内部缓冲区溢出，它会自动变大。从版本JDK 5开始，这个类已经补充了一个为单个线程设计的等价类StringBuilder。由于StringBuilder类支持所有相同的操作，所以通常会优先使用StringBuilder类，但速度更快，因为它不执行同步操作。 StringBuilder：一个可变的字符序列。这个类提供了一个兼容的API StringBuffer，但不保证同步。这个类被设计成在StringBuffer单个线程正在使用字符串缓冲区的地方（如通常情况下）用作嵌入式替换 。在可能的情况下，建议优先使用此类， StringBuffer因为在大多数实现中它会更快。 上的主要操作StringBuilder是 append和insert方法，其被重载，以便接受任何类型的数据。每个有效地将给定的数据转换为一个字符串，然后将该字符串的字符追加或插入到字符串生成器。该 append方法总是在构建器的最后添加这些字符; 该insert方法在指定的点添加字符。 StringBuilder多线程使用的实例不安全。如果需要这种同步，则建议StringBuffer使用。 String：String类代表字符串。Java程序中的所有字符串文字，例如”abc”，都被实现为这个类的实例。字符串是不变的; 他们的价值创造后不能改变。字符串缓冲区支持可变字符串。因为String对象是不可变的，所以它们可以共享。 StringBuffer源码1.StringBuffer一个线程安全的，可变的字符序列。2.StringBuffer就像一个String，但可以修改。在任何时间点，它都包含一些特定的字符列，但是序列的长度和内容可以通过某些方法调用来改变3.字符串缓冲区对于多线程使用是安全的。 方法在必要时进行同步，以便任何特定实例上的所有操作的行为就好像它们以某种连续顺序发生一样，这与每个涉及的各个线程所进行的方法调用的顺序一致。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123; /** * 构造一个没有字符的字符串缓冲区，并且字符的初始容量为16个字符。 */ public StringBuffer() &#123; super(16); &#125; /* *构造一个没有字符的字符串缓冲区，并且指定的初始容量 */ public StringBuffer(int capacity) &#123; super(capacity); &#125; /* *构造一个字符串缓冲区，初始化为*指定字符串的内容。, 字符串缓冲区的初始容量是16加上字符串参数 *的长度。 */ public StringBuffer(String str) &#123; super(str.length() + 16); append(str); &#125; /** * 构造一个字符串缓冲区，其中包含与指定CharSequence相同的字符字符串缓冲区的初始 *容量是 16加上CharSequence参数的长度。 * @param seq */ public StringBuffer(CharSequence seq) &#123; this(seq.length() + 16); append(seq); &#125; //最常用的append 将sb加到该序列 synchronized修饰线程安全的 public synchronized StringBuffer append(StringBuffer sb) &#123; toStringCache = null; super.append(sb); return this; &#125; @Override public synchronized StringBuffer append(CharSequence s) &#123; toStringCache = null; super.append(s); return this; &#125; @Override synchronized StringBuffer append(AbstractStringBuilder asb) &#123; toStringCache = null; super.append(asb); return this; &#125; &#125; ####StringBufer类final修饰说明这个类是“终态的”,不能被继承。类中的方法默认是final所以不能被覆盖。final方法 方法将不能被覆盖 #####StringBuilder 一个可变的字符序列，该类提供一个api与stringCuffer兼容，但不是同步的。这个类被设计在单个线程使用字符串缓存的地方用作（StringBuffer）的嵌入替代品，在大多数实现中它更快。 1234567891011121314151617181920/**StringBuilder和stringBuffer 继承和实现的接口相同*/public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123;/**构造方法和StringBuffer相同*/ public StringBuilder() &#123; super(16); &#125; /* *不同就是append方法 StringBuffer的append方法被synchronized修饰所以是线程安 *全的 */ public StringBuilder append(StringBuffer sb) &#123; super.append(sb); return this; &#125; #####String是不可变的，他们的值创建后无法改变]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[java反射一 概念1.JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。通过class类调用自身的方法属性等二 class对象获得Class对象的由来是将class文件读入内存，并为之创建一个Class对象。通过这个对象可以获取类的相关信息 获取Class对象的三种方式1.1 Object ——&gt; getClass();1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性1.3 通过Class类的静态方法：forName（String ?className）(常用) public static void main(String[] args) { T515 t515=new T515(); /** * 1.返回此的运行时类 */ Class aClass=t515.getClass(); /** * 2.获取class对象 */ Class aClass1=T515.class; try { /** * 3.用给定的字符串名返回与类或接口关联的Class对象 */ Class aClass2 = Class.forName(&quot;T515.T515&quot;); System.out.println(aClass2==aClass); }catch (Exception e){ e.printStackTrace(); } System.out.println(aClass==aClass1); } 结果为 两个true 三 可以通过class对象获取类的相关类信息]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis 一对一级联 一对多]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F27%2Fmybats%E7%BA%A7%E8%81%94%2F</url>
    <content type="text"><![CDATA[一：一对一 用association 一 建表 course 课程与score 课程成绩表是一对一关系 course课程表 score课程成绩表 连接数据库dbconf.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN” “http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 写一个db.properties文件jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybajdbc.username=rootjdbc.password=××× 二 使用mybatis插件自动生成相对应表的配置文件 CourseMapper.xml &lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; SELECT myba.course.* from myba.course WHERE coid=#{coid} CourseMapper接口*CourseMapper.xml是对接口的实现 所以 select 的id与接口中方法名相同package com.ygy.mapper; import com.ygy.model.Course;import com.ygy.model.CourseExample;import java.util.List;import org.apache.ibatis.annotations.Param; public interface CourseMapper { public Course selectcou(int id);} ScoreMapper.xml&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; select myba.score. from myba.score WHERE myba.score.scsid=#{id} ScoreMapper接口package com.ygy.mapper;import com.ygy.model.Score;import com.ygy.model.ScoreExample;import java.util.List;import org.apache.ibatis.annotations.Param;public interface ScoreMapper { public Score selectscore(int id);}在score的model中加上private Course course;//get set方法三 测试@Test public void main(){ SqlSessionFactory sqlSessionFactory; InputStream inputStream; try { inputStream= Resources.getResourceAsStream(“dbconf.xml”); sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); sqlSession=sqlSessionFactory.openSession()； //SCORC和course一对一 ScoreMapper scoreMapper=sqlSession.getMapper(ScoreMapper.class); Score score=scoreMapper.selectscore(1); System.out.println(score.getCourse().getConame()); } catch (IOException e) { e.printStackTrace(); }finally { sqlSession.close(); }二：一对多 collection加入学生表stud插件生成对应的接口什么的&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; SELECT myba.stud. FROM myba.stud WHERE myba.stud.sid=#{id} 接口package com.ygy.mapper; import com.ygy.model.Stud;import com.ygy.model.StudExample;import java.util.List;import org.apache.ibatis.annotations.Param; public interface StudMapper { public Stud selectsud(int id);} 测试@Test public void main(){ SqlSessionFactory sqlSessionFactory; InputStream inputStream; try { inputStream= Resources.getResourceAsStream(&quot;dbconf.xml&quot;); sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); sqlSession=sqlSessionFactory.openSession(); StudMapper studMapper=sqlSession.getMapper(StudMapper.class); Stud stud=studMapper.selectsud(1); System.out.println(stud.getScoreList().get(1).getMark()); } catch (IOException e) { e.printStackTrace(); }finally { sqlSession.close(); } 结果：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F23%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[mybatis自动生成代码插件]]></title>
    <url>%2Fyueguoyu.github.io%2F2018%2F05%2F23%2Fmybatis%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一.generatorconfig.xml文件12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;mysqlgenerator&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ygy&quot; userId=&quot;root&quot; password=&quot;***&quot; /&gt; 1&lt;!--targetProject 后面跟的是model放的位置 targetPackage放的包名--&gt; 123456789101112 &lt;javaModelGenerator targetPackage=&quot;com.nomico271.model&quot; targetProject=&quot;src&quot; /&gt; &lt;sqlMapGenerator targetPackage=&quot;com.nomico271.mapper&quot; targetProject=&quot;src&quot; /&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.nomico271.mapper&quot; targetProject=&quot;src&quot; /&gt; &lt;table tableName=&quot;ygy1&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; ##二.pox.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;generator&lt;/groupId&gt; &lt;artifactId&gt;generator&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;generator Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt;//××引包 &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;generator&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 12 12完成上面的配置 然后打开maven--&gt;plugins---&gt;mybatis-generator---&gt;mybatis-generator:generate运行mybatis-generator:generate完成自动生成所需要的文件 123456789101112131415161718192021222324252627282930313233## 三.添加数据到数据库中import com.nomico271.model.Ygy1;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;public class main &#123; static Reader reader; static SqlSession session; public static void main(String[] args) &#123; try &#123; reader= Resources.getResourceAsReader(&quot;ygy.xml&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader); session=sqlSessionFactory.openSession(); Ygy1 ygy1=new Ygy1(); ygy1.setId(3); ygy1.setName(&quot;sdhuaik&quot;); session.insert(&quot;insert&quot;,ygy1); session.commit(); session.close(); &#125; &#125;&#125;运行程序显示 说明添加成功（其他删，改，查相似）]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
