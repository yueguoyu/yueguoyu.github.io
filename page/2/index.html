<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/yueguoyu.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/yueguoyu.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/yueguoyu.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/yueguoyu.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/yueguoyu.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/yueguoyu.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/yueguoyu.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="YgY" />










<meta property="og:type" content="website">
<meta property="og:title" content="YgY">
<meta property="og:url" content="https://github.com/yueguoyu/yueguoyu.github.io/page/2/index.html">
<meta property="og:site_name" content="YgY">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YgY">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/yueguoyu.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/yueguoyu/yueguoyu.github.io/page/2/"/>





  <title>YgY</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/yueguoyu.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YgY</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活就是这样</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/yueguoyu.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/yueguoyu.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/yueguoyu.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/yueguoyu.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/yueguoyu.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/yueguoyu.github.io/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yueguoyu/yueguoyu.github.io/yueguoyu.github.io/2018/07/06/102. 二叉树的层次遍历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="越狱">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2018/05/28/5b0b594044b97.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YgY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/yueguoyu.github.io/2018/07/06/102. 二叉树的层次遍历/" itemprop="url">二叉树的层次遍历1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-06T15:16:16+08:00">
                2018-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yueguoyu.github.io/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102. 二叉树的层次遍历"></a>102. 二叉树的层次遍历</h3><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>解法：</strong></p>
<p>二叉树的层遍历使用队列，将节点放入队列中，当节点出队时判断该节点的左，右子树是否为空，如果不为空将其放入队列中，本题因为题目要求每次创建一个新的list将每一层的节点添加到list中，size为队列的大小，用来判断队列中的节点是否全部出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自上而下层遍历</span><br><span class="line"> * @param root</span><br><span class="line"> */</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; cen2(TreeNode root)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;();</span><br><span class="line">    if (root==null)&#123;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line">//使用队列</span><br><span class="line">    LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;();</span><br><span class="line">    treeNodes.add(root);</span><br><span class="line">    while(!treeNodes.isEmpty())&#123;</span><br><span class="line">        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        int size=treeNodes.size();</span><br><span class="line">        for (int i=0;i&lt;size;i++)&#123;</span><br><span class="line">            TreeNode n=treeNodes.pop();</span><br><span class="line">            list.add(n.val);</span><br><span class="line">            if (n.l!=null)&#123;</span><br><span class="line">                treeNodes.add(n.l);</span><br><span class="line">            &#125;</span><br><span class="line">            if (n.r!=null)&#123;</span><br><span class="line">                treeNodes.add(n.r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lists.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    return lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yueguoyu/yueguoyu.github.io/yueguoyu.github.io/2018/07/06/二叉树的创建，前序，中序，后序，层遍历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="越狱">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2018/05/28/5b0b594044b97.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YgY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/yueguoyu.github.io/2018/07/06/二叉树的创建，前序，中序，后序，层遍历/" itemprop="url">二叉树的创建，前序，中序，后序，层遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-06T15:13:36+08:00">
                2018-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yueguoyu.github.io/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉树的创建，前序，中序，后序，层遍历"><a href="#二叉树的创建，前序，中序，后序，层遍历" class="headerlink" title="二叉树的创建，前序，中序，后序，层遍历"></a>二叉树的创建，前序，中序，后序，层遍历</h2><p>深度优先搜素用栈，广度优先用队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">package T74;</span><br><span class="line"></span><br><span class="line">import sun.awt.image.ImageWatched;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class BinTree &#123;</span><br><span class="line">    private int size;</span><br><span class="line">    /**</span><br><span class="line">     * root为二叉树的头节点</span><br><span class="line">     */</span><br><span class="line">    private TreeNode root;</span><br><span class="line">    private  int [] date;</span><br><span class="line">    BinTree(int [] date)&#123;</span><br><span class="line">        this.date=date;</span><br><span class="line">        this.size=date.length;</span><br><span class="line">        this.root=CreatTree(0);</span><br><span class="line">    &#125;</span><br><span class="line">    class TreeNode&#123;</span><br><span class="line">        TreeNode l;</span><br><span class="line">        TreeNode r;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode(int val)&#123;</span><br><span class="line">            this.val=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *创建二叉树</span><br><span class="line">     * index为date数组的下标</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public TreeNode CreatTree(int index)&#123;</span><br><span class="line">        if (index&gt;=size)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode treeNode=new TreeNode(date[index]);</span><br><span class="line">        treeNode.l=CreatTree(2*index+1);</span><br><span class="line">        treeNode.r=CreatTree(2*(index+1));</span><br><span class="line">        return treeNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 递归实现前序遍历</span><br><span class="line">     * @param root</span><br><span class="line">     */</span><br><span class="line">    public void qx(TreeNode root)&#123;</span><br><span class="line">        if (root==null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(root.val+&quot; &quot;);</span><br><span class="line">        qx(root.l);</span><br><span class="line">        qx(root.r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用栈实现</span><br><span class="line">     * @param root</span><br><span class="line">     */</span><br><span class="line">    public void qx1(TreeNode root)&#123;</span><br><span class="line">        if (root==null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">        while(root!=null||!stack.empty())&#123;</span><br><span class="line">            while(root!=null)&#123;</span><br><span class="line">                System.out.print(root.val+&quot; &quot;);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.l;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!stack.empty())&#123;</span><br><span class="line">                root=stack.pop();</span><br><span class="line">                root=root.r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 中序 递归</span><br><span class="line">     * @param root</span><br><span class="line">     */</span><br><span class="line">    public void zx(TreeNode root)&#123;</span><br><span class="line">        if (root!=null)&#123;</span><br><span class="line">            zx(root.l);</span><br><span class="line">            System.out.print(root.val+&quot; &quot;);</span><br><span class="line">            zx(root.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 栈实现 中序</span><br><span class="line">     * @param root</span><br><span class="line">     */</span><br><span class="line">    public void zx1(TreeNode root)&#123;</span><br><span class="line">        if (root==null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">        while (root!=null||!stack.empty())&#123;</span><br><span class="line">            while(root!=null)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.l;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!stack.empty())&#123;</span><br><span class="line">                root=stack.pop();</span><br><span class="line">                System.out.print(root.val+&quot; &quot;);</span><br><span class="line">                root=root.r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 递归 后序</span><br><span class="line">     * @param root</span><br><span class="line">     */</span><br><span class="line">    public void hx(TreeNode root)&#123;</span><br><span class="line">        if (root!=null)&#123;</span><br><span class="line">            hx(root.l);</span><br><span class="line">            hx(root.r);</span><br><span class="line">            System.out.print(root.val+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 栈实现  后序</span><br><span class="line">     * @param root</span><br><span class="line">     */</span><br><span class="line">    public void hx1(TreeNode root)&#123;</span><br><span class="line">      if (root==null)&#123;</span><br><span class="line">          return ;</span><br><span class="line">      &#125;</span><br><span class="line">      Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">      //游标list指向节点的右子树，遍历完指向节点</span><br><span class="line">      TreeNode list=null;</span><br><span class="line">      while(root!=null||!stack.empty())&#123;</span><br><span class="line">          while(root!=null)&#123;</span><br><span class="line">              stack.push(root);</span><br><span class="line">              root=root.l;</span><br><span class="line">          &#125;</span><br><span class="line">          root=stack.peek();</span><br><span class="line">          //如果节点的右子树为空或者已经遍历完</span><br><span class="line">          if (root.r==null||root.r==list)&#123;</span><br><span class="line">              System.out.print(root.val+&quot; &quot;);</span><br><span class="line">              root=stack.pop();</span><br><span class="line">              list=root;</span><br><span class="line">              root=null;</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">              root=root.r;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 层遍历</span><br><span class="line">     * @param root</span><br><span class="line">     */</span><br><span class="line">    public void cen(TreeNode root)&#123;</span><br><span class="line">        if (root==null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; q=new LinkedList&lt;&gt;();</span><br><span class="line">         q.add(root);</span><br><span class="line">         while(!q.isEmpty())&#123;</span><br><span class="line">             root=q.poll();</span><br><span class="line">             System.out.print(root.val+&quot; &quot;);</span><br><span class="line">             if (root.l!=null)&#123;</span><br><span class="line">                 q.add(root.l);</span><br><span class="line">             &#125;</span><br><span class="line">             if (root.r!=null)&#123;</span><br><span class="line">                 q.add(root.r);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自下而上的层遍历</span><br><span class="line">     * 从叶子节点所在层到根节点所在的层，逐层从左向右遍历</span><br><span class="line">     * @param root</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; cen1(TreeNode root)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;();</span><br><span class="line">        if (root==null)&#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;();</span><br><span class="line">        treeNodes.add(root);</span><br><span class="line">        while(!treeNodes.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">           int size=treeNodes.size();</span><br><span class="line">           for (int i=0;i&lt;size;i++)&#123;</span><br><span class="line">               TreeNode n=treeNodes.pop();</span><br><span class="line">               list.add(n.val);</span><br><span class="line">               if (n.l!=null)&#123;</span><br><span class="line">                   treeNodes.add(n.l);</span><br><span class="line">               &#125;</span><br><span class="line">               if (n.r!=null)&#123;</span><br><span class="line">                   treeNodes.add(n.r);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           lists.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists1=new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i=lists.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">            lists1.add(lists.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return lists1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自上而下层遍历</span><br><span class="line">     * @param root</span><br><span class="line">     */</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; cen2(TreeNode root)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;();</span><br><span class="line">        if (root==null)&#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; treeNodes=new LinkedList&lt;&gt;();</span><br><span class="line">        treeNodes.add(root);</span><br><span class="line">        while(!treeNodes.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">            int size=treeNodes.size();</span><br><span class="line">            for (int i=0;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode n=treeNodes.pop();</span><br><span class="line">                list.add(n.val);</span><br><span class="line">                if (n.l!=null)&#123;</span><br><span class="line">                    treeNodes.add(n.l);</span><br><span class="line">                &#125;</span><br><span class="line">                if (n.r!=null)&#123;</span><br><span class="line">                    treeNodes.add(n.r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int [] date=new int[]&#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">        BinTree tree=new BinTree(date);</span><br><span class="line">        tree.hx(tree.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        tree.hx1(tree.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        tree.cen(tree.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yueguoyu/yueguoyu.github.io/yueguoyu.github.io/2018/07/04/二叉树的层次遍历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="越狱">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2018/05/28/5b0b594044b97.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YgY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/yueguoyu.github.io/2018/07/04/二叉树的层次遍历/" itemprop="url">二叉树的层次遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-04T20:23:05+08:00">
                2018-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yueguoyu.github.io/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h2><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>解法</strong>：</p>
<p>广度优先用队列</p>
<p>深度优先用栈</p>
<p>层次遍历是广度优先，所以用队列</p>
<p>使用队列实现树的分层遍历，先将树的头节点加入队列，然后将节点弹出队列，再判断这个节点的左子节点是否存在，如果存在加入队列，再判断这个节点的右子节点是否存在，如果存在加入队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">         List&lt;List&lt;Integer&gt;&gt; lists=new LinkedList&lt;&gt;();</span><br><span class="line">          if(root==null)&#123;</span><br><span class="line">                return lists;</span><br><span class="line">            &#125;</span><br><span class="line">         //使用LinkedList实现队列</span><br><span class="line">        LinkedList&lt;TreeNode&gt; q=new LinkedList&lt;&gt;();</span><br><span class="line">       //将root加入队列</span><br><span class="line">            q.add(root);</span><br><span class="line">            //遍历队列</span><br><span class="line">            while(!q.isEmpty())&#123;</span><br><span class="line">                List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">                //因为要分层输出，size为每层节点数</span><br><span class="line">                   int size=q.size();</span><br><span class="line">                   for (int i=0;i&lt;size;i++)&#123;</span><br><span class="line">                      TreeNode n=q.poll();</span><br><span class="line">                      list.add(n.val);</span><br><span class="line">                       if (n.left!=null)&#123;</span><br><span class="line">                           q.add(n.left);</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (n.right!=null)&#123;</span><br><span class="line">                           q.add(n.right);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                lists.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">            return lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yueguoyu/yueguoyu.github.io/yueguoyu.github.io/2018/07/04/反转链表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="越狱">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2018/05/28/5b0b594044b97.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YgY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/yueguoyu.github.io/2018/07/04/反转链表/" itemprop="url">反转链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-04T08:22:40+08:00">
                2018-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yueguoyu.github.io/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p>递归实现：从后往前反转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head)&#123;</span><br><span class="line">       //找到最后一个节点HEAD.NEXT</span><br><span class="line">       if (head==null||head.next==null)&#123;</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode p=reverseList(head.next);</span><br><span class="line">       //反转链表</span><br><span class="line">       head.next.next=head;</span><br><span class="line">       //将head指向后一个节点的关系去掉</span><br><span class="line">       head.next=null;</span><br><span class="line">       return p;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>非递归：前往后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public ListNode sw(ListNode head)&#123;</span><br><span class="line">        if (head==null)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        //指向下一个节点</span><br><span class="line">        ListNode next=null;</span><br><span class="line">        //反转后的头节点</span><br><span class="line">        ListNode pre=null;</span><br><span class="line">        while(head!=null)&#123;</span><br><span class="line">            next=head.next;</span><br><span class="line">            head.next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yueguoyu/yueguoyu.github.io/yueguoyu.github.io/2018/06/28/ThreadLocal源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="越狱">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2018/05/28/5b0b594044b97.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YgY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/yueguoyu.github.io/2018/06/28/ThreadLocal源码分析/" itemprop="url">ThreadLocal源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T10:16:25+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yueguoyu.github.io/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>早在 JDK 1.2 的版本中就提供 java.lang.ThreadLocal，ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p>
<p>　　当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>ThreadLocal类能使线程中的某个值与保存值的对象关联起来。<br>ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。<br>ThreadLoacl类中使用map存储数据，key为线程而value为变量副本。<br>ThreadLocal类中有一个ThreadLocalMap内部类，用来存储副本key为线程，而value为变量的副本。</p>
<h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package T616;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">public class threadlocalTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService service=Executors.newCachedThreadPool();</span><br><span class="line">        ThreadLocal&lt;String&gt; local=new ThreadLocal&lt;&gt;();</span><br><span class="line">        service.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName()+&quot;------&quot;+local.get());</span><br><span class="line">                local.set(&quot;dasa&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;------&quot;+local.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><p><strong>pool-1-thread-1——null</strong></p>
<p><strong>pool-1-thread-1——dasa</strong></p>
<h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><strong>一个ThreadLocal存储多个线程 的副本</strong></p>
<p><img src="https://i.loli.net/2018/06/27/5b32f7bfbc683.png" alt="VarMap.png"></p>
<p><strong>一个线程存在多个ThreadLocal</strong></p>
<p><img src="https://i.loli.net/2018/06/27/5b32f7bfbaef9.png" alt="ThreadMap.png"></p>
<p><a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">参考</a></p>
<h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><p><strong>get方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">//获得当前线程</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    //使用ThreadLocalMap进行存储变量</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ThreadLocalMap类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">//Entry类扩展了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span><br><span class="line">//weakReference弱参考对象，不妨碍他们的参照物被定型，定型，然后回收。 大多数弱引用常用于实现规范化映射</span><br><span class="line">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        /** 线程的副本**/</span><br><span class="line">        Object value;</span><br><span class="line">//使用线程做主键</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Entry[]数组的默认大小，必须是2的倍数.</span><br><span class="line">     */</span><br><span class="line">    private static final int INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Entry数组.</span><br><span class="line">     */</span><br><span class="line">    private Entry[] table;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *表格大小 </span><br><span class="line">     */</span><br><span class="line">    private int size = 0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The next size value at which to resize.</span><br><span class="line">     */</span><br><span class="line">    private int threshold; // Default to 0</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set the resize threshold to maintain at worst a 2/3 load factor.</span><br><span class="line">     */</span><br><span class="line">    private void setThreshold(int len) &#123;</span><br><span class="line">        threshold = len * 2 / 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Increment i modulo len.</span><br><span class="line">     */</span><br><span class="line">    private static int nextIndex(int i, int len) &#123;</span><br><span class="line">        return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Decrement i modulo len.</span><br><span class="line">     */</span><br><span class="line">    private static int prevIndex(int i, int len) &#123;</span><br><span class="line">        return ((i - 1 &gt;= 0) ? i - 1 : len - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * ThreadLocalMap的构造函数</span><br><span class="line">     */</span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    //创建一个容量为16的Entry数组</span><br><span class="line">        table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">        int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">        table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">        size = 1;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Construct a new map including all Inheritable ThreadLocals</span><br><span class="line">     * from given parent map. Called only by createInheritedMap.</span><br><span class="line">     *</span><br><span class="line">     * @param parentMap the map associated with parent thread.</span><br><span class="line">     */</span><br><span class="line">    private ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">        Entry[] parentTable = parentMap.table;</span><br><span class="line">        int len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line">        table = new Entry[len];</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = parentTable[j];</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                if (key != null) &#123;</span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line">                    Entry c = new Entry(key, value);</span><br><span class="line">                    int h = key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                    while (table[h] != null)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Get the entry associated with key.  This method</span><br><span class="line">     * itself handles only the fast path: a direct hit of existing</span><br><span class="line">     * key. It otherwise relays to getEntryAfterMiss.  This is</span><br><span class="line">     * designed to maximize performance for direct hits, in part</span><br><span class="line">     * by making this method readily inlinable.</span><br><span class="line">     *</span><br><span class="line">     * @param  key the thread local object</span><br><span class="line">     * @return the entry associated with key, or null if no such</span><br><span class="line">     */</span><br><span class="line">    private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">        int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">        Entry e = table[i];</span><br><span class="line">        if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">            return e;</span><br><span class="line">        else</span><br><span class="line">            return getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Version of getEntry method for use when key is not found in</span><br><span class="line">     * its direct hash slot.</span><br><span class="line">     *</span><br><span class="line">     * @param  key the thread local object</span><br><span class="line">     * @param  i the table index for key&apos;s hash code</span><br><span class="line">     * @param  e the entry at table[i]</span><br><span class="line">     * @return the entry associated with key, or null if no such</span><br><span class="line">     */</span><br><span class="line">    private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        int len = tab.length;</span><br><span class="line"></span><br><span class="line">        while (e != null) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            if (k == key)</span><br><span class="line">                return e;</span><br><span class="line">            if (k == null)</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">            else</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">            e = tab[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set the value associated with key.</span><br><span class="line">     *</span><br><span class="line">     * @param key the thread local object</span><br><span class="line">     * @param value the value to be set</span><br><span class="line">     */</span><br><span class="line">    private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">        // We don&apos;t use a fast path as with get() because it is at</span><br><span class="line">        // least as common to use set() to create new entries as</span><br><span class="line">        // it is to replace existing ones, in which case, a fast</span><br><span class="line">        // path would fail more often than not.</span><br><span class="line"></span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        int len = tab.length;</span><br><span class="line">        int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">        for (Entry e = tab[i];</span><br><span class="line">             e != null;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            if (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (k == null) &#123;</span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[i] = new Entry(key, value);</span><br><span class="line">        int sz = ++size;</span><br><span class="line">        if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Remove the entry for key.</span><br><span class="line">     */</span><br><span class="line">    private void remove(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        int len = tab.length;</span><br><span class="line">        int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">        for (Entry e = tab[i];</span><br><span class="line">             e != null;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            if (e.get() == key) &#123;</span><br><span class="line">                e.clear();</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Replace a stale entry encountered during a set operation</span><br><span class="line">     * with an entry for the specified key.  The value passed in</span><br><span class="line">     * the value parameter is stored in the entry, whether or not</span><br><span class="line">     * an entry already exists for the specified key.</span><br><span class="line">     *</span><br><span class="line">     * As a side effect, this method expunges all stale entries in the</span><br><span class="line">     * &quot;run&quot; containing the stale entry.  (A run is a sequence of entries</span><br><span class="line">     * between two null slots.)</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @param  value the value to be associated with key</span><br><span class="line">     * @param  staleSlot index of the first stale entry encountered while</span><br><span class="line">     *         searching for key.</span><br><span class="line">     */</span><br><span class="line">    private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="line">                                   int staleSlot) &#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        int len = tab.length;</span><br><span class="line">        Entry e;</span><br><span class="line"></span><br><span class="line">        // Back up to check for prior stale entry in current run.</span><br><span class="line">        // We clean out whole runs at a time to avoid continual</span><br><span class="line">        // incremental rehashing due to garbage collector freeing</span><br><span class="line">        // up refs in bunches (i.e., whenever the collector runs).</span><br><span class="line">        int slotToExpunge = staleSlot;</span><br><span class="line">        for (int i = prevIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != null;</span><br><span class="line">             i = prevIndex(i, len))</span><br><span class="line">            if (e.get() == null)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">        // Find either the key or trailing null slot of run, whichever</span><br><span class="line">        // occurs first</span><br><span class="line">        for (int i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != null;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            // If we find key, then we need to swap it</span><br><span class="line">            // with the stale entry to maintain hash table order.</span><br><span class="line">            // The newly stale slot, or any other stale slot</span><br><span class="line">            // encountered above it, can then be sent to expungeStaleEntry</span><br><span class="line">            // to remove or rehash all of the other entries in run.</span><br><span class="line">            if (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line"></span><br><span class="line">                tab[i] = tab[staleSlot];</span><br><span class="line">                tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                // Start expunge at preceding stale entry if it exists</span><br><span class="line">                if (slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If we didn&apos;t find stale entry on backward scan, the</span><br><span class="line">            // first stale entry seen while scanning for key is the</span><br><span class="line">            // first still present in the run.</span><br><span class="line">            if (k == null &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If key not found, put new entry in stale slot</span><br><span class="line">        tab[staleSlot].value = null;</span><br><span class="line">        tab[staleSlot] = new Entry(key, value);</span><br><span class="line"></span><br><span class="line">        // If there are any other stale entries in run, expunge them</span><br><span class="line">        if (slotToExpunge != staleSlot)</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Expunge a stale entry by rehashing any possibly colliding entries</span><br><span class="line">     * lying between staleSlot and the next null slot.  This also expunges</span><br><span class="line">     * any other stale entries encountered before the trailing null.  See</span><br><span class="line">     * Knuth, Section 6.4</span><br><span class="line">     *</span><br><span class="line">     * @param staleSlot index of slot known to have null key</span><br><span class="line">     * @return the index of the next null slot after staleSlot</span><br><span class="line">     * (all between staleSlot and this slot will have been checked</span><br><span class="line">     * for expunging).</span><br><span class="line">     */</span><br><span class="line">    private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        int len = tab.length;</span><br><span class="line"></span><br><span class="line">        // expunge entry at staleSlot</span><br><span class="line">        tab[staleSlot].value = null;</span><br><span class="line">        tab[staleSlot] = null;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        // Rehash until we encounter null</span><br><span class="line">        Entry e;</span><br><span class="line">        int i;</span><br><span class="line">        for (i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != null;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            if (k == null) &#123;</span><br><span class="line">                e.value = null;</span><br><span class="line">                tab[i] = null;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                if (h != i) &#123;</span><br><span class="line">                    tab[i] = null;</span><br><span class="line"></span><br><span class="line">                    // Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="line">                    // null because multiple entries could have been stale.</span><br><span class="line">                    while (tab[h] != null)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Heuristically scan some cells looking for stale entries.</span><br><span class="line">     * This is invoked when either a new element is added, or</span><br><span class="line">     * another stale one has been expunged. It performs a</span><br><span class="line">     * logarithmic number of scans, as a balance between no</span><br><span class="line">     * scanning (fast but retains garbage) and a number of scans</span><br><span class="line">     * proportional to number of elements, that would find all</span><br><span class="line">     * garbage but would cause some insertions to take O(n) time.</span><br><span class="line">     *</span><br><span class="line">     * @param i a position known NOT to hold a stale entry. The</span><br><span class="line">     * scan starts at the element after i.</span><br><span class="line">     *</span><br><span class="line">     * @param n scan control: &#123;@code log2(n)&#125; cells are scanned,</span><br><span class="line">     * unless a stale entry is found, in which case</span><br><span class="line">     * &#123;@code log2(table.length)-1&#125; additional cells are scanned.</span><br><span class="line">     * When called from insertions, this parameter is the number</span><br><span class="line">     * of elements, but when from replaceStaleEntry, it is the</span><br><span class="line">     * table length. (Note: all this could be changed to be either</span><br><span class="line">     * more or less aggressive by weighting n instead of just</span><br><span class="line">     * using straight log n. But this version is simple, fast, and</span><br><span class="line">     * seems to work well.)</span><br><span class="line">     *</span><br><span class="line">     * @return true if any stale entries have been removed.</span><br><span class="line">     */</span><br><span class="line">    private boolean cleanSomeSlots(int i, int n) &#123;</span><br><span class="line">        boolean removed = false;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        int len = tab.length;</span><br><span class="line">        do &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">            Entry e = tab[i];</span><br><span class="line">            if (e != null &amp;&amp; e.get() == null) &#123;</span><br><span class="line">                n = len;</span><br><span class="line">                removed = true;</span><br><span class="line">                i = expungeStaleEntry(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while ( (n &gt;&gt;&gt;= 1) != 0);</span><br><span class="line">        return removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Re-pack and/or re-size the table. First scan the entire</span><br><span class="line">     * table removing stale entries. If this doesn&apos;t sufficiently</span><br><span class="line">     * shrink the size of the table, double the table size.</span><br><span class="line">     */</span><br><span class="line">    private void rehash() &#123;</span><br><span class="line">        expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">        // Use lower threshold for doubling to avoid hysteresis</span><br><span class="line">        if (size &gt;= threshold - threshold / 4)</span><br><span class="line">            resize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Double the capacity of the table.</span><br><span class="line">     */</span><br><span class="line">    private void resize() &#123;</span><br><span class="line">        Entry[] oldTab = table;</span><br><span class="line">        int oldLen = oldTab.length;</span><br><span class="line">        int newLen = oldLen * 2;</span><br><span class="line">        Entry[] newTab = new Entry[newLen];</span><br><span class="line">        int count = 0;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">            Entry e = oldTab[j];</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                if (k == null) &#123;</span><br><span class="line">                    e.value = null; // Help the GC</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int h = k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                    while (newTab[h] != null)</span><br><span class="line">                        h = nextIndex(h, newLen);</span><br><span class="line">                    newTab[h] = e;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setThreshold(newLen);</span><br><span class="line">        size = count;</span><br><span class="line">        table = newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Expunge all stale entries in the table.</span><br><span class="line">     */</span><br><span class="line">    private void expungeStaleEntries() &#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        int len = tab.length;</span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = tab[j];</span><br><span class="line">            if (e != null &amp;&amp; e.get() == null)</span><br><span class="line">                expungeStaleEntry(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yueguoyu/yueguoyu.github.io/yueguoyu.github.io/2018/06/28/ReentrantLock源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="越狱">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2018/05/28/5b0b594044b97.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YgY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/yueguoyu.github.io/2018/06/28/ReentrantLock源码/" itemprop="url">ReentrantLock源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T10:16:25+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yueguoyu.github.io/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ReentrantLock源码"><a href="#ReentrantLock源码" class="headerlink" title="ReentrantLock源码"></a>ReentrantLock源码</h2><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>重入锁,和与使用 synchronized方法差不多，但具有扩展功能的可重入互斥锁。</p>
<p><code>java.util.concurrent.lock</code> 中的 <code>Lock</code> 框架是锁定的一个抽象，它允许把锁定的实现作为 Java 类，而不是作为语言的特性来实现。这就为 <code>Lock</code> 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。 <code>ReentrantLock</code> 类实现了 <code>Lock</code> ，它拥有与 <code>synchronized</code> 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM 可以花更少的时候来调度线程，把更多时间用在执行线程上。） </p>
<h4 id="ReentrantLock和synchronized比较"><a href="#ReentrantLock和synchronized比较" class="headerlink" title="ReentrantLock和synchronized比较"></a>ReentrantLock和synchronized比较</h4><p><a href="https://blog.csdn.net/fw0124/article/details/6672522" target="_blank" rel="noopener">比较</a></p>
<h4 id="公平锁和非公平锁："><a href="#公平锁和非公平锁：" class="headerlink" title="公平锁和非公平锁："></a>公平锁和非公平锁：</h4><p>公平锁使线程按照请求锁的顺序依次获得锁；而不公平锁则允许讨价还价，在这种情况下，线程有时可以比先请求锁的其他线程先得到锁。 </p>
<h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><p><strong>ReentrantLock构造</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//选择创建是否是公平锁</span><br><span class="line">public ReentrantLock(boolean fair) &#123;    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>非公平锁</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//NonfairSync继承sync类</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *执行锁步骤</span><br><span class="line">     */</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">    //使用cas操作将值从0变为1</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">        //设置当前线程为锁的持有者</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">//尝试获取</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>公平锁</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fair version of tryAcquire.  Don&apos;t grant access unless</span><br><span class="line">     * recursive call or no waiters or is first.</span><br><span class="line">     */</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">        //判断队列中是否有其他的等待线程，如果没有则获取锁</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断当前线程是否是锁的持有者</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock类实现了Lock和java.io.Serializable接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 7373984872572414699L;</span><br><span class="line">    /** Synchronizer providing all implementation mechanics */</span><br><span class="line">    private final Sync sync;</span><br></pre></td></tr></table></figure>
<p>抽象Sync类继承了aqs，实同步现了锁的同步控制基础。分为公平和非公平版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    private static final long serialVersionUID = -5179523762034025860L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing</span><br><span class="line">     * is to allow fast path for nonfair version.</span><br><span class="line">     */</span><br><span class="line">    abstract void lock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 不公平尝试获取</span><br><span class="line">     */</span><br><span class="line">    final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    //获取当前线程</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        //获得状态数值</span><br><span class="line">        int c = getState();</span><br><span class="line">        //如果为0</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">        //acqutres此时为1</span><br><span class="line">            if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            //设定当前线程拥有独占访问权限</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当前线程是否是由setExclusiveOwnerThread方法最后设定的线程</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        //此时c为1，表示有锁，nextc为2</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0) // overflow</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">//尝试释放</span><br><span class="line">    protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">        int c = getState() - releases;</span><br><span class="line">        if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        boolean free = false;</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            free = true;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        return free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean isHeldExclusively() &#123;</span><br><span class="line">        // While we must in general read state before owner,</span><br><span class="line">        // we don&apos;t need to do so to check if current thread is owner</span><br><span class="line">        return getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ConditionObject newCondition() &#123;</span><br><span class="line">        return new ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Methods relayed from outer class</span><br><span class="line"></span><br><span class="line">    final Thread getOwner() &#123;</span><br><span class="line">        return getState() == 0 ? null : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int getHoldCount() &#123;</span><br><span class="line">        return isHeldExclusively() ? getState() : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final boolean isLocked() &#123;</span><br><span class="line">        return getState() != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Reconstitutes the instance from a stream (that is, deserializes it).</span><br><span class="line">     */</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(0); // reset to unlocked state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 非公平锁</span><br><span class="line"> */</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 锁实现</span><br><span class="line">     */</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">    //状态数值由0变为1</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">        //设置当前线程是锁的持有者</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加锁和释放锁"><a href="#加锁和释放锁" class="headerlink" title="加锁和释放锁"></a>加锁和释放锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//加锁</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>ReentrantLock是lock框架的一个抽象实现,是一个可重入的互斥锁，ReentranLock是通过sync实现的，sync又是继承aqs的，其内部又有公平锁和非公平锁类它们继承sync，它们实现了锁的公平获取和非公平获取的实现。</p>
<p>​     一个可重入的互斥锁定 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义，但功能更强大。ReentrantLock 将由最近成功获得锁定，并且还没有释放该锁定的线程所拥有。当锁定没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁定并返回。如果当前线程已经拥有该锁定，此方法将立即返回。可以使用 isHeldByCurrentThread() 和 getHoldCount() 方法来检查此情况是否发生。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yueguoyu/yueguoyu.github.io/yueguoyu.github.io/2018/06/28/CyclicBarrier源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="越狱">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2018/05/28/5b0b594044b97.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YgY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/yueguoyu.github.io/2018/06/28/CyclicBarrier源码分析/" itemprop="url">CyclicBarrier源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T10:16:25+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yueguoyu.github.io/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CyclicBarrier源码分析"><a href="#CyclicBarrier源码分析" class="headerlink" title="CyclicBarrier源码分析"></a>CyclicBarrier源码分析</h2><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>cyclicbarrier同步屏障，它是一种同步协助，它允许一组线程等待彼此以达到共同的障碍点。CyclicBarriers 在涉及固定大小的线程的程序中非常有用，它必须偶尔等待对方，该屏障称为循环，因为它可以在等待线程释放后重新使用。</p>
<p>CyclicBarrier 好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。 </p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>parties爆发量，barrierAction当屏障被触发时执行的命令，如果没有任何操作，则执行{null}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.parties = parties;</span><br><span class="line">    this.count = parties;</span><br><span class="line">    this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">        this(parties, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrier &#123;</span><br><span class="line">private static class Generation &#123;</span><br><span class="line">    boolean broken = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可重入锁</span><br><span class="line">private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">//条件队列</span><br><span class="line">private final Condition trip = lock.newCondition();</span><br><span class="line">//参与的线程数</span><br><span class="line">private final int parties;</span><br><span class="line">//屏障打开时运行的操作</span><br><span class="line">private final Runnable barrierCommand;</span><br><span class="line">//当前代</span><br><span class="line">private Generation generation = new Generation();</span><br><span class="line">//在屏障里等待的线程数量</span><br><span class="line">private int count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe); // cannot happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dowait方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">           //使用了ReentrantLock（重入锁）</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">    //代</span><br><span class="line">        final Generation g = generation;</span><br><span class="line"></span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line">//如果线程中断</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">        //将当前的屏障生成设置为中断并唤醒每个人</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">//到达屏障临界点的剩余线程数</span><br><span class="line">        int index = --count;</span><br><span class="line">        if (index == 0) &#123;  // tripped跳闸</span><br><span class="line">            boolean ranAction = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command = barrierCommand;</span><br><span class="line">                if (command != null)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = true;</span><br><span class="line">                //更新屏障状态，并且唤醒所有等待线程</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                //将当前的屏障生成设置为中断，并唤醒每一个人</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // loop until tripped, broken, interrupted, or timed out循环直到跳闸，断开，中断或超时</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // We&apos;re about to finish waiting even if we had not</span><br><span class="line">                    // been interrupted, so this interrupt is deemed to</span><br><span class="line">                    // &quot;belong&quot; to subsequent execution.</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line"></span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见CyclicBarrier是基于ReentrantLock(重入锁)实现的。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package T616;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public class cyclicBarrier &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier barrier=new CyclicBarrier(3,new main1());</span><br><span class="line">/*</span><br><span class="line"> *   等待开门的线程</span><br><span class="line"> */</span><br><span class="line">        new Thread(new play(1,barrier)).start();</span><br><span class="line">        new Thread(new play(2,barrier)).start();</span><br><span class="line">        new Thread(new play(3,barrier)).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   static class main1 implements Runnable&#123;</span><br><span class="line">        main1()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          System.out.println(&quot;main&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   static class play implements Runnable&#123;</span><br><span class="line">        CyclicBarrier barrier;</span><br><span class="line">        int id;</span><br><span class="line">        play(int id,CyclicBarrier barrier)&#123;</span><br><span class="line">            this.barrier=barrier;</span><br><span class="line">            this.id=id;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(id+&quot;------&quot;+Thread.currentThread().getName()+&quot;完成&quot;);</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/07/02/5b39896fca6ea.png" alt="QQ截图20180702100908.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yueguoyu/yueguoyu.github.io/yueguoyu.github.io/2018/06/28/Semaphore源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="越狱">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2018/05/28/5b0b594044b97.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YgY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/yueguoyu.github.io/2018/06/28/Semaphore源码分析/" itemprop="url">Semaphore源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T10:16:25+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yueguoyu.github.io/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Semaphore源码分析"><a href="#Semaphore源码分析" class="headerlink" title="Semaphore源码分析"></a>Semaphore源码分析</h2><p>semaphore（信号量）用来控制同时访问特定资源的线程数，在获得物品之前，每个线程必须从信号量获得许可证，以确保物品可供使用。 当<em>线程完成该项目时，它将返回到</em>池，并且许可证返回到信号量，允许另一个<em>线程获取该项目。请注意，在调用acquire时不会同步锁定，因为这会阻止将项目</em>返回到池中。 信号量封装了用于限制对池的访问所需的同步，与为保持池自身一致性所需的任何同步分开。</p>
<p><strong>源码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Semaphore implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -3222578661600680210L;</span><br><span class="line">   //所有机制都通过AbstractQueuedSynchronizer子类</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>semaphore的内部类sync</strong></p>
<p>Sync类继承AQS，实现信号量的同步，使用AQS表示信号量，分为公平版本和非公平。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    private static final long serialVersionUID = 1192457210091910933L;</span><br><span class="line"></span><br><span class="line">    Sync(int permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int getPermits() &#123;</span><br><span class="line">        return getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int available = getState();</span><br><span class="line">            int remaining = available - acquires;</span><br><span class="line">            if (remaining &lt; 0 ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                return remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current = getState();</span><br><span class="line">            int next = current + releases;</span><br><span class="line">            if (next &lt; current) // overflow</span><br><span class="line">                throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">            if (compareAndSetState(current, next))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void reducePermits(int reductions) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current = getState();</span><br><span class="line">            int next = current - reductions;</span><br><span class="line">            if (next &gt; current) // underflow</span><br><span class="line">                throw new Error(&quot;Permit count underflow&quot;);</span><br><span class="line">            if (compareAndSetState(current, next))</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int drainPermits() &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current = getState();</span><br><span class="line">            if (current == 0 || compareAndSetState(current, 0))</span><br><span class="line">                return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 非公平版本</span><br><span class="line"> *NonfairSync继承Sync类</span><br><span class="line"> */</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -2694183684443567898L;</span><br><span class="line">//设置许可证的数量</span><br><span class="line">    NonfairSync(int permits) &#123;</span><br><span class="line">    //使用sync的构造器</span><br><span class="line">        super(permits);</span><br><span class="line">    &#125;</span><br><span class="line">//尝试获取共享</span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FairSync和NonfairSync都继承sync，唯一不同的是再获取时FairSync类加了一个hasQueuedPredecessors判断，判断是否有线程在 AQS 的 Sync Queue 里面进行等待获取 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 共平版本</span><br><span class="line"> *继承sync类</span><br><span class="line"> */</span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = 2014338818796000944L;</span><br><span class="line"></span><br><span class="line">    FairSync(int permits) &#123;</span><br><span class="line">        super(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (hasQueuedPredecessors())</span><br><span class="line">                return -1;</span><br><span class="line">            int available = getState();</span><br><span class="line">            int remaining = available - acquires;</span><br><span class="line">            if (remaining &lt; 0 ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                return remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取信号量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Semaphore的构造方法</span><br><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">    sync = new NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line">//可响应中断的获取信号量</span><br><span class="line"> public void acquire() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //不可响应中断的获取信号量</span><br><span class="line">    public void acquireUninterruptibly() &#123;</span><br><span class="line">        sync.acquireShared(1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>尝试获取信号量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean tryAcquire() &#123;</span><br><span class="line">    return sync.nonfairTryAcquireShared(1) &gt;= 0;</span><br><span class="line">&#125;</span><br><span class="line">//有时间限制的尝试获取信号量</span><br><span class="line"> public boolean tryAcquire(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    //尝试获取一定的数量的信号量</span><br><span class="line">     public boolean tryAcquire(int permits) &#123;</span><br><span class="line">        if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">        return sync.nonfairTryAcquireShared(permits) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //在一定时间尝试获取一定数量的信号量</span><br><span class="line"> public boolean tryAcquire(int permits, long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">        return sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>释放信号量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//释放一定数量的信号量</span><br><span class="line">public void release(int permits) &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br><span class="line">//返回此信号量中当前可用的许可证数量</span><br><span class="line"> public int availablePermits() &#123;</span><br><span class="line">        return sync.getPermits();</span><br><span class="line">    &#125;</span><br><span class="line">//获取并返回所有立即可用的许可证。</span><br><span class="line">public int drainPermits() &#123;</span><br><span class="line">        return sync.drainPermits();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取等待的线程数量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回等待获取的线程数的估计值</span><br><span class="line">public final int getQueueLength() &#123;</span><br><span class="line">    return sync.getQueueLength();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>semaphore（信号量）通过控制对资源同步的访问的线程的数量，比如模拟一个停车场停车信号，假设停车场只有两个车位，一开始两个车位都是空的。这时如果同时来了两辆车，看门人允许它们进入停车场，然后放下车拦。以后来的车必须在入口等待，直到停车场中有车辆离开。这时，如果有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开一辆，则又可以放入一辆，如此往复。<br>[参考]（<a href="https://www.jianshu.com/p/d1bfa69f864d）" target="_blank" rel="noopener">https://www.jianshu.com/p/d1bfa69f864d）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package T616;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService service=Executors.newFixedThreadPool(5);</span><br><span class="line">        Semaphore semaphore=new Semaphore(2);</span><br><span class="line">        for (int i=0;i&lt;5;i++)&#123;</span><br><span class="line">                Runnable runnable=new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            semaphore.acquire();</span><br><span class="line">                            System.out.println(&quot;进入&quot;);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(1000);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                        System.out.println(&quot;释放&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                service.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/07/02/5b39dc0fe418e.png" alt="QQ截图20180702160145.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yueguoyu/yueguoyu.github.io/yueguoyu.github.io/2018/06/28/AbstractQueuedSynchronizer(AQS)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="越狱">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2018/05/28/5b0b594044b97.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YgY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/yueguoyu.github.io/2018/06/28/AbstractQueuedSynchronizer(AQS)/" itemprop="url">AbstractQueuedSynchronizer(AQS)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T10:16:25+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yueguoyu.github.io/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AbstractQueuedSynchronizer-AQS"><a href="#AbstractQueuedSynchronizer-AQS" class="headerlink" title="AbstractQueuedSynchronizer(AQS)"></a>AbstractQueuedSynchronizer(AQS)</h2><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器。是用来构建锁或者其他同步组件的基础框架。</p>
<h4 id="synchronized-同步和AQS"><a href="#synchronized-同步和AQS" class="headerlink" title="synchronized 同步和AQS"></a>synchronized 同步和AQS</h4><p>synchronized 同步，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码需要关联到一个监视对象，当线程执行 monitorenter 指令时，需要首先获得获得监视对象的锁，这里监视对象锁就是进入同步块的凭证，只有获得了凭证才可以进入同步块，当线程离开同步块时，会执行 monitorexit 指令，释放对象锁。</p>
<p>在 AQS 同步中，使用一个 int 类型的变量 state 来表示当前同步块的状态。以独占式同步（一次只能有一个线程进入同步块）为例，state 的有效值有两个 0 和 1，其中 0 表示当前同步块中没有线程，1 表示同步块中已经有线程在执行。当线程要进入同步块时，需要首先判断 state 的值是否为 0，假设为 0，会尝试将 state 修改为 1，只有<strong>修改成功</strong>了之后，线程才可以进入同步块。注意上面提到的两个条件：</p>
<ul>
<li>state 为 0，证明当前同步块中没有线程在执行，所以当前线程可以尝试获得进入同步块的凭证，而这里的凭证就是是否成功将 state 修改为 1（在 synchronized 同步中，我们说的凭证是对象锁，但是对象锁的最终实现是否和这种方式类似，没有找到相关的资料）</li>
<li>成功将 state 修改为 1，通过使用 CAS 操作，我们可以确保即便有多个线程同时修改 state，也只有一个线程会修改成功。关于 CAS 的具体解释会在后面提到。</li>
</ul>
<p>当线程离开同步块时，会修改 state 的值，将其设为 0，并唤醒等待的线程。所以在 AQS 同步中，我们说线程获得了锁，实际上是指线程成功修改了状态变量 state，而线程释放了锁，是指线程将状态变量置为了可修改的状态（在独占式同步中就是置为了 0），让其他线程可以再次尝试修改状态变量。在下面的表述中，我们说线程获得和释放了锁，就是上述含义， 这与 synchronized 同步中说的获得和释放锁的含义不同，需要区别理解</p>
<p><a href="http://www.cnblogs.com/zhangjk1993/p/6715653.html" target="_blank" rel="noopener">原文</a> </p>
<h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><p>AQS的实现是依赖内部的同步队列（FIFO双向队列） ，如果当前线程获取同步状态失败，AQS会将线程以及等待状态等信息构成一个node，将其加到队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    +------+  prev +-----+       +-----+</span><br><span class="line">* head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">*      +------+       +-----+       +-----+</span><br></pre></td></tr></table></figure>
<h3 id="AQS结构图"><a href="#AQS结构图" class="headerlink" title="AQS结构图"></a>AQS结构图</h3><p><img src="https://i.loli.net/2018/06/21/5b2b47ba8a47c.png" alt="201701240001-1.png"></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="node内部类"><a href="#node内部类" class="headerlink" title="node内部类"></a>node内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    /** 标记以指示节点正在以共享模式等待 */</span><br><span class="line">    static final AbstractQueuedSynchronizer.Node SHARED = new AbstractQueuedSynchronizer.Node();</span><br><span class="line">    /** 标记以指示节点正在以独占模式等待 */</span><br><span class="line">    static final AbstractQueuedSynchronizer.Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">      // 结点状态</span><br><span class="line">        // CANCELLED，值为1，表示当前的线程被取消</span><br><span class="line">        // SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark</span><br><span class="line">        // CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中</span><br><span class="line">        // PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行</span><br><span class="line">        // 值为0，表示当前节点在sync队列中，等待着获取锁</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">   </span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">  </span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">  </span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 状态字段只取下面的值：</span><br><span class="line">     *   SIGNAL:     该节点的后继者（或将很快）被阻塞（通过park），因此当前节点必须在释放或取消后取消其继任者。</span><br><span class="line">     *               为了避免竞争，获取方法必须首先表明他们需要一个信号，然后重试原子捕获，然后在失败时阻止阻塞</span><br><span class="line">     *   CANCELLED:  由于超时或中断，此节点被取消。</span><br><span class="line">     *               节点永远不会离开这个状态。, 尤其是，具有取消节点的线程不会再次阻塞。</span><br><span class="line">     *   CONDITION:  该节点当前处于条件队列中。</span><br><span class="line">     *   PROPAGATE:  releaseShared应该传播到其他*节点。</span><br><span class="line">     *              在doReleaseShared中设置这个（仅用于头节点）以确保传播继续，即使其他操作自干预以来也有*。</span><br><span class="line">     *   0:          None of the above</span><br><span class="line">     */</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链接到当前节点/线程依赖*的前驱节点来检查waitStatus。</span><br><span class="line">     */</span><br><span class="line">    volatile AbstractQueuedSynchronizer.Node prev;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链接到当前节点/线程*在释放后停止的后继节点。</span><br><span class="line">     */</span><br><span class="line">    volatile AbstractQueuedSynchronizer.Node next;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 排入此节点的线程。初始化施工并在使用后清空</span><br><span class="line">     */</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链接到下一个节点等待条件，或者特殊*值SHARED。</span><br><span class="line">     * 因为条件队列只有在独占模式下才被访问，所以我们只需要一个简单的*链接队列来等待*条件下的节点。</span><br><span class="line">     * 然后他们被转移到队列重新获得。 由于条件只能是排他性的，我们通过使用特殊值来保存字段以指示共享模式。</span><br><span class="line">     */</span><br><span class="line">    AbstractQueuedSynchronizer.Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果节点在共享模式下等待，则返回true。</span><br><span class="line">     */</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回前一个节点，如果为null则抛出NullPointerException。 </span><br><span class="line">     * 前驱不能为空时使用。, 空检查可能会被忽略，但是可以帮助虚拟机。</span><br><span class="line">     *</span><br><span class="line">     * @return the predecessor of this node</span><br><span class="line">     */</span><br><span class="line">    final AbstractQueuedSynchronizer.Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        AbstractQueuedSynchronizer.Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    // Used to establish initial head or SHARED marker</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, AbstractQueuedSynchronizer.Node mode) &#123;     // Used by addWaiter</span><br><span class="line">        this.nextWaiter = mode;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">        this.waitStatus = waitStatus;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h4><p>AbstractQueuedSynchronizer类继承AbstractOwnableSynchronizer类，AbstractOwnableSynchronizer类同步器可能由线程专有。 这个<em>类提供了创建锁和相关同步器</em>的基础，这可能需要拥有所有权。 , AbstractOwnableSynchronizer类本身不管理或使用这些信息。 但是，子类和工具可以使用<em>适当维护的值来帮助控制和监视访问</em>并提供诊断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//队列头节点</span><br><span class="line">private transient volatile Node head;</span><br><span class="line">//尾节点</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line">//同步状态</span><br><span class="line"> private volatile int state;</span><br><span class="line"> //获得同步状态</span><br><span class="line"> protected final int getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"> //设置同步状态</span><br><span class="line">protected final void setState(int newState) &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">/*</span><br><span class="line">*变更同步状态，基于cas操作，比较expect的值与存储位置的值是否相等</span><br><span class="line">*相等就将值变为update</span><br><span class="line">*/</span><br><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">        // See below for intrinsics setup to support this</span><br><span class="line">        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">//将节点插入队列</span><br><span class="line"> private Node enq(final Node node) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            if (t == null) &#123; // Must initialize</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractOwnableSynchronizer类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *设置当前拥有独占访问权限的线程。</span><br><span class="line"> */</span><br><span class="line">protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回最后由setExclusiveOwnerThread设置的线程，如果从未设置，则返回null。此方法不会以其他方式强制执行任何同步或字段访问。返回所有者线程</span><br><span class="line"> */</span><br><span class="line">protected final Thread getExclusiveOwnerThread() &#123;</span><br><span class="line">    return exclusiveOwnerThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">    extends AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br></pre></td></tr></table></figure>
<h4 id="CountDownLatch源码"><a href="#CountDownLatch源码" class="headerlink" title="CountDownLatch源码"></a>CountDownLatch源码</h4><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>一个同步协助，允许一个或多个线程等待，直到完成其他线程中正在执行的一组操作。</p>
<h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    private static final long serialVersionUID = 4982264981922014374L;</span><br><span class="line"></span><br><span class="line">    Sync(int count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getCount() &#123;</span><br><span class="line">        return getState();</span><br><span class="line">    &#125;</span><br><span class="line">/**</span><br><span class="line">     * 重写 AQS 中的 tryAcquireShared</span><br><span class="line">     * 尝试获取共享锁，如果当前 state 等于 0 返回 1 表示获取成功，否      则返回 -1 表示失败</span><br><span class="line">     */</span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return (getState() == 0) ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line"> /**</span><br><span class="line">     * 重写 AQS 中的 tryReleaseShared</span><br><span class="line">     */</span><br><span class="line">    protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">        // Decrement count; signal when transition to zero</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0)</span><br><span class="line">                return false;</span><br><span class="line">            int nextc = c-1;</span><br><span class="line">            if (compareAndSetState(c, nextc))</span><br><span class="line">                return nextc == 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/yueguoyu/yueguoyu.github.io/yueguoyu.github.io/2018/06/28/CountDownLatch分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="越狱">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2018/05/28/5b0b594044b97.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YgY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/yueguoyu.github.io/2018/06/28/CountDownLatch分析/" itemprop="url">CountDownLatch分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T10:16:25+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yueguoyu.github.io/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CountDownLatch分析"><a href="#CountDownLatch分析" class="headerlink" title="CountDownLatch分析"></a>CountDownLatch分析</h2><h4 id="什么是CountDownLatch"><a href="#什么是CountDownLatch" class="headerlink" title="什么是CountDownLatch"></a>什么是CountDownLatch</h4><p><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html" target="_blank" rel="noopener">CountDownLatch</a>是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。</p>
<p>  CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、<a href="http://howtodoinjava.com/2013/05/27/best-practices-for-using-concurrenthashmap/" target="_blank" rel="noopener">ConcurrentHashMap</a>和<a href="http://howtodoinjava.com/2012/10/20/how-to-use-blockingqueue-and-threadpoolexecutor-in-java/" target="_blank" rel="noopener">BlockingQueue</a>，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p>
<p>   使用AQS状态来表示计数，AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架 。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>内部类</strong></p>
<p>Sync继承AQS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    private static final long serialVersionUID = 4982264981922014374L;</span><br><span class="line"></span><br><span class="line">    Sync(int count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getCount() &#123;</span><br><span class="line">        return getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return (getState() == 0) ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">        // Decrement count; signal when transition to zero</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0)</span><br><span class="line">                return false;</span><br><span class="line">            int nextc = c-1;</span><br><span class="line">            if (compareAndSetState(c, nextc))</span><br><span class="line">                return nextc == 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatch &#123;</span><br><span class="line">    // 同步队列</span><br><span class="line">    private final Sync sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有参构造</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">//如果count小于0时则返回IllegalArgumentException</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    //初始化状态数</span><br><span class="line">    this.sync = new Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>无参构造</strong></p>
<p>减少锁存器计数，如果计数为零，释放所有的等待的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>await方法</strong></p>
<p>​    等待锁存器计数为零时，再释放当前线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">//使用了aqs的方法</span><br><span class="line">//在共享模式下获取，如果中断则中止</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在共享模式下获取，如果中断则中止</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">    //设置中断</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>doAcquireSharedInterruptibly方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">       throws InterruptedException &#123;</span><br><span class="line">       // 添加节点至等待队列</span><br><span class="line">       final Node node = addWaiter(Node.SHARED);</span><br><span class="line">       boolean failed = true;</span><br><span class="line">       try &#123;</span><br><span class="line">           for (;;) &#123; // 无限循环</span><br><span class="line">               // 获取node的前驱节点</span><br><span class="line">               final Node p = node.predecessor();</span><br><span class="line">               if (p == head) &#123; // 前驱节点为头结点</span><br><span class="line">                   // 试图在共享模式下获取对象状态</span><br><span class="line">                   int r = tryAcquireShared(arg);</span><br><span class="line">                   if (r &gt;= 0) &#123; // 获取成功</span><br><span class="line">                       // 设置头结点并进行繁殖</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       // 设置节点next域</span><br><span class="line">                       p.next = null; // help GC</span><br><span class="line">                       failed = false;</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt()) // 在获取失败后是否需要禁止线程并且进行中断检查</span><br><span class="line">                   // 抛出异常</span><br><span class="line">                   throw new InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>await（long timeout, TimeUnit unit）方法</strong></p>
<p>导致当前线程等待，直到锁存器计数到<em>为零，除非线程中断，</em>或经过了指定的等待时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//尝试以共享模式获取，如果中断则中止，如果超时，则失败。</span><br><span class="line">public boolean await(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package T616;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class threadTst &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch end=new CountDownLatch(3);</span><br><span class="line"></span><br><span class="line">      new Thread(new play1(1,end)).start();</span><br><span class="line">      new Thread(new play1(2,end)).start();</span><br><span class="line">      new Thread(new play1(3,end)).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            end.await();</span><br><span class="line">            System.out.println(&quot;main&quot;+&quot;****&quot;+Thread.currentThread().getName());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  static class play1 implements Runnable&#123;</span><br><span class="line">        int id;</span><br><span class="line">        CountDownLatch end;</span><br><span class="line">     public play1(int id,CountDownLatch end)&#123;</span><br><span class="line">         this.id=id;</span><br><span class="line">         this.end=end;</span><br><span class="line">     &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              Thread.sleep(1000);</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+&quot;----&quot;+id);</span><br><span class="line">              end.countDown();</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/yueguoyu.github.io/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/yueguoyu.github.io/">1</a><span class="page-number current">2</span><a class="page-number" href="/yueguoyu.github.io/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/yueguoyu.github.io/page/6/">6</a><a class="extend next" rel="next" href="/yueguoyu.github.io/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2018/05/28/5b0b594044b97.jpg"
                alt="越狱" />
            
              <p class="site-author-name" itemprop="name">越狱</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/yueguoyu.github.io/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/yueguoyu.github.io/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/yueguoyu.github.io/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yueguoyu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">越狱</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/yueguoyu.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/yueguoyu.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/yueguoyu.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/yueguoyu.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/yueguoyu.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/yueguoyu.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/yueguoyu.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/yueguoyu.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/yueguoyu.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/yueguoyu.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/yueguoyu.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
